-
  name: "ID query"
  gqlquery: |
    query {
      getAuthor(id: "0x1") {
        name
      }
    }
  dgquery: |-
    query {
      getAuthor(func: uid(0x1)) @filter(type(Author)) {
        name : Author.name
      }
    }

-
  name: "ID query with query alias"
  gqlquery: |
    query {
      author : getAuthor(id: "0x1") {
        name
      }
    }
  dgquery: |-
    query {
      author(func: uid(0x1)) @filter(type(Author)) {
        name : Author.name
      }
    }
    
-
  name: "ID query with field alias"
  gqlquery: |
    query {
      getAuthor(id: "0x1") {
        authName : name
      }
    }
  dgquery: |-
    query {
      getAuthor(func: uid(0x1)) @filter(type(Author)) {
        authName : Author.name
      }
    }

-
  name: "ID field gets transformed to uid"
  gqlquery: |
    query {
      getAuthor(id: "0x1") {
        id
        name
      }
    }
  dgquery: |-
    query {
      getAuthor(func: uid(0x1)) @filter(type(Author)) {
        id : uid
        name : Author.name
      }
    }

-
  name: "ID query with depth"
  gqlquery: |
    query {
      getAuthor(id: "0x1") {
        name
        posts {
          title
          text
        }
      }
    }
  dgquery: |-
    query {
      getAuthor(func: uid(0x1)) @filter(type(Author)) {
        name : Author.name
        posts : Author.posts {
          title : Post.title
          text : Post.text
        }
      }
    }

-
  name: "ID query with depth and alias"
  gqlquery: |
    query {
      getAuthor(id: "0x1") {
        name
        allPosts : posts {
          postTitle : title
          postText : text
        }
      }
    }
  dgquery: |-
    query {
      getAuthor(func: uid(0x1)) @filter(type(Author)) {
        name : Author.name
        allPosts : Author.posts {
          postTitle : Post.title
          postText : Post.text
        }
      }
    }

-
  name: "ID query deep"
  gqlquery: |
    query {
      getAuthor(id: "0x1") {
        name
        allPosts : posts {
          title
          text
          author {
            authorID : id
            name
          }
        }
      }
    }
  dgquery: |-
    query {
      getAuthor(func: uid(0x1)) @filter(type(Author)) {
        name : Author.name
        allPosts : Author.posts {
          title : Post.title
          text : Post.text
          author : Post.author {
            authorID : uid
            name : Author.name
          }
        }
      }
    }

-
  name: "Query with no args is query for everything of that type"
  gqlquery: |
    query {
      queryAuthor {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : Author.name
      }
    }

-
  name: "Filter gets rewritten as @filter"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } }) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter(eq(Author.name, "A. N. Author")) {
        name : Author.name
      }
    }

-
  name: "Filters in same input object implies AND"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" }, dob: { le: "2001-01-01" }, reputation: { gt: 2.5 } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter((le(Author.dob, "2001-01-01") AND eq(Author.name, "A. N. Author") AND gt(Author.reputation, 2.5))) {
        name : Author.name
      }
    }

-
  name: "Filter with nested 'and'"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" }, and: { dob: { le: "2001-01-01" }, and: { reputation: { gt: 2.5 } } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter(((gt(Author.reputation, 2.5) AND le(Author.dob, "2001-01-01")) AND eq(Author.name, "A. N. Author"))) {
        name : Author.name
      }
    }

-
  name: "Filter with 'or'"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" }, or: { dob: { le: "2001-01-01" } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter((eq(Author.name, "A. N. Author") OR le(Author.dob, "2001-01-01"))) {
        name : Author.name
      }
    }


-
  name: "Filter with implied and as well as 'or'"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" }, reputation: { gt: 2.5 }, or: { dob: { le: "2001-01-01" } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter(((eq(Author.name, "A. N. Author") AND gt(Author.reputation, 2.5)) OR le(Author.dob, "2001-01-01"))) {
        name : Author.name
      }
    }

-
  name: "Filter with implied and nested in 'or'"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" }, or: { reputation: { gt: 2.5 }, dob: { le: "2001-01-01" } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter((eq(Author.name, "A. N. Author") OR (le(Author.dob, "2001-01-01") AND gt(Author.reputation, 2.5)))) {
        name : Author.name
      }
    }

-
  name: "Filter nested 'or'"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" }, or: { reputation: { gt: 2.5 }, or: { dob: { le: "2001-01-01" } } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter((eq(Author.name, "A. N. Author") OR (gt(Author.reputation, 2.5) OR le(Author.dob, "2001-01-01")))) {
        name : Author.name
      }
    }

-
  name: "Filter with 'not"
  gqlquery: |
    query {
      queryAuthor(filter: { not: { reputation: { gt: 2.5 } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter(NOT (gt(Author.reputation, 2.5))) {
        name : Author.name
      }
    }

-
  name: "Filter with first"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } }, first: 10) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author), first: 10) @filter(eq(Author.name, "A. N. Author")) {
        name : Author.name
      }
    }

-
  name: "Filter with first and offset"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } }, first: 10, offset: 10) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author), first: 10, offset: 10) @filter(eq(Author.name, "A. N. Author")) {
        name : Author.name
      }
    }

-
  name: "Filter with order asc"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } }, order: { asc: reputation }) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author), orderasc: Author.reputation) @filter(eq(Author.name, "A. N. Author")) {
        name : Author.name
      }
    }

-
  name: "Filter with order desc"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } }, order: { desc: reputation }) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author), orderdesc: Author.reputation) @filter(eq(Author.name, "A. N. Author")) {
        name : Author.name
      }
    }


-
  name: "Filter with nested order"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } }, order: { desc: reputation, then: { asc: dob } }) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author), orderdesc: Author.reputation, orderasc: Author.dob) @filter(eq(Author.name, "A. N. Author")) {
        name : Author.name
      }
    }

-
  name: "Filter with order, first and offset"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } }, order: { desc: reputation }, first: 10, offset: 10) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author), orderdesc: Author.reputation, first: 10, offset: 10) @filter(eq(Author.name, "A. N. Author")) {
        name : Author.name
      }
    }

-
  name: "Deep filter"
  gqlquery: |
    query {
      queryAuthor {
        name
        posts(filter: { title: { anyofterms: "GraphQL" } }) {
          title
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : Author.name
        posts : Author.posts @filter(anyofterms(Post.title, "GraphQL")) {
          title : Post.title
        }
      }
    }


-
  name: "Deep filter with first"
  gqlquery: |
    query {
      queryAuthor {
        name
        posts(filter: { title: { anyofterms: "GraphQL" } }, first: 10) {
          title
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : Author.name
        posts : Author.posts @filter(anyofterms(Post.title, "GraphQL")) (first: 10) {
          title : Post.title
        }
      }
    }

-
  name: "Deep filter with order, first and offset"
  gqlquery: |
    query {
      queryAuthor {
        name
        posts(filter: { title: { anyofterms: "GraphQL" } }, order: { asc: numLikes }, first: 10, offset: 10) {
          title
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : Author.name
        posts : Author.posts @filter(anyofterms(Post.title, "GraphQL")) (orderasc: Post.numLikes, first: 10, offset: 10) {
          title : Post.title
        }
      }
    }


-
  name: "All Float filters work"
  gqlquery: |
    query {
      queryAuthor(filter: { reputation: { gt: 1.1 }, or: { reputation: { ge: 1.1 }, or: { reputation: { lt: 1.1 }, or: { reputation: { le: 1.1 }, or: { reputation: { eq: 1.1 } } } } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter((gt(Author.reputation, 1.1) OR (ge(Author.reputation, 1.1) OR (lt(Author.reputation, 1.1) OR (le(Author.reputation, 1.1) OR eq(Author.reputation, 1.1)))))) {
        name : Author.name
      }
    }

-
  name: "All DateTime filters work"
  gqlquery: |
    query {
      queryAuthor(filter: { dob: { gt: "2000-01-01" }, or: { dob: { ge: "2000-01-01" }, or: { dob: { lt: "2000-01-01" }, or: { dob: { le: "2000-01-01" }, or: { dob: { eq: "2000-01-01" } } } } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter((gt(Author.dob, "2000-01-01") OR (ge(Author.dob, "2000-01-01") OR (lt(Author.dob, "2000-01-01") OR (le(Author.dob, "2000-01-01") OR eq(Author.dob, "2000-01-01")))))) {
        name : Author.name
      }
    }

-
  name: "All Int filters work"
  gqlquery: |
    query {
      queryPost(filter: { numLikes: { gt: 10 }, or: { numLikes: { ge: 10 }, or: { numLikes: { lt: 10 }, or: { numLikes: { le: 10 }, or: { numLikes: { eq: 10 } } } } } } ) {
        title
      }
    }
  dgquery: |-
    query {
      queryPost(func: type(Post)) @filter((gt(Post.numLikes, 10) OR (ge(Post.numLikes, 10) OR (lt(Post.numLikes, 10) OR (le(Post.numLikes, 10) OR eq(Post.numLikes, 10)))))) {
        title : Post.title
      }
    }

-
  name: "All String hash filters work"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter(eq(Author.name, "A. N. Author")) {
        name : Author.name
      }
    }

-
  name: "All String exact filters work"
  gqlquery: |
    query {
      queryCountry(filter: { name: { gt: "AAA" }, or: { name: { ge: "AAA" }, or: { name: { lt: "AAA" }, or: { name: { le: "AAA" }, or: { name: { eq: "AAA" } } } } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryCountry(func: type(Country)) @filter((gt(Country.name, "AAA") OR (ge(Country.name, "AAA") OR (lt(Country.name, "AAA") OR (le(Country.name, "AAA") OR eq(Country.name, "AAA")))))) {
        name : Country.name
      }
    }

-
  name: "All String term filters work"
  gqlquery: |
    query {
      queryPost(filter: { title: { anyofterms: "GraphQL"}, or: { title: { allofterms: "GraphQL" } } } ) {
        title
      }
    }
  dgquery: |-
    query {
      queryPost(func: type(Post)) @filter((anyofterms(Post.title, "GraphQL") OR allofterms(Post.title, "GraphQL"))) {
        title : Post.title
      }
    }


-
  name: "All String fulltext filters work"
  gqlquery: |
    query {
      queryPost(filter: { text: { anyoftext: "GraphQL"}, or: { text: { alloftext: "GraphQL" } } } ) {
        title
      }
    }
  dgquery: |-
    query {
      queryPost(func: type(Post)) @filter((anyoftext(Post.text, "GraphQL") OR alloftext(Post.text, "GraphQL"))) {
        title : Post.title
      }
    }

-
  name: "All String regexp filters work"
  gqlquery: |
    query {
      queryCountry(filter: { name: { regexp: "/.*ust.*/" }}) {
        name
      }
    }
  dgquery: |-
    query {
      queryCountry(func: type(Country)) @filter(regexp(Country.name, /.*ust.*/)) {
        name : Country.name
      }
    }
