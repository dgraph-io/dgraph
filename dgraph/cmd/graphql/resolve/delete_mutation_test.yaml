-
  name: "Only id filter"
  gqlmutation: |
    mutation deleteAuthor($filter: AuthorFilter!) {
      deleteAuthor(filter: $filter)
    }
  gqlvariables: |
    { "filter":
      { "ids": ["0x1", "0x2"] }
    }
  explanation: "The correct mutation and query should be built using variable and filters."
  dgraphmutation: uid(x) * * .
  dgraphquery: |-
    query {
      x as deleteAuthor(func: uid(0x1, 0x2)) @filter(type(Author))
    }

-
  name: "Multiple filters including id"
  gqlmutation: |
    mutation deleteAuthor($filter: AuthorFilter!) {
      deleteAuthor(filter: $filter)
    }
  gqlvariables: |
    { "filter":
      {
        "ids": ["0x1", "0x2"],
        "name": { "eq": "A.N. Author" }
      }
    }
  explanation: "The correct mutation and query should be built using variable and filters."
  dgraphmutation: uid(x) * * .
  dgraphquery: |-
    query {
      x as deleteAuthor(func: uid(0x1, 0x2)) @filter((eq(Author.name, "A.N. Author") AND type(Author)))
    }

-
  name: "Multiple non-id filters"
  gqlmutation: |
    mutation deleteAuthor($filter: AuthorFilter!) {
      deleteAuthor(filter: $filter)
    }
  gqlvariables: |
    { "filter":
      {
        "name": { "eq": "A.N. Author" },
        "dob": { "eq": "2000-01-01" }
      }
    }
  explanation: "The correct mutation and query should be built using variable and filters."
  dgraphmutation: uid(x) * * .
  dgraphquery: |-
    query {
      x as deleteAuthor(func: type(Author)) @filter((eq(Author.dob, "2000-01-01") AND eq(Author.name, "A.N. Author")))
    }


-
  name: "Delete mutation using xid"
  gqlmutation: |
    mutation deleteState($filter: StateFilter!) {
      deleteState(filter: $filter)
    }
  gqlvariables: |
    { "filter": {
        "xid": { "eq": "nsw" }
      }
    }
  explanation: "The delete mutation should get rewritten into a Dgraph upsert mutation"
  dgraphmutation: uid(x) * * .
  dgraphquery: |-
    query {
      x as deleteState(func: type(State)) @filter(eq(State.xid, "nsw"))
    }