/*
 * Copyright 2019 Dgraph Labs, Inc. and Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package resolve

import (
	"encoding/json"
	"fmt"
	"strconv"

	dgoapi "github.com/dgraph-io/dgo/v2/protos/api"
	"github.com/dgraph-io/dgraph/dgraph/cmd/graphql/schema"
	"github.com/dgraph-io/dgraph/gql"
	"github.com/pkg/errors"
)

const (
	createdNode             = "newnode"
	mutationQueryVar        = "x"
	createdUpsertNode       = "uid(x)"
	deleteUIDVarMutation    = `{ "uid": "uid(x)" }`
	addXIDCondition         = "@if(eq(len(x), 0))"
	updateMutationCondition = `@if(gt(len(x), 0))`
)

type addRewriter struct{}
type updateRewriter struct{}
type deleteRewriter struct{}

// NewAddRewriter returns new MutationRewriter for add & update mutations.
func NewAddRewriter() MutationRewriter {
	return &addRewriter{}
}

// NewUpdateRewriter returns new MutationRewriter for add & update mutations.
func NewUpdateRewriter() MutationRewriter {
	return &updateRewriter{}
}

// NewDeleteRewriter returns new MutationRewriter for delete mutations..
func NewDeleteRewriter() MutationRewriter {
	return &deleteRewriter{}
}

// Rewrite takes a GraphQL schema.Mutation and rewrites it to a struct representing
// that mutation that's ready to be marshalled as a Dgraph JSON mutation.  As per
// the schemas generated by 'dgraph graphql init ...`, schema.Mutation m
// must have a single argument called 'input' that carries the mutation data.
//
// That argument could have been passed in the mutation like:
//
// addPost(input: { title: "...", ... })
//
// or be passed in a GraphQL variable like:
//
// addPost(input: $newPost)
//
// Either way, the data needs to have type information added and have some rewriting
// done - for example, rewriting field names from the GraphQL view to what's stored
// in Dgraph, and rewriting ID fields from their names to uid.
//
// For example, a GraphQL add mutation to add an object of type Author,
// with GraphQL input object:
//
// { name: "A.N. Author", country: { id: "0x123" }, posts: [] }
//
// becomes a Dgraph JSON mutation:
//
// { "uid":"_:newnode",
//   "dgraph.type":"Author",
//   "Author.name":"A.N. Author",
//   "Author.country": { "uid": "0x123" },
//   "Author.posts":[]
// }
func (mrw *addRewriter) Rewrite(
	m schema.Mutation) (*gql.GraphQuery, []*dgoapi.Mutation, error) {

	var gqlQuery *gql.GraphQuery

	// ATM mutations aren't very deep.  At worst, a mutation can be one object with
	// reference to other existing objects. e.g. like:
	//
	// { "title": "...", author: { "id": "0x123" }, ... }
	//
	// or, if the schema says a post can have multiple authors
	//
	// { "title": "...", authors: [ { "id": "0x123" }, { "id": "0x321" }, ...] }
	//
	// Later, that'll turn into deeper mutations, so there will be much more to
	// dig through.

	mutatedType := m.MutatedType()

	// ArgValue resolves the argument regardless of if it was passed in the request
	// as an argument or in a GraphQL variable.  All Input arguments are non-nullable
	// so GraphQL validation will ensure that val isn't nil here.  It's also either
	// from a json list or object (not a single value).
	val := m.ArgValue(schema.InputArgName).(map[string]interface{})

	var srcUID string
	var cond string
	xidField := mutatedType.XIDField()
	if xidField == nil {
		srcUID = "_:" + createdNode
	} else {
		srcUID = fmt.Sprintf("uid(%s)", mutationQueryVar)
		xidVal := val[xidField.Name()].(string)
		gqlQuery = rewriteUpsertQueryFromAddMutation(m, xidField.Name(), xidVal)
		cond = addXIDCondition
	}

	obj, err := rewriteObject(mutatedType, nil, srcUID, val)
	if err != nil {
		return nil, nil, err
	}

	obj["uid"] = srcUID
	dgraphTypes := []string{mutatedType.Name()}
	dgraphTypes = append(dgraphTypes, mutatedType.Interfaces()...)
	obj["dgraph.type"] = dgraphTypes

	mutationJSON, err := json.Marshal(obj)
	return gqlQuery,
		[]*dgoapi.Mutation{{
			SetJson: mutationJSON,
			Cond:    cond,
		}},
		schema.GQLWrapf(err, "failed to rewrite mutation payload")

	// TODO: we don't yet have a bulk mutation that takes a list of mutations
	// like
	// addManyPost(input: [{...post1...}, {...post2...}, ...])
	// That'll need to rewrite all of those mutations and keep track of
	// adding blank nodes for every new object, so we can look them up in the
	// later query
	//
	// When that happens the arg type will change
	// from map[string]interface{}
	// to []map[string]interface{}
}

// FromMutationResult rewrites the query part of a GraphQL mutation into a Dgraph query.
func (mrw *addRewriter) FromMutationResult(
	mutation schema.Mutation,
	assigned map[string]string,
	mutated map[string][]string) (*gql.GraphQuery, error) {

	var uid uint64
	var err error

	xidField := mutation.MutatedType().XIDField()
	// If a type has an xid field, then the AddMutation should always return the uid
	// corresponding to an xid field. If no uid is return that means the node already exists
	// which is an error.
	if xidField != nil && len(assigned) == 0 {
		return nil, schema.GQLWrapf(errors.New("add operation failed"),
			"node with given %s already exists", xidField.Name())
	}

	if len(assigned) > 0 {
		// This would be true for upsert operations when a new node is created and also for
		// normal add operations.
		node := createdNode
		if xidField != nil {
			node = createdUpsertNode
		}
		uid, err = strconv.ParseUint(assigned[node], 0, 64)
		if err != nil {
			return nil, schema.GQLWrapf(err,
				"received %s as an assigned uid from Dgraph, but couldn't parse it as uint64",
				assigned[node])

		}
	}

	return rewriteAsGet(mutation.QueryField(), uid, nil), nil
}

// Rewrite rewrites set and delete update patches into a GraphQL+- mutation.
// The GraphQL updates look like:
//
// input UpdateAuthorInput {
// 	filter: AuthorFilter!
// 	set: PatchAuthor
// 	delete: PatchAuthor
// }
//
// which gets rewritten in to a Dgraph upsert mutation
// - filter becomes the query
// - set becomes the Dgraph set mutation
// - delete becomes the Dgraph delete mutation
//
// The semantics is the same as the Dgraph mutation semantics.
// - Any values in set become the new values for those predicates (or add to the existing
//   values for lists)
// - Any nulls in set are ignored.
// - Explicit values in delete mean delete this if it is the actual value
// - Nulls in delete become like delete * for the corresponding predicate.
func (urw *updateRewriter) Rewrite(
	m schema.Mutation) (*gql.GraphQuery, []*dgoapi.Mutation, error) {

	var setObj, delObj map[string]interface{}
	var setJSON, delJSON []byte
	var err error

	mutatedType := m.MutatedType()

	inp := m.ArgValue(schema.InputArgName).(map[string]interface{})
	setArg := inp["set"]
	delArg := inp["remove"]

	if setArg == nil && delArg == nil {
		return nil, nil, nil
	}

	gqlQuery := rewriteUpsertQueryFromMutation(m)
	srcUID := fmt.Sprintf("uid(%s)", mutationQueryVar)

	if setArg != nil {
		setObj, err = rewriteObject(mutatedType, nil, srcUID, setArg.(map[string]interface{}))
		if err != nil {
			return nil, nil, err
		}
		setObj["uid"] = srcUID
		setJSON, err = json.Marshal(setObj)
		if err != nil {
			return nil, nil, schema.GQLWrapf(err, "failed to rewrite mutation payload")
		}
	}

	if delArg != nil {
		delObj, err = rewriteObject(mutatedType, nil, srcUID, delArg.(map[string]interface{}))
		if err != nil {
			return nil, nil, err
		}
		delObj["uid"] = srcUID
		delJSON, err = json.Marshal(delObj)
		if err != nil {
			return nil, nil, schema.GQLWrapf(err, "failed to rewrite mutation payload")
		}
	}

	return gqlQuery,
		[]*dgoapi.Mutation{{
			SetJson:    setJSON,
			DeleteJson: delJSON,
			Cond:       updateMutationCondition,
		}},
		schema.GQLWrapf(err, "failed to rewrite mutation payload")
}

// FromMutationResult rewrites the query part of a GraphQL mutation into a Dgraph query.
func (urw *updateRewriter) FromMutationResult(
	mutation schema.Mutation,
	assigned map[string]string,
	mutated map[string][]string) (*gql.GraphQuery, error) {

	var uids []uint64
	if len(mutated) > 0 {
		// This is the case of a conditional upsert where we should get uids from mutated.
		stringUids := mutated[mutationQueryVar]
		for _, id := range stringUids {
			uid, err := strconv.ParseUint(id, 0, 64)
			if err != nil {
				return nil, schema.GQLWrapf(err,
					"received %s as an updated uid from Dgraph, but couldn't parse it as "+
						"uint64", id)
			}
			uids = append(uids, uid)
		}
	}

	return rewriteAsQueryByIds(mutation.QueryField(), uids), nil
}

func extractFilter(m schema.Mutation) map[string]interface{} {
	var filter map[string]interface{}
	mutationType := m.MutationType()
	if mutationType == schema.UpdateMutation {
		input, ok := m.ArgValue("input").(map[string]interface{})
		if ok {
			filter, _ = input["filter"].(map[string]interface{})
		}
	} else if mutationType == schema.DeleteMutation {
		filter, _ = m.ArgValue("filter").(map[string]interface{})
	}
	return filter
}

// For a mutation on a type with a field which has @id directive, this function rewrites it as an
// upsert query.
func rewriteUpsertQueryFromAddMutation(m schema.Mutation, xidField, xidVal string) *gql.GraphQuery {
	gqlQuery := &gql.GraphQuery{
		Var:  mutationQueryVar,
		Attr: m.ResponseName(),
	}
	gqlQuery.Func = &gql.Function{
		Name: "eq",
		Args: []gql.Arg{
			{Value: m.MutatedType().DgraphPredicate(xidField)},
			{Value: maybeQuoteArg("eq", xidVal)},
		},
	}
	addTypeFilter(gqlQuery, m.MutatedType())
	return gqlQuery
}

func rewriteUpsertQueryFromMutation(m schema.Mutation) *gql.GraphQuery {
	// The query needs to assign the results to a variable, so that the mutation can use them.
	dgQuery := &gql.GraphQuery{
		Var:  mutationQueryVar,
		Attr: m.ResponseName(),
	}

	if ids := idFilter(m); ids != nil {
		addUIDFunc(dgQuery, ids)
	} else {
		addTypeFunc(dgQuery, m.MutatedType().Name())
	}

	filter := extractFilter(m)
	addFilter(dgQuery, m.Type(), filter)
	return dgQuery
}

func (drw *deleteRewriter) Rewrite(m schema.Mutation) (
	*gql.GraphQuery, []*dgoapi.Mutation, error) {
	if m.MutationType() != schema.DeleteMutation {

		return nil, nil, errors.Errorf(
			"(internal error) call to build delete mutation for %s mutation type",
			m.MutationType())
	}

	return rewriteUpsertQueryFromMutation(m),
		[]*dgoapi.Mutation{{
			DeleteJson: []byte(deleteUIDVarMutation),
		}},
		nil
}

func (drw *deleteRewriter) FromMutationResult(
	mutation schema.Mutation,
	assigned map[string]string,
	mutated map[string][]string) (*gql.GraphQuery, error) {

	// There's no query that follows a delete
	return nil, nil
}

func asUIDs(vals []interface{}) ([]uint64, error) {
	if vals == nil {
		return nil, nil
	}

	uids := make([]uint64, 0, len(vals))
	for _, val := range vals {
		id, ok := val.(string)
		uid, err := strconv.ParseUint(id, 0, 64)

		if !ok || err != nil {
			return nil, errors.Errorf("ID argument (%s) was not able to be parsed", id)
		}
		uids = append(uids, uid)
	}

	return uids, nil
}

// We are processing a mutation and got to an object obj like
//
// { "title": "...", author: { "id": "0x123" }, ... }
//
// here we process that object as being of type typ.  If we got here
// as a nested object like
//
// { "blaa" : { "title" ... }}
//
// then scrField is the field of that enclosing object and srcUID is the uid
// of that node (either a blank node or the actual uid).  If this is the top level
// of the mutation, then scrField will be nil and srcUID will be the top level
// uid or blank node of the mutation.
func rewriteObject(
	typ schema.Type,
	srcField schema.FieldDefinition,
	srcUID string,
	obj map[string]interface{}) (map[string]interface{}, error) {

	// GraphQL validation has already ensured that the types of arguments
	// (or variables) are correct and has ensured that non-nullables are
	// not null.  If this is an add mutation, that's all that's needed.
	// But an update mutation doesn't set the same restrictions:
	// e.g. a Post might have `title: String!`` in the schema, but, you
	// don't need to update the title everytime you make a post update,
	// so the input type for an update mutation might have `title: String`.
	//
	// That means a Post update could set a non-nullable field to null.
	// ATM we allow this and it'll just triggers GraphQL error propagation
	// when that is in a query result.  This is the same case as deletes:
	// e.g. deleting an author might make the `author: Author!` field of
	// a bunch of Posts invalid.
	// (That might actually be helpful if you want to run one
	// mutation to remove something and then another to correct it.)
	//
	// The long term plan is to allow the server to run in different modes.
	// Or even allow mutations to run in different modes.  One (like above)
	// will allow this breaking of referential integrity, other modes
	// might enforce it an reject a mutation if it breaks, or even might
	// have some sort of cascading delete or for scalars allow 'deleting'
	// to set to a default value.

	result := make(map[string]interface{}, len(obj))

	for field, val := range obj {
		var res interface{}
		var err error

		fieldDef := typ.Field(field)
		fieldName := typ.DgraphPredicate(field)

		switch val := val.(type) {
		case map[string]interface{}:
			// TODO: Because mutations are just one level deep, we don't have to
			// reset the srcUID.  Once they are deeper, we first have to look up
			// the current UID and then set to that.
			res, err = rewriteObject(fieldDef.Type(), fieldDef, srcUID, val)
		case []interface{}:
			// This field is either a list of objects
			// { "title": "...", "authors": [ { "id": "0x123" }, { "id": "0x321" }, ...] }
			//          like here ^^
			// or it's a list of scalars - e.g. if schema said `scores: [Float]`
			// { "title": "...", "scores": [10.5, 9.3, ... ]
			//          like here ^^
			res, err = rewriteList(fieldDef.Type(), fieldDef, srcUID, val)
		default:
			// scalar value
			res = val

			if fieldDef.IsID() {
				fieldName = "uid"

				_, err := asUIDs([]interface{}{val})
				if err != nil {
					return nil, err
				}

				// If the mutation contains a reference to another node, e.g it was
				// say adding a post with:
				// { "title": "...", "author": { "id": "0x123" }, ... }
				// and we've gotten into here  ^^^^
				// and the schema says that Post.author and Author.Posts are inverses
				// of each other, then we need to make sure the inverse link is
				// added.  We have to make sure it ends up like
				//
				// { "title": "...", "author": { "id": "0x123", "posts": { "uid": ... } }, ... }
				//
				// We already know that "posts" isn't going to be in val because the
				// schema rules say that a reference to another type in an add/update
				// must either be just an object reference like
				//
				// "author": { "id": "0x123" }
				//
				// or must be a whole new node (<- TODO: that case isn't in schema yet)
				if srcField != nil {
					invType, invField := srcField.Inverse()
					if invType != nil && invField != nil {
						result[fmt.Sprintf("%s.%s", invType.Name(), invField.Name())] =
							map[string]interface{}{"uid": srcUID}
					}
				}
			}
		}
		if err != nil {
			return nil, err
		}
		result[fieldName] = res
	}

	return result, nil
}

func rewriteList(
	typ schema.Type,
	srcField schema.FieldDefinition,
	srcUID string,
	objects []interface{}) ([]interface{}, error) {

	result := make([]interface{}, len(objects))

	for i, obj := range objects {
		switch obj := obj.(type) {
		case map[string]interface{}:
			res, err := rewriteObject(typ, srcField, srcUID, obj)
			if err != nil {
				return nil, err
			}
			result[i] = res
		default:
			// scalar value - can't be a list because lists of lists aren't allowed
			result[i] = obj
		}
	}

	return result, nil
}
