-
  name: "Add mutation with variables"
  gqlmutation: |
    mutation addAuthor($auth: AuthorInput!) {
      addAuthor(input: $auth) {
        author {
          name
        }
      }
    }
  gqlvariables: |
    { "auth":
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": []
      }
    }
  explanation: "A uid and type should get injected and all data transformed to
    underlying Dgraph edge names"
  dgraphmutation: |
    { "uid":"_:newnode",
      "dgraph.type":["Author"],
      "Author.name":"A.N. Author",
      "Author.dob":"2000-01-01",
      "Author.posts":[]
    }

-
  name: "Add Mutation with embedded value"
  gqlmutation: |
    mutation addAuthor {
      addAuthor(input: { name: "A.N. Author", posts: []}) {
        author {
          name
        }
      }
    }
  explanation: "The input should be used for the mutation, with a uid and type getting
    injected and all data transformed to underlying Dgraph edge names"
  dgraphmutation: |
    { "uid":"_:newnode",
      "dgraph.type":["Author"],
      "Author.name":"A.N. Author",
      "Author.posts":[]
    }

-
  name: "Add Mutation with mixed vars and embedded value"
  gqlmutation: |
    mutation addAuthor($name: String!) {
      addAuthor(input: { name: $name, posts: []}) {
        author {
          name
        }
      }
    }
  gqlvariables: |
    { "name":  "A.N. Author" }
  explanation: "The input and variables should be used for the mutation, with a uid and type
    getting injected and all data transformed to underlying Dgraph edge names"
  dgraphmutation: |
    { "uid":"_:newnode",
      "dgraph.type":["Author"],
      "Author.name":"A.N. Author",
      "Author.posts":[]
    }

-
  name: "Add mutation with reference"
  gqlmutation: |
    mutation addAuthor($auth: AuthorInput!) {
      addAuthor(input: $auth) {
        author {
          name
        }
      }
    }
  gqlvariables: |
    { "auth":
      { "name": "A.N. Author",
        "country": { "id": "0x123" },
        "posts": []
      }
    }
  explanation: "The reference to country should get transformed to 'uid' for the
    Dgraph JSON mutation"
  dgraphmutation: |
    { "uid":"_:newnode",
      "dgraph.type":["Author"],
      "Author.name":"A.N. Author",
      "Author.country": { "uid": "0x123" },
      "Author.posts":[]
    }

-
  name: "Add mutation with invalid reference"
  gqlmutation: |
    mutation addAuthor($auth: AuthorInput!) {
      addAuthor(input: $auth) {
        author {
          name
        }
      }
    }
  gqlvariables: |
    { "auth":
      { "name": "A.N. Author",
        "country": { "id": "HI!" },
        "posts": []
      }
    }
  explanation: "A reference must be a valid UID"
  error:
    { "message": "ID argument (HI!) was not able to be parsed" }

-
  name: "Add mutation with inverse reference"
  gqlmutation: |
    mutation addPost($post: PostInput!) {
      addPost(input: $post) {
        post {
          postId
        }
      }
    }
  gqlvariables: |
    { "post":
      { "title": "Exciting post",
        "text": "A really good post",
        "author": { "id": "0x2" }
      }
    }
  explanation: "The reference to the author node should be transformed to include
    a new 'posts' edge."
  dgraphmutation: |
    { "uid" : "_:newnode",
      "dgraph.type" : ["Post"],
      "Post.title" : "Exciting post",
      "Post.text" : "A really good post",
      "Post.author": {
        "uid" : "0x2",
        "Author.posts" : { "uid": "_:newnode" }
      }
    }

-
  name: "Update mutation with variables"
  gqlmutation: |
    mutation updatePost($patch: UpdatePostInput!) {
      updatePost(input: $patch) {
        post {
          postId
        }
      }
    }
  gqlvariables: |
    { "patch":
      { "filter": {
          "ids": ["0x123", "0x124"]
        },
        "patch": {
          "text": "updated text"
        }
      }
    }
  explanation: "The update patch should get rewritten into the Dgraph mutation"
  dgraphmutation: |
    { "uid" : "uid(x)",
      "Post.text": "updated text"
    }
  dgraphquery: |-
    query {
      x as updatePost(func: type(Post)) @filter(uid(0x123, 0x124))
    }
  condition: "@if(gt(len(x), 0))"

-
  name: "Add mutation for a type that implements an interface"
  gqlmutation: |
    mutation addHuman($human: HumanInput!) {
      addHuman(input: $human) {
        human {
          name
          dob
          female
        }
      }
    }
  gqlvariables: |
    { "human":
      { "name": "Bob",
        "dob": "2000-01-01",
        "female": true,
        "ename": "employee no. 1"
      }
    }
  explanation: "The mutation should get rewritten with correct edges from the interface."
  dgraphmutation: |
    { "uid" : "_:newnode",
      "Character.name": "Bob",
      "Employee.ename": "employee no. 1",
      "Human.dob": "2000-01-01",
      "Human.female": true,
      "dgraph.type": ["Human", "Character", "Employee"]
    }


-
  name: "Update mutation for a type that implements an interface"
  gqlmutation: |
    mutation updateHuman($patch: UpdateHumanInput!) {
      updateHuman(input: $patch) {
        human {
          name
          dob
          female
        }
      }
    }
  gqlvariables: |
    { "patch":
      {
        "filter": {
          "ids": ["0x123"]
        },
        "patch": { "name": "Bob",
          "dob": "2000-01-01",
          "female": true,
          "ename": "employee no. 1"
        }
      }
    }
  explanation: "The mutation should get rewritten with correct edges from the interface."
  dgraphmutation: |
    { "uid" : "uid(x)",
      "Character.name": "Bob",
      "Employee.ename": "employee no. 1",
      "Human.dob": "2000-01-01",
      "Human.female": true
    }
  dgraphquery: |-
    query {
      x as updateHuman(func: type(Human)) @filter(uid(0x123))
    }
  condition: "@if(gt(len(x), 0))"

-
  name: "Update mutation for an interface"
  gqlmutation: |-
    mutation {
      updateCharacter(input: {filter: { ids: ["0x123"] }, patch: {name:"Bob"}}) {
        character {
          id
          name
        }
      }
    }
  explanation: "The mutation should get rewritten with correct edges from the interface."
  dgraphmutation: |
    { "uid" : "uid(x)",
      "Character.name": "Bob"
    }
  dgraphquery: |-
    query {
      x as updateCharacter(func: type(Character)) @filter(uid(0x123))
    }
  condition: "@if(gt(len(x), 0))"

-
  name: "Update mutation using filters"
  gqlmutation: |
    mutation updatePost($patch: UpdatePostInput!) {
      updatePost(input: $patch) {
        post {
          postId
        }
      }
    }
  gqlvariables: |
    { "patch":
      { "filter": {
          "tags": { "eq": "foo"}
        },
        "patch": {
          "text": "updated text"
        }
      }
    }
  explanation: "The update patch should get rewritten into the Dgraph mutation"
  dgraphmutation: |
    { "uid" : "uid(x)",
      "Post.text": "updated text"
    }
  dgraphquery: |-
    query {
      x as updatePost(func: type(Post)) @filter(eq(Post.tags, "foo"))
    }
  condition: "@if(gt(len(x), 0))"

-
  name: "Add mutation using code"
  gqlmutation: |
    mutation addState($input: StateInput!) {
      addState(input: $input) {
        state {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "code": "nsw",
        "name": "NSW",
        "country": { "id": "0x12" }
      }
    }
  explanation: "The add mutation should get rewritten into a Dgraph upsert mutation"
  dgraphmutation: |
    { "uid" : "uid(x)",
      "dgraph.type": ["State"],
      "State.name": "NSW",
      "State.code": "nsw",
      "State.country": {
        "uid": "0x12"
      }
    }
  dgraphquery: |-
    query {
      x as addState(func: eq(State.code, "nsw")) @filter(type(State))
    }
  condition: "@if(eq(len(x), 0))"

-
  name: "Update mutation using code"
  gqlmutation: |
    mutation updateState($patch: UpdateStateInput!) {
      updateState(input: $patch) {
        state {
          name
        }
      }
    }
  gqlvariables: |
    { "patch":
      { "filter": {
          "code": { "eq": "nsw" }
        },
        "patch": {
          "name": "nsw"
        }
      }
    }
  explanation: "The update mutation should get rewritten into a Dgraph upsert mutation"
  dgraphmutation: |
    { "uid" : "uid(x)",
      "State.name": "nsw"
    }
  dgraphquery: |-
    query {
      x as updateState(func: type(State)) @filter(eq(State.code, "nsw"))
    }
  condition: "@if(gt(len(x), 0))"

-
  name: "Add mutation using code on type which also has an ID field"
  gqlmutation: |
    mutation addEditor($input: EditorInput!) {
      addEditor(input: $input) {
        editor {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "code": "editor",
        "name": "A.N. Editor"
      }
    }
  explanation: "The add mutation should get rewritten into a Dgraph upsert mutation"
  dgraphmutation: |
    { "uid" : "uid(x)",
      "dgraph.type": ["Editor"],
      "Editor.name": "A.N. Editor",
      "Editor.code": "editor"
    }
  dgraphquery: |-
    query {
      x as addEditor(func: eq(Editor.code, "editor")) @filter(type(Editor))
    }
  condition: "@if(eq(len(x), 0))"

-
  name: "Update mutation using code on type which also has an ID field"
  gqlmutation: |
    mutation updateEditor($patch: UpdateEditorInput!) {
      updateEditor(input: $patch) {
        editor {
          name
        }
      }
    }
  gqlvariables: |
    { "patch":
      { "filter": {
          "code": { "eq": "editor" },
          "ids": [ "0x1", "0x2" ]
        },
        "patch": {
          "name": "A.N. Editor"
        }
      }
    }
  explanation: "The update mutation should get rewritten into a Dgraph upsert mutation"
  dgraphmutation: |
    { "uid" : "uid(x)",
      "Editor.name": "A.N. Editor"
    }
  dgraphquery: |-
    query {
      x as updateEditor(func: type(Editor)) @filter((eq(Editor.code, "editor") AND uid(0x1, 0x2)))
    }
  condition: "@if(gt(len(x), 0))"

