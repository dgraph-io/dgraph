invalid_schemas:
  -
    name: "More than 1 id field"
    input: |
      type P {
        id1: ID!
        id2: ID!
        id3: ID!
      }
    errlist: [
      {"message":"Fields id1, id2 and id3 are listed as IDs for type P, but a type can have only one ID field. Pick a single field as the ID for type P.", "locations":[{"line":2, "column":3}, {"line":3, "column":3}, {"line":4, "column":3}]},
    ]

  -
    name: "Query, Mutation in initial schema"
    input: |
      type Query {
        getAuthro(id: ID): Author!
      }
      type Mutation {
        getAuthro(id: ID): Author!
      }
    errlist: [
      {"message":"You don't need to define the GraphQL Query or Mutation types. Those are built automatically for you.", "locations":[{"line":1, "column":6}]},
      {"message":"You don't need to define the GraphQL Query or Mutation types. Those are built automatically for you.", "locations":[{"line":4, "column":6}]},
    ]

  -
    name: "Invalid list type"
    input: |
      type A {
        posts: [A]!
      }
    errlist: [
      {"message":"[A]! lists are invalid. Valid options are [A!]! and [A!].", "locations":[{"line":2, "column":3}]},
    ]

  -
    name: "Unsupported definitions in initial schema"
    input: |
      scalar Int
      interface P {
        t: T!
      }
      union Q = R | S | T
      input U {
        x: X!
      }
    errlist: [
      {"message":"You can't add scalar definitions. Only type, interface and enums are allowed in initial schema.", "locations":[{"line":1, "column":8}]},
      {"message":"You can't add union definitions. Only type, interface and enums are allowed in initial schema.", "locations":[{"line":5, "column":7}]},
      {"message":"You can't add input_object definitions. Only type, interface and enums are allowed in initial schema.", "locations":[{"line":6, "column":7}]},
    ]

  -
    name: "Typename is reserved word"
    input: |
      type String {
        id: ID!
      }
    errlist: [
      {"message":"String is a reserved word, so you can't declare a type with this name. Pick a different name for the type.", "locations":[{"line":1, "column":6}]},
    ]

  -
    name: "More than 1 errors"
    input: |
      type X {
        i1: ID!
        i2: ID!
        i3: ID!
        l1: [X]!
      }
    errlist: [
      {"message":"Fields i1, i2 and i3 are listed as IDs for type X, but a type can have only one ID field. Pick a single field as the ID for type X.", "locations":[{"line":2, "column":3}, {"line":3, "column":3}, {"line":4, "column":3}]},
      {"message":"[X]! lists are invalid. Valid options are [X!]! and [X!].", "locations":[{"line":5, "column":3}]},
    ]

  -
    name: "Union type in schema"
    input: |
      union U = R | S | T
    errlist: [
      {"message":"You can't add union definitions. Only type, interface and enums are allowed in initial schema.", "locations":[{"line":1, "column":7}]}
    ]

  -
    name: "Non linking inverse directives"
    input: |
      type X {
        f1: P @hasInverse(field: "f1")
        f2: String
      }
      type P {
        f1: X @hasInverse(field: "f2")
      }
    errlist: [
      {"message":"Type X; Field f1: @hasInverse is required in both the directions to link the fields, but field f1 of type P doesn't have @hasInverse directive pointing to field f1 of type X. To link these add @hasInverse in both directions.", "locations":[{"line":2, "column":10}]},
      {"message":"Type P; Field f1: @hasInverse is required in both the directions to link the fields, but field f2 of type X doesn't have @hasInverse directive pointing to field f1 of type P. To link these add @hasInverse in both directions.", "locations":[{"line":6, "column":10}]},
    ]

  -
    name: "Inverse Directive on non object field"
    input: |
      type X {
        f1: String @hasInverse(field: "f1")
      }
    errlist: [
      {"message":"Type X; Field f1: Field f1 is of type String, but @hasInverse directive only applies to fields with object types.", "locations":[{"line":2, "column":3}]},
    ]

  -
    name: "Inverse Directive doesn't have field argument"
    input: |
      type X {
        f1: X @hasInverse
      }
    errlist: [
      {"message":"Type X; Field f1: @hasInverse directive doesn't have field argument.", "locations":[{"line":2, "column":10}]},
    ]

  -
    name: "hasInverse on non existing field"
    input: |
      type X {
        f1: [P!]! @hasInverse(field: "f2")
      }
      type P  {
        f1: String
      }
    errlist: [
      {"message":"Type X; Field f1: inverse field f2 doesn't exist for type P.", "locations":[{"line":2, "column":14}]},
    ]

  -
    name: "ID is not searchable"
    input: |
      type X {
        id: ID! @searchable
      }
      type Y {
        id: ID! @searchable(by: term)
      }
    errlist: [
      {"message": "Type X; Field id: has the @searchable directive but fields of type ID are
          not searchable.",
      "locations":[{"line":2, "column":12}]},
      {"message": "Type Y; Field id: has the @searchable directive but the argument term doesn't
          apply to field type ID.  Searchable term applies to fields of type String. Fields of type
          ID are not searchable.",
      "locations":[{"line":5, "column":12}]}
      ]

  -
    name: "Searchable will error on un-searchableType"
    input: |
      type X {
        y: Y @searchable
      }
      type Y {
        y: String
      }
    errlist: [
      {"message": "Type X; Field y: has the @searchable directive but fields of type Y
          are not searchable.",
      "locations":[{"line":2, "column":9}]}
      ]

  -
    name: "Searchable (with arg) will error on un-searchableType"
    input: |
      type X {
        y: Y @searchable(by: term)
      }
      type Y {
        y: String
      }
    errlist: [
      {"message": "Type X; Field y: has the @searchable directive but the argument term doesn't
          apply to field type Y.  Searchable term applies to fields of type String. Fields of
          type Y are not searchable.",
      "locations":[{"line":2, "column":9}]}
      ]

  -
    name: "Searchable with wrong arg with error on default searchable type"
    input: |
      type X {
        y: Int @searchable(by: term)
      }
    errlist: [
      {"message": "Type X; Field y: has the @searchable directive but the argument term doesn't
          apply to field type Int.  Searchable term applies to fields of type String. Fields of
          type Int are searchable by just @searchable.",
      "locations":[{"line":2, "column":11}]}
      ]

  -
    name: "Searchable with wrong arg with error on searchable type"
    input: |
      type X {
        y: String @searchable(by: day)
      }
    errlist: [
      {"message": "Type X; Field y: has the @searchable directive but the argument day doesn't
          apply to field type String.  Searchable day applies to fields of type DateTime. Fields
          of type String are searchable by exact, fulltext, hash, term and trigram.",
      "locations":[{"line":2, "column":14}]}
      ]

  -
    name: "Searchable doesn't accept bogus args"
    input: |
      type X {
        y: String @searchable(by: bogus)
      }
    errlist: [
      {"message": "Type X; Field y: the argument to @searchable bogus isn't valid.Fields of type
          String are searchable by exact, fulltext, hash, term and trigram.",
      "locations":[{"line":2, "column":14}]}
      ]

  -
    name: "Type implements an interface which wasn't defined"
    input: |
      type X implements Y {
        y: String
      }
    errlist: [
      {"message": Undefined type "Y".,
      "locations":[{"line":1, "column":6}]}
      ]

  -
    name: "Type implemets an interface with the field definition repeated"
    input: |
      interface Y {
        id: ID
      }
      type X implements Y {
        id: ID
        y: String
      }
    errlist: [
      {"message": "Field X.id can only be defined once.",
      "locations":[{"line":5, "column":3}]}
      ]

  -
    name: "Type implements an interface with the field name repeated but different type"
    input: |
      interface Y {
        id: ID
      }
      type X implements Y {
        id: String
        y: String
      }
    errlist: [
      {"message": "Field X.id can only be defined once.",
      "locations":[{"line":5, "column":3}]}
      ]

  -
    name: "Type implemets an interface with no field of its own"
    input: |
      interface Y {
        id: ID
      }
      type X implements Y {
      }
    errlist: [
      {"message": "expected at least one definition, found }",
      "locations":[{"line":5, "column":1}]}
      ]

  -
    name: "Type implements from two interfaces where both have ID"
    input: |
      interface X {
        id: ID
      }
      interface Y {
        id: ID
      }
      type Z implements X & Y {
        name: String
      }
    errlist: [
      {"message": "Field Z.id can only be defined once.",
      "locations":[{"line":2, "column":3}]}
      ]

  -
    name: "List of Boolean is not allowed"
    input: |
      type X {
        q: [Boolean]
      }
    errlist: [
      {"message": "[Boolean] lists are invalid. Only Boolean scalar fields are allowed.",
      "locations":[{"line":2, "column":3}]}
      ]


valid_schemas:
  -
    name: "hasInverse directive on singleton"
    input: |
      type X {
        f1: Y @hasInverse(field: "f1")
      }
      type Y {
        f1: X @hasInverse(field: "f1")
      }

  -
    name: "hasInverse directive on list type 1"
    input: |
      type X {
        f1: [Y] @hasInverse(field: "f1")
      }
      type Y {
        f1: X @hasInverse(field: "f1")
      }

  -
    name: "hasInverse directive on list type 2"
    input: |
      type X {
        f1: [Y] @hasInverse(field: "f1")
      }
      type Y {
        f1: [X] @hasInverse(field: "f1")
      }

  -
    name: "Correct searchable types"
    input: |
      type X {
        int1: Int @searchable
        int2: Int @searchable(by: int)
        float1: Float @searchable
        float2: Float @searchable(by: float)
        bool1: Boolean @searchable
        bool2: Boolean @searchable(by: bool)
        str: String @searchable
        strHash: String @searchable(by: hash)
        strExact: String @searchable(by: exact)
        strTerm: String @searchable(by: term)
        strFulltext: String @searchable(by: fulltext)
        strTrigram: String @searchable(by: trigram)
        dt: DateTime @searchable
        dtYear: DateTime @searchable(by: year)
        dtMonth: DateTime @searchable(by: month)
        dtDay: DateTime @searchable(by: day)
        dtHour: DateTime @searchable(by: hour)
        enumFld: E @searchable
        req: String! @searchable(by: term)
        list: [Int] @searchable
        reqList: [DateTime!]! @searchable
      }
      enum E {
        A
      }
