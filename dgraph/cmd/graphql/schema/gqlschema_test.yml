invalid_schemas:
  -
    name: "More than 1 id field"
    input: |
      type P {
        id1: ID!
        id2: ID!
        id3: ID!
      }
    errlist: [
      {"message":"Fields id1, id2 and id3 are listed as IDs for type P, but a type can have only one ID field. Pick a single field as the ID for type P.", "locations":[{"line":2, "column":3}, {"line":3, "column":3}, {"line":4, "column":3}]},
    ]

  -
    name: "Query, Mutation in initial schema"
    input: |
      type Query {
        getAuthro(id: ID): Author!
      }
      type Mutation {
        getAuthro(id: ID): Author!
      }
    errlist: [
      {"message":"You don't need to define the GraphQL Query or Mutation types. Those are built automatically for you.", "locations":[{"line":1, "column":6}]},
      {"message":"You don't need to define the GraphQL Query or Mutation types. Those are built automatically for you.", "locations":[{"line":4, "column":6}]},
    ]

  -
    name: "Invalid list type"
    input: |
      type A {
        posts: [A]!
      }
    errlist: [
      {"message":"[A]! lists are invalid. Valid options are [A!]! and [A!].", "locations":[{"line":2, "column":3}]},
    ]

  -
    name: "Unsupported definitions in initial schema"
    input: |
      scalar Int
      interface P {
        t: T!
      }
      union Q = R | S | T
      input U {
        x: X!
      }
    errlist: [
      {"message":"You can't add scalar definitions. Only type, interface and enums are allowed in initial schema.", "locations":[{"line":1, "column":8}]},
      {"message":"You can't add union definitions. Only type, interface and enums are allowed in initial schema.", "locations":[{"line":5, "column":7}]},
      {"message":"You can't add input_object definitions. Only type, interface and enums are allowed in initial schema.", "locations":[{"line":6, "column":7}]},
    ]

  -
    name: "Typename is reserved word"
    input: |
      type String {
        id: ID!
      }
    errlist: [
      {"message":"String is a reserved word, so you can't declare a type with this name. Pick a different name for the type.", "locations":[{"line":1, "column":6}]},
    ]

  -
    name: "More than 1 errors"
    input: |
      type X {
        i1: ID!
        i2: ID!
        i3: ID!
        l1: [X]!
      }
    errlist: [
      {"message":"Fields i1, i2 and i3 are listed as IDs for type X, but a type can have only one ID field. Pick a single field as the ID for type X.", "locations":[{"line":2, "column":3}, {"line":3, "column":3}, {"line":4, "column":3}]},
      {"message":"[X]! lists are invalid. Valid options are [X!]! and [X!].", "locations":[{"line":5, "column":3}]},
    ]

  -
    name: "Union type in schema"
    input: |
      union U = R | S | T
    errlist: [
      {"message":"You can't add union definitions. Only type, interface and enums are allowed in initial schema.", "locations":[{"line":1, "column":7}]}
    ]

  -
    name: "Non linking inverse directives"
    input: |
      type X {
        f1: P @hasInverse(field: "f3")
        f2: String
      }
      type P {
        f3: X @hasInverse(field: "f2")
      }
    errlist: [
      {"message":"Type X; Field f1: @hasInverse is required in both the directions to link the fields, but field f3 of type P doesn't have @hasInverse directive pointing to field f1 of type X. To link these add @hasInverse in both directions.", "locations":[{"line":2, "column":10}]},
      {"message":"Type P; Field f3: @hasInverse is required in both the directions to link the fields, but field f2 of type X doesn't have @hasInverse directive pointing to field f3 of type P. To link these add @hasInverse in both directions.", "locations":[{"line":6, "column":10}]},
    ]

  -
    name: "Inverse Directive on non object field"
    input: |
      type X {
        f1: String @hasInverse(field: "f1")
      }
    errlist: [
      {"message":"Type X; Field f1: Field f1 is of type String, but @hasInverse directive only applies to fields with object types.", "locations":[{"line":2, "column":3}]},
    ]

  -
    name: "Inverse Directive doesn't have field argument"
    input: |
      type X {
        f1: X @hasInverse
      }
    errlist: [
      {"message":"Type X; Field f1: @hasInverse directive doesn't have field argument.", "locations":[{"line":2, "column":10}]},
    ]

  -
    name: "hasInverse on non existing field"
    input: |
      type X {
        f1: [P!]! @hasInverse(field: "f2")
      }
      type P  {
        f3: String
      }
    errlist: [
      {"message":"Type X; Field f1: inverse field f2 doesn't exist for type P.", "locations":[{"line":2, "column":14}]},
    ]

  -
    name: "ID can't have the @search directive"
    input: |
      type X {
        id: ID! @search
      }
      type Y {
        id: ID! @search(by: term)
      }
    errlist: [
      {"message": "Type X; Field id: has the @search directive but fields of type ID can't
          have the @search directive.",
      "locations":[{"line":2, "column":12}]},
      {"message": "Type Y; Field id: has the @search directive but the argument term doesn't
          apply to field type ID.  Search by term applies to fields of type String. Fields of type
          ID can't have the @search directive.",
      "locations":[{"line":5, "column":12}]}
      ]

  -
    name: "Search will error on type that can't have the @search"
    input: |
      type X {
        y: Y @search
      }
      type Y {
        Z: String
      }
    errlist: [
      {"message": "Type X; Field y: has the @search directive but fields of type Y
          can't have the @search directive.",
      "locations":[{"line":2, "column":9}]}
      ]

  -
    name: "Search (with arg) will error that can't have the @search"
    input: |
      type X {
        y: Y @search(by: term)
      }
      type Y {
        Z: String
      }
    errlist: [
      {"message": "Type X; Field y: has the @search directive but the argument term doesn't
          apply to field type Y.  Search by term applies to fields of type String. Fields of
          type Y can't have the @search directive.",
      "locations":[{"line":2, "column":9}]}
      ]

  -
    name: "Search with wrong arg with error on default search type"
    input: |
      type X {
        y: Int @search(by: term)
      }
    errlist: [
      {"message": "Type X; Field y: has the @search directive but the argument term doesn't
          apply to field type Int.  Search by term applies to fields of type String. Fields of
          type Int are searchable by just @search.",
      "locations":[{"line":2, "column":11}]}
      ]

  -
    name: "Search with wrong arg with error on search type"
    input: |
      type X {
        y: String @search(by: day)
      }
    errlist: [
      {"message": "Type X; Field y: has the @search directive but the argument day doesn't
          apply to field type String.  Search by day applies to fields of type DateTime. Fields
          of type String can have @search by exact, fulltext, hash, regexp, term and trigram.",
      "locations":[{"line":2, "column":14}]}
      ]

  -
    name: "Search doesn't accept bogus args"
    input: |
      type X {
        y: String @search(by: bogus)
      }
    errlist: [
      {"message": "Type X; Field y: the argument to @search bogus isn't valid.Fields of type
          String can have @search by exact, fulltext, hash, regexp, term and trigram.",
      "locations":[{"line":2, "column":14}]}
      ]

  -
    name: "Type implements an interface which wasn't defined"
    input: |
      type X implements Y {
        y: String
      }
    errlist: [
      {"message": Undefined type "Y".,
      "locations":[{"line":1, "column":6}]}
      ]

  -
    name: "Type implemets an interface with the field definition repeated"
    input: |
      interface Y {
        id: ID
      }
      type X implements Y {
        id: ID
        y: String
      }
    errlist: [
      {"message": "Field X.id can only be defined once.",
      "locations":[{"line":5, "column":3}]}
      ]

  -
    name: "Type implements an interface with the field name repeated but different type"
    input: |
      interface Y {
        id: ID
      }
      type X implements Y {
        id: String
        y: String
      }
    errlist: [
      {"message": "Field X.id can only be defined once.",
      "locations":[{"line":5, "column":3}]}
      ]

  -
    name: "Type implements an interface with no field of its own"
    input: |
      interface Y {
        id: ID
      }
      type X implements Y {
      }
    errlist: [
      {"message": "expected at least one definition, found }",
      "locations":[{"line":5, "column":1}]}
      ]

  -
    name: "Type implements from two interfaces where both have ID"
    input: |
      interface X {
        id: ID
      }
      interface Y {
        id: ID
      }
      type Z implements X & Y {
        name: String
      }
    errlist: [
      {"message": "Field Z.id can only be defined once.",
      "locations":[{"line":2, "column":3}]}
      ]

  -
    name: "List of Boolean is not allowed"
    input: |
      type X {
        q: [Boolean]
      }
    errlist: [
      {"message": "[Boolean] lists are invalid. Only Boolean scalar fields are allowed.",
      "locations":[{"line":2, "column":3}]}
      ]

  -
    name: "Field with same name but different type across different type definitions not allowed."
    input: |
      type X {
        q: [String]
      }

      type Y {
        q: String
      }
    errlist: [
      {"message": "Field Y.q should have same type across type definitions. Found: String, expected: [String]",
      "locations":[{"line":6, "column":3}]}
      ]

  -
    name: "Field with same name but different field type across different definitions not allowed."
    input: |
      type X {
        q: [String]
      }

      type Y {
        q: P
      }

      type P {
        a: String
      }
    errlist: [
      {"message": "Field Y.q should have same type across type definitions. Found: P, expected: [String]",
      "locations":[{"line":6, "column":3}]}
      ]


valid_schemas:
  -
    name: "hasInverse directive on singleton"
    input: |
      type X {
        f1: Y @hasInverse(field: "f2")
      }
      type Y {
        f2: X @hasInverse(field: "f1")
      }

  -
    name: "hasInverse directive on list type 1"
    input: |
      type X {
        f1: [Y] @hasInverse(field: "f2")
      }
      type Y {
        f2: X @hasInverse(field: "f1")
      }

  -
    name: "hasInverse directive on list type 2"
    input: |
      type X {
        f1: [Y] @hasInverse(field: "f2")
      }
      type Y {
        f2: [X] @hasInverse(field: "f1")
      }

  -
    name: "Correct search types"
    input: |
      type X {
        int1: Int @search
        int2: Int @search(by: int)
        float1: Float @search
        float2: Float @search(by: float)
        bool1: Boolean @search
        bool2: Boolean @search(by: bool)
        str: String @search
        strHash: String @search(by: hash)
        strExact: String @search(by: exact)
        strTerm: String @search(by: term)
        strFulltext: String @search(by: fulltext)
        strTrigram: String @search(by: trigram)
        strRegexp: String @search(by: regexp)
        dt: DateTime @search
        dtYear: DateTime @search(by: year)
        dtMonth: DateTime @search(by: month)
        dtDay: DateTime @search(by: day)
        dtHour: DateTime @search(by: hour)
        enumFld: E @search
        req: String! @search(by: term)
        list: [Int] @search
        reqList: [DateTime!]! @search
      }
      enum E {
        A
      }

  -
    name: "Field with same name and same type but different list guarantees are allowed."
    input: |
      type X {
        q: [String]
      }

      type Y {
        a: [X]
      }

      type P {
        a: [X!]
      }