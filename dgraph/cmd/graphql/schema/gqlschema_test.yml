invalid_schemas:
  -
    name: "More than 1 id field"
    input: |
      type P {
        id1: ID!
        id2: ID!
        id3: ID!
      }
    errlist: [
      {"message":"Fields id1, id2 and id3 are listed as IDs for type P, but a type can have only one ID field. Pick a single field as the ID for type P.", "locations":[{"line":2, "column":3}, {"line":3, "column":3}, {"line":4, "column":3}]},
    ]

  -
    name: "Query, Mutation in initial schema"
    input: |
      type Query {
        getAuthro(id: ID): Author!
      }
      type Mutation {
        getAuthro(id: ID): Author!
      }
    errlist: [
      {"message":"You don't need to define the GraphQL Query or Mutation types. Those are built automatically for you.", "locations":[{"line":1, "column":6}]},
      {"message":"You don't need to define the GraphQL Query or Mutation types. Those are built automatically for you.", "locations":[{"line":4, "column":6}]},
    ]

  -
    name: "Invalid list type"
    input: |
      type A {
        posts: [A]!
      }
    errlist: [
      {"message":"[A]! lists are invalid. Valid options are [A!]! and [A!].", "locations":[{"line":2, "column":3}]},
    ]

  -
    name: "Unsupported definitions in initial schema"
    input: |
      scalar Int
      interface P {
        t: T!
      }
      union Q = R | S | T
      input U {
        x: X!
      }
    errlist: [
      {"message":"You can't add scalar definitions. Only type and enums are allowed in initial schema.", "locations":[{"line":1, "column":8}]},
      {"message":"You can't add interface definitions. Only type and enums are allowed in initial schema.", "locations":[{"line":2, "column":11}]},
      {"message":"You can't add union definitions. Only type and enums are allowed in initial schema.", "locations":[{"line":5, "column":7}]},
      {"message":"You can't add input_object definitions. Only type and enums are allowed in initial schema.", "locations":[{"line":6, "column":7}]},
    ]

  -
    name: "Typename is reserved word"
    input: |
      type String {
        id: ID!
      }
    errlist: [
      {"message":"String is a reserved word, so you can't declare a type with this name. Pick a different name for the type.", "locations":[{"line":1, "column":6}]},
    ]

  -
    name: "More than 1 errors"
    input: |
      type X {
        i1: ID!
        i2: ID!
        i3: ID!
        l1: [X]!
      }
    errlist: [
      {"message":"Fields i1, i2 and i3 are listed as IDs for type X, but a type can have only one ID field. Pick a single field as the ID for type X.", "locations":[{"line":2, "column":3}, {"line":3, "column":3}, {"line":4, "column":3}]},
      {"message":"[X]! lists are invalid. Valid options are [X!]! and [X!].", "locations":[{"line":5, "column":3}]},
    ]

  -
    name: "Union type in schema"
    input: |
      union U = R | S | T
    errlist: [
      {"message":"You can't add union definitions. Only type and enums are allowed in initial schema.", "locations":[{"line":1, "column":7}]}
    ]

  -
    name: "Non linking inverse directives"
    input: |
      type X {
        f1: P @hasInverse(field: "f1")
        f2: String
      }
      type P {
        f1: X @hasInverse(field: "f2")
      }
    errlist: [
      {"message":"Type X; Field f1: @hasInverse is required in both the directions to link the fields, but field f1 of type P doesn't have @hasInverse directive pointing to field f1 of type X. To link these add @hasInverse in both directions.", "locations":[{"line":2, "column":10}]},
      {"message":"Type P; Field f1: @hasInverse is required in both the directions to link the fields, but field f2 of type X doesn't have @hasInverse directive pointing to field f1 of type P. To link these add @hasInverse in both directions.", "locations":[{"line":6, "column":10}]},
    ]

  -
    name: "Inverse Directive on non object field"
    input: |
      type X {
        f1: String @hasInverse(field: "f1")
      }
    errlist: [
      {"message":"Type X; Field f1: Field f1 is of type String, but @hasInverse directive only applies to fields with object types.", "locations":[{"line":2, "column":3}]},
    ]

  -
    name: "Inverse Directive doesn't have field argument"
    input: |
      type X {
        f1: X @hasInverse
      }
    errlist: [
      {"message":"Type X; Field f1: @hasInverse directive doesn't have field argument.", "locations":[{"line":2, "column":10}]},
    ]

  -
    name: "hasInverse on non existing field"
    input: |
      type X {
        f1: [P!]! @hasInverse(field: "f2")
      }
      type P  {
        f1: String
      }
    errlist: [
      {"message":"Type X; Field f1: inverse field f2 doesn't exist for type P.", "locations":[{"line":2, "column":14}]},
    ]

valid_schemas:
  -
    name: "hasInverse directive on singleton"
    input: |
      type X {
        f1: Y @hasInverse(field: "f1")
      }
      type Y {
        f1: X @hasInverse(field: "f1")
      }

  -
    name: "hasInverse directive on list type 1"
    input: |
      type X {
        f1: [Y] @hasInverse(field: "f1")
      }
      type Y {
        f1: X @hasInverse(field: "f1")
      }

  -
    name: "hasInverse directive on list type 2"
    input: |
      type X {
        f1: [Y] @hasInverse(field: "f1")
      }
      type Y {
        f1: [X] @hasInverse(field: "f1")
      }