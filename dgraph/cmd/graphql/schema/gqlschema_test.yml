invalid_schemas:
  -
    name: "More than 1 id field"
    input: |
      type P {
        id1: ID!
        id2: ID!
        id3: ID!
      }
    errlist: [
      {"message":"Fields id1, id2 and id3 are listed as IDs for type P, but a type can have only one ID field. Pick a single field as the ID for type P.", "locations":[{"line":2, "column":3}, {"line":3, "column":3}, {"line":4, "column":3}]},
    ]

  -
    name: "Query, Mutation in initial schema"
    input: |
      type Query {
        getAuthro(id: ID): Author!
      }
      type Mutation {
        getAuthro(id: ID): Author!
      }
    errlist: [
      {"message":"You don't need to define the GraphQL Query or Mutation types. Those are built automatically for you.", "locations":[{"line":1, "column":6}]},
      {"message":"You don't need to define the GraphQL Query or Mutation types. Those are built automatically for you.", "locations":[{"line":4, "column":6}]},
    ]

  -
    name: "Invalid list type"
    input: |
      type A {
        posts: [A]!
      }
    errlist: [
      {"message":"[A]! lists are invalid. Valid options are [A!]! and [A!].", "locations":[{"line":2, "column":3}]},
    ]

  -
    name: "Unsupported definitions in initial schema"
    input: |
      scalar Int
      interface P {
        t: T!
      }
      union Q = R | S | T
      input U {
        x: X!
      }
    errlist: [
      {"message":"You can't add scalar definitions. Only type and enums are allowed in initial schema.", "locations":[{"line":1, "column":8}]},
      {"message":"You can't add interface definitions. Only type and enums are allowed in initial schema.", "locations":[{"line":2, "column":11}]},
      {"message":"You can't add union definitions. Only type and enums are allowed in initial schema.", "locations":[{"line":5, "column":7}]},
      {"message":"You can't add input_object definitions. Only type and enums are allowed in initial schema.", "locations":[{"line":6, "column":7}]},
    ]

  -
    name: "Typename is reserved word"
    input: |
      type String {
        id: ID!
      }
    errlist: [
      {"message":"String is a reserved word, so you can't declare a type with this name. Pick a different name for the type.", "locations":[{"line":1, "column":6}]},
    ]

  -
    name: "More than 1 errors"
    input: |
      type X {
        i1: ID!
        i2: ID!
        i3: ID!
        l1: [X]!
      }
    errlist: [
      {"message":"Fields i1, i2 and i3 are listed as IDs for type X, but a type can have only one ID field. Pick a single field as the ID for type X.", "locations":[{"line":2, "column":3}, {"line":3, "column":3}, {"line":4, "column":3}]},
      {"message":"[X]! lists are invalid. Valid options are [X!]! and [X!].", "locations":[{"line":5, "column":3}]},
    ]

  -
    name: "Union type in schema"
    input: |
      union U = R | S | T
    errlist: [
      {"message":"You can't add union definitions. Only type and enums are allowed in initial schema.", "locations":[{"line":1, "column":7}]}
    ]

  -
    name: "Non linking inverse directives"
    input: |
      type X {
        f1: P @hasInverse(field: "f1")
      }
      type P {
        f1: X @hasInverse(field: "f2")
      }
    errlist: [
      {"message":"Inverse field for P.f1 doesn't exist.", "locations":[{"line":5, "column":10}]},
      {"message":"X.f1 have @hasInverse directive to P.f1, which doesn't point back to it.", "locations":[{"line":2, "column":10}]},
    ]

  -
    name: "Inverse Directive on non object field"
    input: |
      type X {
        f1: String @hasInverse(field: "f1")
      }
    errlist: [
      {"message":"X.f1 is of type String, but @hasInverse directive isn't allowed on non object type field.", "locations":[{"line":2, "column":15}]},
    ]

  -
    name: "Inverse Directive doesn't have field argument"
    input: |
      type X {
        f1: X @hasInverse
      }
    errlist: [
      {"message":"hasInverse directive at X.f1 doesn't have field argument.", "locations":[{"line":2, "column":10}]},
    ]