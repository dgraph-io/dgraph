-
  name: "Add mutation geo field - Point type"
  gqlmutation: |
    mutation addHotel($hotel: AddHotelInput!) {
      addHotel(input: [$hotel]) {
        hotel {
          name
          location {
            latitude
            longitude
          }
        }
      }
    }
  gqlvariables: |
    { "hotel":
      { "name": "Taj Hotel",
        "location": { "latitude": 11.11 , "longitude" : 22.22}
      }
    }
  qnametouid: |
  explanation: "Add mutation should convert the Point type mutation to corresponding Dgraph JSON mutation"
  dgmutations:
    - setjson: |
        { "uid":"_:Hotel1",
          "dgraph.type":["Hotel"],
          "Hotel.name":"Taj Hotel",
          "Hotel.location": {
            "type": "Point",
            "coordinates": [22.22, 11.11]
          }
        }

-
  name: "Add mutation geo field - Polygon type"
  gqlmutation: |
    mutation addHotel($hotel: AddHotelInput!) {
      addHotel(input: [$hotel]) {
        hotel {
          name
          area {
            coordinates {
              points {
                latitude
                longitude
              }
            }
          }
        }
      }
    }
  gqlvariables: |
    { "hotel":
      { "name": "Taj Hotel",
        "area": {
          "coordinates": [{
            "points": [{
              "latitude": 11.11,
              "longitude": 22.22
            }, {
              "latitude": 15.15,
              "longitude": 16.16
            }, {
              "latitude": 20.20,
              "longitude": 21.21
            }]
          }, {
              "points": [{
                "latitude": 11.18,
                "longitude": 22.28
              }, {
                "latitude": 15.18,
                "longitude": 16.18
              }, {
                "latitude": 20.28,
                "longitude": 21.28
              }]
          }]
        }
      }
    }
  explanation: "Add mutation should convert the Polygon type mutation to corresponding Dgraph JSON mutation"
  dgmutations:
    - setjson: |
        {
          "uid":"_:Hotel1",
          "dgraph.type":["Hotel"],
          "Hotel.name":"Taj Hotel",
          "Hotel.area": {
            "type": "Polygon",
            "coordinates": [[[22.22,11.11],[16.16,15.15],[21.21,20.2]],[[22.28,11.18],[16.18,15.18],[21.28,20.28]]]
          }
        }

-
  name: "Add mutation geo field - MultiPolygon type"
  gqlmutation: |
    mutation addHotel($hotel: AddHotelInput!) {
      addHotel(input: [$hotel]) {
        hotel {
          name
          branches {
            polygons {
              coordinates {
                points {
                  latitude
                  longitude
                }
              }
            }
          }
        }
      }
    }
  gqlvariables: |
    { "hotel":
      { "name": "Taj Hotel",
        "branches": {
          "polygons": [{
            "coordinates": [{
              "points": [{
                "latitude": 11.11,
                "longitude": 22.22
              }, {
                "latitude": 15.15,
                "longitude": 16.16
              }, {
                "latitude": 20.20,
                "longitude": 21.21
              }]
            }, {
              "points": [{
                "latitude": 11.18,
                "longitude": 22.28
              }, {
                "latitude": 15.18,
                "longitude": 16.18
              }, {
                "latitude": 20.28,
                "longitude": 21.28
              }]
            }]
          }, {
            "coordinates": [{
              "points": [{
                "latitude": 91.11,
                "longitude": 92.22
              }, {
                "latitude": 15.15,
                "longitude": 16.16
              }, {
                "latitude": 20.20,
                "longitude": 21.21
              }]
            }, {
              "points": [{
                "latitude": 11.18,
                "longitude": 22.28
              }, {
                "latitude": 15.18,
                "longitude": 16.18
              }, {
                "latitude": 20.28,
                "longitude": 21.28
              }]
            }]
        }]
        }
      }
    }
  explanation: "Add mutation should convert the MultiPolygon type mutation to corresponding Dgraph JSON mutation"
  dgmutations:
    - setjson: |
        {
          "uid":"_:Hotel1",
          "dgraph.type":["Hotel"],
          "Hotel.name":"Taj Hotel",
          "Hotel.branches": {
            "type": "MultiPolygon",
            "coordinates": [[[[22.22,11.11],[16.16,15.15],[21.21,20.2]],[[22.28,11.18],[16.18,15.18],[21.28,20.28]]],[[[92.22,91.11],[16.16,15.15],[21.21,20.2]],[[22.28,11.18],[16.18,15.18],[21.28,20.28]]]]
          }
        }

-
  name: "Add mutation with variables"
  gqlmutation: |
    mutation addAuthor($auth: AddAuthorInput!) {
      addAuthor(input: [$auth]) {
        author {
          name
        }
      }
    }
  gqlvariables: |
    { "auth":
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": []
      }
    }
  explanation: "A uid and type should get injected and all data transformed to
    underlying Dgraph edge names"
  dgmutations:
    - setjson: |
        { "uid":"_:Author1",
          "dgraph.type":["Author"],
          "Author.name":"A.N. Author",
          "Author.dob":"2000-01-01",
          "Author.posts":[]
        }

-
  name: "Add deep mutation with variables"
  gqlmutation: |
    mutation addAuthor($auth: AddAuthorInput!) {
      addAuthor(input: [$auth]) {
        author {
          name
        }
      }
    }
  gqlvariables: |
    { "auth":
      { "name": "A.N. Author",
        "posts": [{
                "title": "post1",
                "ps": {"title": "ps1"}
        }, {
                "title": "post2",
                "ps": {"title": "ps2"}
        }, {
                "title": "post3",
                "ps": {"title": "ps3"}
        }, {
                "title": "post4",
                "ps": {"title": "ps4"}
        }, {
                "title": "post5",
                "ps": {"title": "ps5"}
        }, {
                "title": "post6",
                "ps": {"title": "ps6"}
        }, {
                "title": "post7",
                "ps": {"title": "ps7"}
        }, {
                "title": "post8",
                "ps": {"title": "ps8"}
        }]
      }
    }
  explanation: "A uid and type should get injected and all data transformed to
    underlying Dgraph edge names. Some PostSecrets are present and are not created."
  dgquery: |-
    query {
      PostSecret1(func: eq(PostSecret.title, "ps1")) @filter(type(PostSecret)) {
        uid
      }
      PostSecret2(func: eq(PostSecret.title, "ps2")) @filter(type(PostSecret)) {
        uid
      }
      PostSecret3(func: eq(PostSecret.title, "ps3")) @filter(type(PostSecret)) {
        uid
      }
      PostSecret4(func: eq(PostSecret.title, "ps4")) @filter(type(PostSecret)) {
        uid
      }
      PostSecret5(func: eq(PostSecret.title, "ps5")) @filter(type(PostSecret)) {
        uid
      }
      PostSecret6(func: eq(PostSecret.title, "ps6")) @filter(type(PostSecret)) {
        uid
      }
      PostSecret7(func: eq(PostSecret.title, "ps7")) @filter(type(PostSecret)) {
        uid
      }
      PostSecret8(func: eq(PostSecret.title, "ps8")) @filter(type(PostSecret)) {
        uid
      }
    }
  qnametouid: |
    {
      "PostSecret1":"0x1",
      "PostSecret2":"0x2",
      "PostSecret3":"0x3",
      "PostSecret4":"0x4"
    }
  dgmutations:
    - setjson: |
        {
          "Author.name":"A.N. Author",
          "Author.posts":
            [
              {
                "Post.author":
                  {
                    "uid":"_:Author9"
                  },
                "Post.ps":
                  {
                    "uid":"0x1"
                  },
                "Post.title":"post1",
                "dgraph.type":["Post"],
                "uid":"_:Post10"
              },
              {
                "Post.author":
                  {
                    "uid":"_:Author9"
                  },
                "Post.ps":
                  {
                    "uid":"0x2"
                  },
                "Post.title":"post2",
                "dgraph.type":["Post"],
                "uid":"_:Post11"
              },
              {
                "Post.author":
                  {
                    "uid":"_:Author9"
                  },
                "Post.ps":
                  {
                    "uid":"0x3"
                  },
                "Post.title":"post3",
                "dgraph.type":["Post"],
                "uid":"_:Post12"
              },
              {
                "Post.author":
                  {
                    "uid":"_:Author9"
                  },
                "Post.ps":
                  {
                    "uid":"0x4"
                  },
                "Post.title":"post4",
                "dgraph.type":["Post"],
                "uid":"_:Post13"
              },
              {
                "Post.author":
                  {
                    "uid":"_:Author9"
                  },
                "Post.ps":
                  {
                    "PostSecret.title":"ps5",
                    "dgraph.type":["PostSecret"],
                    "uid":"_:PostSecret5"
                  },
                "Post.title":"post5",
                "dgraph.type":["Post"],
                "uid":"_:Post14"
              },
              {
                "Post.author":
                  {
                    "uid":"_:Author9"
                  },
                "Post.ps":
                  {
                    "PostSecret.title":"ps6",
                    "dgraph.type":["PostSecret"],
                    "uid":"_:PostSecret6"
                  },
                "Post.title":"post6",
                "dgraph.type":["Post"],
                "uid":"_:Post15"
              },
              {
                "Post.author":
                  {
                    "uid":"_:Author9"
                  },
                "Post.ps":
                  {
                    "PostSecret.title":"ps7",
                    "dgraph.type":["PostSecret"],
                    "uid":"_:PostSecret7"
                  },
                "Post.title":"post7",
                "dgraph.type":["Post"],
                "uid":"_:Post16"
              },
              {
                "Post.author":
                  {
                    "uid":"_:Author9"
                  },
                "Post.ps":
                  {
                    "PostSecret.title":"ps8",
                    "dgraph.type":["PostSecret"],
                    "uid":"_:PostSecret8"
                  },
                "Post.title":"post8",
                "dgraph.type":["Post"],
                "uid":"_:Post17"
              }
            ],
          "dgraph.type":["Author"],
          "uid":"_:Author9"
        }

-
  name: "Add mutation for predicates with special characters having @dgraph directive."
  gqlmutation: |
    mutation {
      addMessage(input : [{content : "content1", author: "author1"}]) {
        message {
          content
          author
        }
      }
    }
  dgmutations:
    - setjson: |
        {
          "uid":"_:Message1",
          "dgraph.type":["Message"],
          "职业":"author1",
          "post":"content1"
        }

-
  name: "Add multiple mutation with variables"
  gqlmutation: |
    mutation addAuthor($auth: [AddAuthorInput!]!) {
      addAuthor(input: $auth) {
        author {
          name
        }
      }
    }
  gqlvariables: |
    {
      "auth": [{
          "name": "A.N. Author"
        },
        {
          "name": "Different Author"
        }
      ]
    }
  explanation: "A uid and type should get injected and all data transformed to
    underlying Dgraph edge names"
  dgmutations:
    - setjson: |
        { "uid":"_:Author1",
          "dgraph.type":["Author"],
          "Author.name":"A.N. Author"
        }
    - setjson: |
        { "uid":"_:Author2",
          "dgraph.type":["Author"],
          "Author.name":"Different Author"
        }

-
  name: "Add Mutation with object at root instead of an array"
  gqlmutation: |
    mutation addAuthor {
      addAuthor(input: { name: "A.N. Author"}) {
        author {
          name
        }
      }
    }
  explanation: "The input being an object should also work because of the input coercion rules
  for input objects."
  dgmutations:
    - setjson: |
        { "uid":"_:Author1",
          "dgraph.type":["Author"],
          "Author.name":"A.N. Author"
        }


-
  name: "Add Mutation with embedded value"
  gqlmutation: |
    mutation addAuthor {
      addAuthor(input: [{ name: "A.N. Author", posts: []}]) {
        author {
          name
        }
      }
    }
  explanation: "The input should be used for the mutation, with a uid and type getting
    injected and all data transformed to underlying Dgraph edge names"
  dgmutations:
    - setjson: |
        { "uid":"_:Author1",
          "dgraph.type":["Author"],
          "Author.name":"A.N. Author",
          "Author.posts":[]
        }

-
  name: "Add Mutation with Password field"
  gqlmutation: |
    mutation addUser($name: String!, $pwd: String!) {
      addUser(input: [{ name: $name, pwd: $pwd}]) {
        user {
          name
        }
      }
    }
  gqlvariables: |
    { "name":  "A.N. Author", "pwd": "Password" }
  explanation: "The input and variables should be used for the mutation, with a uid and type
    getting injected and all data transformed to underlying Dgraph edge names"
  dgquery: |-
    query {
      User1(func: eq(User.name, "A.N. Author")) @filter(type(User)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "uid":"_:User1",
          "dgraph.type":["User"],
          "User.name":"A.N. Author",
          "User.pwd":"Password"
        }

-
  name: "Add Multiple Mutations with embedded value"
  gqlmutation: |
    mutation addAuthor {
      addAuthor(input: [{ name: "A.N. Author", posts: []},
                        { name: "Different Author", posts: []}]) {
        author {
          name
        }
      }
    }
  explanation: "The input should be used for the mutation, with a uid and type getting
    injected and all data transformed to underlying Dgraph edge names"
  dgmutations:
    - setjson: |
        {
          "uid":"_:Author1",
          "dgraph.type":["Author"],
          "Author.name":"A.N. Author",
          "Author.posts":[]
        }
    - setjson: |
        {
          "uid":"_:Author2",
          "dgraph.type":["Author"],
          "Author.name":"Different Author",
          "Author.posts":[]
        }

-
  name: "Add mutation with reference"
  gqlmutation: |
    mutation addAuthor($auth: AddAuthorInput!) {
      addAuthor(input: [$auth]) {
        author {
          name
        }
      }
    }
  gqlvariables: |
    { "auth":
      { "name": "A.N. Author",
        "country": { "id": "0x123" },
        "posts": []
      }
    }
  explanation: "The reference to country should get transformed to 'uid' for the
    Dgraph JSON mutation"
  dgquery: |-
    query {
      Country1(func: uid(0x123)) @filter(type(Country)) {
        uid
      }
    }
  qnametouid: |-
    {
      "Country1":"0x123"
    }
  dgmutations:
    - setjson: |
        {
          "uid":"_:Author2",
          "dgraph.type":["Author"],
          "Author.name":"A.N. Author",
          "Author.country":
            {
              "uid": "0x123"
            },
          "Author.posts":[]
        }

-
  name: "Add mutation with missing reference"
  gqlmutation: |
    mutation addAuthor($auth: AddAuthorInput!) {
      addAuthor(input: [$auth]) {
        author {
          name
        }
      }
    }
  gqlvariables: |
    { "auth":
      { "name": "A.N. Author",
        "country": { "id": "0x123" },
        "posts": []
      }
    }
  explanation: "This should throw an error as 0x123 is not a valid Country node"
  dgquery: |-
    query {
      Country1(func: uid(0x123)) @filter(type(Country)) {
        uid
      }
    }
  error2:
    {
      "message": "failed to rewrite mutation payload because ID \"0x123\" isn't a Country"
    }

-
  name: "Add mutation with invalid reference"
  gqlmutation: |
    mutation addAuthor($auth: AddAuthorInput!) {
      addAuthor(input: [$auth]) {
        author {
          name
        }
      }
    }
  gqlvariables: |
    { "auth":
      { "name": "A.N. Author",
        "country": { "id": "HI!" },
        "posts": []
      }
    }
  explanation: "A reference must be a valid UID"
  error:
    { "message":
        "failed to rewrite mutation payload because ID argument (HI!) was not able to be parsed" }

-
  name: "Add mutation with inverse reference"
  gqlmutation: |
    mutation addPost($post: AddPostInput!) {
      addPost(input: [$post]) {
        post {
          postID
        }
      }
    }
  gqlvariables: |
    { "post":
      { "title": "Exciting post",
        "text": "A really good post",
        "author": { "id": "0x2" }
      }
    }
  explanation: "The reference to the author node should be transformed to include
    a new 'posts' edge."
  dgquery: |-
    query {
      Author1(func: uid(0x2)) @filter(type(Author)) {
        uid
      }
    }
  qnametouid: |-
    {
      "Author1": "0x2"
    }
  dgmutations:
    - setjson: |
        { "uid" : "_:Post2",
          "dgraph.type" : ["Post"],
          "Post.title" : "Exciting post",
          "Post.text" : "A really good post",
          "Post.author": {
            "uid" : "0x2",
            "Author.posts" : [ { "uid": "_:Post2" } ]
          }
        }

-
  name: "Add mutation for a type that implements an interface"
  gqlmutation: |
    mutation addHuman($human: AddHumanInput!) {
      addHuman(input: [$human]) {
        human {
          name
          dob
          female
        }
      }
    }
  gqlvariables: |
    { "human":
      { "name": "Bob",
        "dob": "2000-01-01",
        "female": true,
        "ename": "employee no. 1"
      }
    }
  explanation: "The mutation should get rewritten with correct edges from the interface."
  dgmutations:
    - setjson: |
        { "uid" : "_:Human1",
          "Character.name": "Bob",
          "Employee.ename": "employee no. 1",
          "Human.dob": "2000-01-01",
          "Human.female": true,
          "dgraph.type": ["Human", "Character", "Employee"]
        }

-
  name: "Add mutation using xid code 1"
  gqlmutation: |
    mutation addState($input: AddStateInput!) {
      addState(input: [$input]) {
        state {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "code": "nsw",
        "name": "NSW",
        "country": { "id": "0x12" }
      }
    }
  explanation: "The add mutation should get rewritten into a Dgraph upsert mutation"
  dgquery: |-
    query {
      State1(func: eq(State.code, "nsw")) @filter(type(State)) {
        uid
      }
      Country2(func: uid(0x12)) @filter(type(Country)) {
        uid
      }
    }
  qnametouid: |-
    {
      "Country2": "0x12"
    }
  dgmutations:
    - setjson: |
        { "uid" : "_:State1",
          "dgraph.type": ["State"],
          "State.name": "NSW",
          "State.code": "nsw",
          "State.country": {
            "uid": "0x12",
            "Country.states": [ { "uid": "_:State1" } ]
          }
        }

-
  name: "Add mutation using xid code 2"
  explanation: "Error thrown as node with code nsw exists."
  gqlmutation: |
    mutation addState($input: AddStateInput!) {
      addState(input: [$input], upsert: false) {
        state {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "code": "nsw",
        "name": "NSW",
        "country": { "id": "0x12" }
      }
    }
  dgquery: |-
    query {
      State1(func: eq(State.code, "nsw")) @filter(type(State)) {
        uid
      }
      Country2(func: uid(0x12)) @filter(type(Country)) {
        uid
      }
    }
  qnametouid: |-
    {
      "State1": "0x11",
      "Country2": "0x12"
    }
  error2:
    {
      "message": "failed to rewrite mutation payload because id nsw already exists for field code inside type State"
    }

-
  name: "Multiple Upsert Mutation 1"
  explanation: "As both states exist, the countries of the states are updated"
  gqlmutation: |
    mutation addState($input: [AddStateInput!]!) {
      addState(input: $input, upsert: true) {
        state {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      [
        {
          "code": "nsw",
          "name": "NSW",
          "country": { "id": "0x12" }
        },
        {
          "code": "mh",
          "name": "Maharashtra",
          "country": { "id": "0x14" }
        }
      ]
    }
  dgquery: |-
    query {
      State1(func: eq(State.code, "nsw")) @filter(type(State)) {
        uid
      }
      Country2(func: uid(0x12)) @filter(type(Country)) {
        uid
      }
      State3(func: eq(State.code, "mh")) @filter(type(State)) {
        uid
      }
      Country4(func: uid(0x14)) @filter(type(Country)) {
        uid
      }
    }
  qnametouid: |-
    {
      "State1": "0x11",
      "Country2": "0x12",
      "State3": "0x13",
      "Country4": "0x14"
    }
  dgquerysec: |-
    query {
      State1 as State1(func: uid(0x11)) @filter(type(State)) {
        uid
      }
      State3 as State3(func: uid(0x13)) @filter(type(State)) {
        uid
      }
      var(func: uid(State1)) {
        Country5 as State.country @filter(NOT (uid(0x12)))
      }
      var(func: uid(State3)) {
        Country7 as State.country @filter(NOT (uid(0x14)))
      }
    }
  dgmutations:
    - setjson: |
        { "uid" : "uid(State1)",
          "State.name": "NSW",
          "State.country": {
            "uid": "0x12",
            "Country.states": [ { "uid": "uid(State1)" } ]
          }
        }
      deletejson: |
        [
          {
            "uid":"uid(Country5)",
            "Country.states":
              [
                {
                  "uid":"uid(State1)"
                }
              ]
          }
        ]
      cond: "@if(gt(len(State1), 0))"
    - setjson: |
        { "uid" : "uid(State3)",
          "State.name": "Maharashtra",
          "State.country": {
            "uid": "0x14",
            "Country.states": [ { "uid": "uid(State3)" } ]
          }
        }
      deletejson: |
        [
          {
            "uid":"uid(Country7)",
            "Country.states":
              [
                {
                  "uid":"uid(State3)"
                }
              ]
          }
        ]
      cond: "@if(gt(len(State3), 0))"

-
  name: "Upsert Mutation with multiple xids where both existence queries result exist"
  gqlmutation: |
    mutation addBook($input: [AddBookInput!]!) {
      addBook(input: $input, upsert: true) {
        book {
          title
          ISBN
        }
      }
    }
  gqlvariables: |
    { "input":
      [
        {
          "title": "Sapiens",
          "ISBN": "NSW",
          "publisher": "penguin"
        }
      ]
    }
  dgquery: |-
    query {
      Book1(func: eq(Book.ISBN, "NSW")) @filter(type(Book)) {
        uid
      }
      Book2(func: eq(Book.title, "Sapiens")) @filter(type(Book)) {
        uid
      }
    }
  qnametouid: |-
    {
      "Book1": "0x11",
      "Book2": "0x11"
    }
  dgquerysec: |-
    query {
      Book2 as Book2(func: uid(0x11)) @filter(type(Book)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        { "uid" : "uid(Book2)",
          "Book.publisher": "penguin"
        }
      cond: "@if(gt(len(Book2), 0))"

-
  name: "Upsert Mutation with multiple xids where only one of existence queries result exist"
  explanation: "Book1 does not exist but Book2 exists. As Book2 exists, this is an upsert.
    Even though, Book1 does not exist, the mutation should not update ISBN as it is also an XID."
  gqlmutation: |
    mutation addBook($input: [AddBookInput!]!) {
      addBook(input: $input, upsert: true) {
        book {
          title
          ISBN
        }
      }
    }
  gqlvariables: |
    { "input":
      [
        {
          "title": "Sapiens",
          "ISBN": "NSW",
          "publisher": "penguin"
        }
      ]
    }
  dgquery: |-
    query {
      Book1(func: eq(Book.ISBN, "NSW")) @filter(type(Book)) {
        uid
      }
      Book2(func: eq(Book.title, "Sapiens")) @filter(type(Book)) {
        uid
      }
    }
  qnametouid: |-
    {
      "Book2": "0x11"
    }
  dgquerysec: |-
    query {
      Book2 as Book2(func: uid(0x11)) @filter(type(Book)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "uid" : "uid(Book2)",
          "Book.publisher": "penguin"
        }
      cond: "@if(gt(len(Book2), 0))"

-
  name: "Multiple Upsert Mutation 2"
  explanation: "The first state exists and is updated. Second is created. Country
    is also created in second"
  gqlmutation: |
    mutation addState($input: [AddStateInput!]!) {
      addState(input: $input, upsert: true) {
        state {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      [
        {
          "code": "nsw",
          "name": "NSW",
          "country": { "id": "0x12" }
        },
        {
          "code": "mh",
          "name": "Maharashtra",
          "country": { "name": "India" }
        }
      ]
    }
  dgquery: |-
    query {
      State1(func: eq(State.code, "nsw")) @filter(type(State)) {
        uid
      }
      Country2(func: uid(0x12)) @filter(type(Country)) {
        uid
      }
      State3(func: eq(State.code, "mh")) @filter(type(State)) {
        uid
      }
    }
  qnametouid: |-
    {
      "State1": "0x11",
      "Country2": "0x12"
    }
  dgquerysec: |-
    query {
      State1 as State1(func: uid(0x11)) @filter(type(State)) {
        uid
      }
      var(func: uid(State1)) {
        Country4 as State.country @filter(NOT (uid(0x12)))
      }
    }
  dgmutations:
    - setjson: |
        { "uid" : "uid(State1)",
          "State.name": "NSW",
          "State.country": {
            "uid": "0x12",
            "Country.states": [ { "uid": "uid(State1)" } ]
          }
        }
      deletejson: |
        [
          {
            "uid":"uid(Country4)",
            "Country.states":
              [
                {
                  "uid":"uid(State1)"
                }
              ]
          }
        ]
      cond: "@if(gt(len(State1), 0))"
    - setjson: |
        { "uid" : "_:State3",
          "dgraph.type": ["State"],
          "State.name": "Maharashtra",
          "State.code": "mh",
          "State.country": {
            "uid": "_:Country6",
            "dgraph.type": ["Country"],
            "Country.name": "India",
            "Country.states": [ { "uid": "_:State3" } ]
          }
        }

-
  name: "Add mutation using code on type which also has an ID field"
  gqlmutation: |
    mutation addEditor($input: AddEditorInput!) {
      addEditor(input: [$input]) {
        editor {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "code": "editor",
        "name": "A.N. Editor"
      }
    }
  explanation: "The add mutation should get rewritten into a Dgraph upsert mutation"
  dgquery: |-
    query {
      Editor1(func: eq(Editor.code, "editor")) @filter(type(Editor)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "uid" : "_:Editor1",
          "dgraph.type": ["Editor"],
          "Editor.name": "A.N. Editor",
          "Editor.code": "editor"
        }

-
  name: "Deep add mutation"
  gqlmutation: |
    mutation addAuthor($author: AddAuthorInput!) {
      addAuthor(input: [$author]) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    { "author":
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "title": "New post",
            "text": "A really new post"
          }
        ]
      }
    }
  dgmutations:
    - setjson: |
        { "uid" : "_:Author1",
          "dgraph.type" : [ "Author" ],
          "Author.name": "A.N. Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post2",
              "dgraph.type" : [ "Post" ],
              "Post.title" : "New post",
              "Post.text" : "A really new post",
              "Post.author": {
                "uid" : "_:Author1"
              }
            }
          ]
        }

-
  name: "Deep add multiple mutation"
  gqlmutation: |
    mutation addAuthor($author: [AddAuthorInput!]!) {
      addAuthor(input: $author) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    { "author": [
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "title": "New post",
            "text": "A really new post"
          }
        ]
      },
      { "name": "Different Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "title": "New New post",
            "text": "A wonderful post"
          }
        ]
      }]
    }
  dgmutations:
    - setjson: |
        { "uid" : "_:Author1",
          "dgraph.type" : [ "Author" ],
          "Author.name": "A.N. Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post2",
              "dgraph.type" : [ "Post" ],
              "Post.title" : "New post",
              "Post.text" : "A really new post",
              "Post.author": {
                "uid" : "_:Author1"
              }
            }
          ]
        }
    - setjson: |
        { "uid" : "_:Author3",
          "dgraph.type" : [ "Author" ],
          "Author.name": "Different Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post4",
              "dgraph.type" : [ "Post" ],
              "Post.title" : "New New post",
              "Post.text" : "A wonderful post",
              "Post.author": {
                "uid" : "_:Author3"
              }
            }
          ]
        }

-
  name: "Deep add with existing"
  gqlmutation: |
    mutation addAuthor($author: AddAuthorInput!) {
      addAuthor(input: [$author]) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    { "author":
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "title": "New post",
            "text": "A really new post"
          },
          {
            "postID": "0x123",
            "title": "Old post",
            "text": "A really old post"
          }
        ]
      }
    }
  dgquery: |-
    query {
      Post1(func: uid(0x123)) @filter(type(Post)) {
        uid
      }
    }
  qnametouid: |-
    {
      "Post1":"0x123"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x123)) {
        Author4 as Post.author
      }
    }
  dgmutations:
    - setjson: |
        { "uid": "_:Author2",
          "dgraph.type": [ "Author" ],
          "Author.name": "A.N. Author",
          "Author.dob": "2000-01-01",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post3",
              "dgraph.type": [ "Post" ],
              "Post.title": "New post",
              "Post.text": "A really new post",
              "Post.author": {
                "uid": "_:Author2"
              }
            },
            {
              "uid": "0x123",
              "Post.author": {
                "uid": "_:Author2"
              }
            }
          ]
        }
      deletejson: |
        [
          {
            "uid": "uid(Author4)",
            "Author.posts": [{"uid": "0x123"}]
          }
        ]

-
  name: "Deep add multiple with existing"
  gqlmutation: |
    mutation addAuthor($author: [AddAuthorInput!]!) {
      addAuthor(input: $author) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    { "author": [
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "title": "New post",
            "text": "A really new post"
          },
          {
            "postID": "0x123",
            "title": "Old post",
            "text": "A really old post"
          }
        ]
      },
      { "name": "Different Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "title": "New new post",
            "text": "A wonderful post"
          },
          {
            "postID": "0x124",
            "title": "Another Old post",
            "text": "Another old post text"
          }
        ]
      }]
    }
  dgquery: |-
    query {
      Post1(func: uid(0x123)) @filter(type(Post)) {
        uid
      }
      Post2(func: uid(0x124)) @filter(type(Post)) {
        uid
      }
    }
  qnametouid: |-
    {
      "Post1":"0x123",
      "Post2":"0x124"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x123)) {
        Author5 as Post.author
      }
      var(func: uid(0x124)) {
        Author8 as Post.author
      }
    }
  dgmutations:
    - setjson: |
        { "uid": "_:Author3",
          "dgraph.type": [ "Author" ],
          "Author.name": "A.N. Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post4",
              "dgraph.type": [ "Post" ],
              "Post.title": "New post",
              "Post.text": "A really new post",
              "Post.author": {
                "uid": "_:Author3"
              }
            },
            {
              "uid": "0x123",
              "Post.author": {
                "uid": "_:Author3"
              }
            }
          ]
        }
      deletejson: |
        [
          {
            "uid": "uid(Author5)",
            "Author.posts": [
              {
              "uid": "0x123"
              }
            ]
          }
        ]
    - setjson: |
        {
          "uid": "_:Author6",
          "dgraph.type": [ "Author" ],
          "Author.name": "Different Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post7",
              "dgraph.type": [ "Post" ],
              "Post.title": "New new post",
              "Post.text": "A wonderful post",
              "Post.author": {
                "uid": "_:Author6"
              }
            },
            {
              "uid": "0x124",
              "Post.author": {
                "uid": "_:Author6"
              }
            }
          ]
        }
      deletejson: |
        [
          {
            "uid": "uid(Author8)",
            "Author.posts": [
              {
                "uid": "0x124"
              }
            ]
          }
        ]

-
  name: "Deep add with two existing"
  gqlmutation: |
    mutation addAuthor($author: AddAuthorInput!) {
      addAuthor(input: [$author]) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    { "author":
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "postID": "0x123",
            "title": "Old post",
            "text": "A really old post"
          },
          {
            "postID": "0x456"
          }
        ]
      }
    }
  dgquery: |-
    query {
      Post1(func: uid(0x123)) @filter(type(Post)) {
        uid
      }
      Post2(func: uid(0x456)) @filter(type(Post)) {
        uid
      }
    }
  qnametouid: |-
    {
      "Post1":"0x123",
      "Post2":"0x456"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x123)) {
        Author4 as Post.author
      }
      var(func: uid(0x456)) {
        Author5 as Post.author
      }
    }
  dgmutations:
    - setjson: |
        { "uid": "_:Author3",
          "dgraph.type": [ "Author" ],
          "Author.name": "A.N. Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "0x123",
              "Post.author": {
                "uid": "_:Author3"
              }
            },
            {
              "uid": "0x456",
              "Post.author": {
                "uid": "_:Author3"
              }
            }
          ]
        }
      deletejson: |
        [
          {
            "uid": "uid(Author4)",
            "Author.posts": [{"uid": "0x123"}]
          },
          {
            "uid": "uid(Author5)",
            "Author.posts": [{"uid": "0x456"}]
          }
        ]

-
  name: "Deep add with null"
  gqlmutation: |
    mutation addAuthor($author: AddAuthorInput!) {
      addAuthor(input: [$author]) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    { "author":
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "postID": null,
            "title": "New post",
            "text": "A really new post"
          }
        ]
      }
    }
  dgmutations:
    - setjson: |
        { "uid" : "_:Author1",
          "dgraph.type" : [ "Author" ],
          "Author.name": "A.N. Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post2",
              "dgraph.type" : [ "Post" ],
              "Post.title" : "New post",
              "Post.text" : "A really new post",
              "Post.author": {
                "uid" : "_:Author1"
              }
            }
          ]
        }

-
  name: "Add three deep"
  gqlmutation: |
    mutation addAuthor($author: AddAuthorInput!) {
      addAuthor(input: [$author]) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    { "author":
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "title": "Exciting post",
            "text": "A really good post",
            "category": {
              "name": "New Category"
            }
          }
        ]
      }
    }
  dgmutations:
    - setjson: |
        { "uid": "_:Author1",
          "dgraph.type": [ "Author" ],
          "Author.name": "A.N. Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post2",
              "dgraph.type": [ "Post" ],
              "Post.title": "Exciting post",
              "Post.text": "A really good post",
              "Post.author": {
                "uid": "_:Author1"
              },
              "Post.category": {
                "uid": "_:Category3",
                "dgraph.type": [ "Category" ],
                "Category.name": "New Category",
                "Category.posts": [
                  { "uid": "_:Post2" }
                ]
              }
            }
          ]
        }

-
  name: "Add mutation with deep xid choices 1"
  gqlmutation: |
    mutation addCountry($input: AddCountryInput!) {
      addCountry(input: [$input]) {
        country {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "name": "Dgraph Land",
        "states": [ {
          "code": "dg",
          "name": "Dgraph"
        } ]
      }
    }
  explanation: "No nodes exist. Both nodes are created."
  dgquery: |-
    query {
      State1(func: eq(State.code, "dg")) @filter(type(State)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "Country.name":"Dgraph Land",
          "Country.states":
            [
              {
                "State.code":"dg",
                "State.country":
                  {
                    "uid":"_:Country2"
                  },
                "State.name":"Dgraph",
                "dgraph.type":["State"],
                "uid":"_:State1"
              }
            ],
          "dgraph.type":["Country"],
          "uid":"_:Country2"
        }

-
  name: "Add mutation with deep xid choices 2"
  gqlmutation: |
    mutation addCountry($input: AddCountryInput!) {
      addCountry(input: [$input]) {
        country {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "name": "Dgraph Land",
        "states": [ {
          "code": "dg",
          "name": "Dgraph"
        } ]
      }
    }
  explanation: "The state exists. It is linked to the new Country. Its link to old country is deleted."
  dgquery: |-
    query {
      State1(func: eq(State.code, "dg")) @filter(type(State)) {
        uid
      }
    }
  qnametouid: |-
    {
      "State1":"0x12"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x12)) {
        Country3 as State.country
      }
    }
  dgmutations:
    - setjson: |
        {
          "Country.name":"Dgraph Land",
          "Country.states":
            [
              {
                "State.country":
                  {
                    "uid":"_:Country2"
                  },
                "uid":"0x12"
              }
            ],
          "dgraph.type":["Country"],
          "uid":"_:Country2"
        }
      deletejson: |
        [
          {
            "uid":"uid(Country3)",
            "Country.states":
              [
                {
                  "uid":"0x12"
                }
              ]
          }
        ]

-
  name: "Add mutation with deep xid that must be reference 1"
  gqlmutation: |
    mutation addCountry($input: AddCountryInput!) {
      addCountry(input: [$input]) {
        country {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "name": "Dgraph Land",
        "states": [ {
          "code": "dg"
        } ]
      }
    }
  explanation: "The add mutation has only one option because the state isn't a valid create
    because it's missing required field name"
  dgquery: |-
    query {
      State1(func: eq(State.code, "dg")) @filter(type(State)) {
        uid
      }
    }
  qnametouid: |-
    {
      "State1":"0x12"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x12)) {
        Country3 as State.country
      }
    }
  dgmutations:
    - setjson: |
        {
          "uid": "_:Country2",
          "dgraph.type": ["Country"],
          "Country.name": "Dgraph Land",
          "Country.states":
            [
              {
                "uid": "0x12",
                "State.country":
                  {
                    "uid": "_:Country2"
                  }
              }
            ]
        }
      deletejson: |
        [
          {
            "uid": "uid(Country3)",
            "Country.states": [{"uid": "0x12"}]
          }
        ]

-
  name: "Add mutation with deep xid that must be reference 2"
  gqlmutation: |
    mutation addCountry($input: AddCountryInput!) {
      addCountry(input: [$input]) {
        country {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "name": "Dgraph Land",
        "states": [ {
          "code": "dg"
        } ]
      }
    }
  explanation: "Error is thrown as State with code dg does not exist"
  dgquery: |-
    query {
      State1(func: eq(State.code, "dg")) @filter(type(State)) {
        uid
      }
    }
  error2:
    {
      "message": "failed to rewrite mutation payload because type State requires a value for field name, but no value present"
    }


-
  name: "deprecated fields can be mutated"
  gqlmutation: |
    mutation addCategory($cat: AddCategoryInput!) {
      addCategory(input: [$cat]) {
        category {
          name
          iAmDeprecated
        }
      }
    }
  gqlvariables: |
    { "cat":
      { "name": "A Category",
        "iAmDeprecated": "but I can be written to"
      }
    }
  dgmutations:
    - setjson: |
        { "uid": "_:Category1",
          "dgraph.type": ["Category"],
          "Category.name": "A Category",
          "Category.iAmDeprecated": "but I can be written to"
        }

-
  name: "Add mutation with reverse predicate"
  gqlmutation: |
    mutation addMovieDirector($dir: AddMovieDirectorInput!) {
      addMovieDirector(input: [$dir]) {
        movieDirector {
          id
        }
      }
    }
  gqlvariables: |
    { "dir":
      { "name": "Steven Spielberg",
        "directed": [{ "id": "0x2" }]
      }
    }
  explanation: "Movie node exists and is not created"
  dgquery: |-
    query {
      Movie1(func: uid(0x2)) @filter(type(Movie)) {
        uid
      }
    }
  qnametouid: |-
    {
      "Movie1":"0x2"
    }
  dgmutations:
    - setjson: |
        { "uid" : "_:MovieDirector2",
          "dgraph.type" : ["MovieDirector"],
          "MovieDirector.name" : "Steven Spielberg",
          "directed.movies": [{
            "uid" : "0x2"
          }]
        }

- name: "Top Level Duplicate XIDs with same object Test"
  gqlmutation: |
    mutation addState($input: [AddStateInput!]!) {
      addState(input: $input) {
        state {
          code
          name
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {"name": "State1", "code": "S1"},
        {"name": "State1", "code": "S1"}
      ]
    }
  explanation: "When duplicate XIDs are given as input at top level, but the object structure is
  same, it should return error."
  error:
    message: "failed to rewrite mutation payload because duplicate XID found: S1"

- name: "Top Level Duplicate XIDs with different object Test"
  gqlmutation: |
    mutation addState($input: [AddStateInput!]!) {
      addState(input: $input) {
        state {
          code
          name
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {"name": "State1", "code": "S1"},
        {"name": "State2", "code": "S1"}
      ]
    }
  explanation: "When duplicate XIDs are given as input at top level, but the object structure is
  different, it should still return error."
  error:
    message: "failed to rewrite mutation payload because duplicate XID found: S1"

- name: "Deep Mutation Duplicate XIDs with same object Test"
  gqlmutation: |
    mutation addCity($input: [AddCityInput!]!) {
      addCity(input: $input) {
        city {
          name
          district {
            code
            name
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "name": "Bengaluru",
          "district": {"code": "D1", "name": "Dist1"}
        },
        {
          "name": "NY",
          "district": {"code": "D1", "name": "Dist1"}
        },
        {
         "name": "Sydney",
         "district": {"code": "D1"}
        }
      ]
    }
  explanation: "When duplicate XIDs are given as input to deep mutation but the object structure
  is same or contains just xid, it should not return error."
  dgquery: |-
    query {
      District1(func: eq(District.code, "D1")) @filter(type(District)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "City.district":
            {
              "District.cities":
                [
                  {
                    "uid":"_:City2"
                  }
                ],
              "District.code":"D1",
              "District.name":"Dist1",
              "dgraph.type":["District"],
              "uid":"_:District1"
            },
          "City.name":"Bengaluru",
          "dgraph.type":["City"],
          "uid":"_:City2"
        }
    - setjson: |
        {
          "City.district":
            {
              "District.cities":
                [
                  {
                    "uid":"_:City3"
                  }
                ],
              "uid":"_:District1"
            },
          "City.name":"NY",
          "dgraph.type":["City"],
          "uid":"_:City3"
        }
    - setjson: |
        {
          "City.district":
            {
              "District.cities":
                [
                  {
                    "uid":"_:City4"
                  }
                ],
              "uid":"_:District1"
            },
          "City.name":"Sydney",
          "dgraph.type":["City"],
          "uid":"_:City4"
        }

- name: "Deep Mutation Duplicate XIDs with same object with @hasInverse Test"
  gqlmutation: |
    mutation addCountry($input: [AddCountryInput!]!) {
      addCountry(input: $input) {
        country {
          id
          name
          states {
            code
            name
            capital
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "name": "Country1",
          "states": [
            {"code": "S1", "name": "State1", "capital": "Cap1"},
            {"code": "S1", "name": "State1", "capital": "Cap1"}
          ]
        },
        {
          "name": "Country2",
          "states": [
            {"code": "S2", "name": "State2", "capital": "Cap2"}
          ]
        },
        {
          "name": "Country3",
          "states": [
            {"code": "S2", "name": "State2", "capital": "Cap2"}
          ]
        }
      ]
    }
  explanation: "When duplicate XIDs are given as input to deep mutation and the object structure
  is same and the containing object has @hasInverse on its xid object field, but the xid object
  does not have the @hasInverse field of List type, it should return error."
  error:
    message: |-
      failed to rewrite mutation payload because duplicate XID found: S1
      failed to rewrite mutation payload because duplicate XID found: S2

- name: "Deep Mutation Duplicate XIDs with different object Test"
  gqlmutation: |
    mutation addStudent($input: [AddStudentInput!]!) {
      addStudent(input: $input) {
        student {
          xid
          name
          taughtBy {
            xid
            name
            subject
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "xid": "S1",
          "name": "Stud1",
          "taughtBy": [
            {"xid": "T1", "name": "Teacher1", "subject": "Sub1"}
          ]
        },
        {
          "xid": "S2",
          "name": "Stud2",
          "taughtBy": [
            {"xid": "T1", "name": "Teacher1", "subject": "Sub2"}
          ]
        },
        {
          "xid": "S3",
          "name": "Stud3",
          "taughtBy": [
            {"xid": "T1", "name": "Teacher1"}
          ]
        }
      ]
    }
  explanation: "When duplicate XIDs are given as input to deep mutation but the object structure
  is different, it should return error."
  error:
    message: |-
      failed to rewrite mutation payload because duplicate XID found: T1
      failed to rewrite mutation payload because duplicate XID found: T1

- name: "Circular Duplicate XIDs in single mutation"
  gqlmutation: |
    mutation addStudent($input: [AddStudentInput!]!) {
      addStudent(input: $input) {
        student {
          xid
          name
          taughtBy {
            xid
            name
            subject
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "xid": "S1",
          "name": "Stud1",
          "taughtBy": [
            {"xid": "T1", "name": "Teacher1", "teaches": [{"xid": "S1", "name": "Stud1"}]}
          ]
        }
      ]
    }
  explanation: "When duplicate XIDs are given as input circularly in a single mutation, it
  should return error."
  error:
    message: |-
      failed to rewrite mutation payload because duplicate XID found: S1

- name: "Duplicate XIDs in single mutation for Interface"
  gqlmutation: |
    mutation addStudent($input: [AddStudentInput!]!) {
      addStudent(input: $input) {
        student {
          xid
          name
          taughtBy {
            xid
            name
            subject
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "xid": "S1",
          "name": "Stud1"
        },
        {
          "xid": "S2",
          "name": "Stud2",
          "taughtBy": [
            {"xid": "S1", "name": "Teacher1", "subject": "Sub1"}
          ]
        }
      ]
    }
  explanation: "When duplicate XIDs are given as input for an Interface in a single mutation, it
  should return error."
  error:
    message: |-
      failed to rewrite mutation payload because duplicate XID found: S1

# Additional Deletes
#
# If we have
#
# type Post { ... author: Author @hasInverse(field: posts) ... }
# type Author { ... posts: [Post] ... }
#
# and existing edge
#
# Post1 --- author --> Author1
#
# there must also exist edge
#
# Author1 --- posts --> Post1
#
# So if we did an add Author2 and connect the author to Post1, that changes the
# author of Post1 to Author2, we need to
#  * add edge Post1 --- author --> Author2 (done by asIDReference/asXIDReference)
#  * add edge Author2 --- posts --> Post1 (done by addInverseLink)
#  * delete edge Author1 --- posts --> Post1 (done by addAdditionalDeletes)
#
# This delete only needs to be done when there is a singular edge in the mutation:
# i.e. if both directions of the edge are [], then it's just an add.
#
# There's three cases to consider: add by ID, add by XID, deep add

- name: "Additional Deletes - Add connects to existing node by ID"
  gqlmutation: |
    mutation addAuthor($auth: AddAuthorInput!) {
      addAuthor(input: [$auth]) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    {
      "auth": {
        "name": "A.N. Author",
        "posts": [ { "postID": "0x456" }, {"title": "New Post", "author": {"name": "Abhimanyu"}} ]
      }
    }
  dgquery: |-
    query {
      Post1(func: uid(0x456)) @filter(type(Post)) {
        uid
      }
    }
  qnametouid: |-
    {
      "Post1": "0x456"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x456)) {
        Author3 as Post.author
      }
    }
  dgmutations:
    - setjson: |
        {
          "uid":"_:Author2",
          "dgraph.type":["Author"],
          "Author.name":"A.N. Author",
          "Author.posts": [
            {
              "uid": "0x456",
              "Post.author": { "uid": "_:Author2" }
            },
            {
              "uid": "_:Post4",
              "dgraph.type": ["Post"],
              "Post.title": "New Post",
              "Post.author": { "uid": "_:Author2" }
            }
          ]
        }
      deletejson: |
        [
          {
            "uid": "uid(Author3)",
            "Author.posts": [ { "uid": "0x456" } ]
          }
        ]

- name: "Additional Deletes - Add connects to existing node by XID"
  explanation: "One of the states exists. Country attached to that state is deleted."
  gqlmutation: |
    mutation addCountry($inp: AddCountryInput!) {
      addCountry(input: [$inp]) {
        country {
          id
        }
      }
    }
  gqlvariables: |
    {
      "inp": {
        "name": "A Country",
        "states": [
          { "code": "abc", "name": "Alphabet" },
          { "code": "def", "name": "Vowel", "country": { "name": "B country" } }
        ]
      }
    }
  dgquery: |-
    query {
      State1(func: eq(State.code, "abc")) @filter(type(State)) {
        uid
      }
      State2(func: eq(State.code, "def")) @filter(type(State)) {
        uid
      }
    }
  qnametouid: |-
    {
      "State1": "0x1234"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x1234)) {
        Country4 as State.country
      }
    }
  dgmutations:
    - setjson: |
        {
          "Country.name":"A Country",
          "Country.states":
            [
              {
                "State.country":
                  {
                    "uid":"_:Country3"
                  },
                "uid":"0x1234"
              },
              {
                "State.code":"def",
                "State.country":
                  {
                    "uid":"_:Country3"
                  },
                "State.name":"Vowel",
                "dgraph.type":["State"],
                "uid":"_:State2"
              }
            ],
          "dgraph.type":["Country"],
          "uid":"_:Country3"
        }
      deletejson: |
        [
          {
            "uid":"uid(Country4)",
            "Country.states":
              [
                {"uid":"0x1234"}
              ]
          }
        ]

- name: "Deep XID 4 level deep 1"
  explanation: "No nodes exist. All nodes are created."
  gqlmutation: |
    mutation addStudent($student: AddStudentInput!) {
      addStudent(input: [$student]) {
        student {
          name
        }
      }
    }
  gqlvariables: |
    {
      "student": {
        "xid": "S0",
        "name": "Student0",
        "taughtBy": [{
                "xid": "T0",
                "name": "teacher0",
                "teaches": [{
                        "xid": "S1",
                        "name": "Student1",
                        "taughtBy": [{
                                "xid": "T1",
                                "name": "teacher1"
                        }]
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Student1(func: eq(People.xid, "S0")) @filter(type(Student)) {
        uid
      }
      Teacher2(func: eq(People.xid, "T0")) @filter(type(Teacher)) {
        uid
      }
      Student3(func: eq(People.xid, "S1")) @filter(type(Student)) {
        uid
      }
      Teacher4(func: eq(People.xid, "T1")) @filter(type(Teacher)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "People.name":"Student0",
          "People.xid":"S0",
          "Student.taughtBy":
            [
              {
                "People.name":"teacher0",
                "People.xid":"T0",
                "Teacher.teaches":
                  [
                    {
                      "uid":"_:Student1"
                    },
                    {
                      "People.name":"Student1",
                      "People.xid":"S1",
                      "Student.taughtBy":
                        [
                          {
                            "uid":"_:Teacher2"
                          },
                          {
                            "People.name":"teacher1",
                            "People.xid":"T1",
                            "Teacher.teaches":
                              [
                                {
                                  "uid":"_:Student3"
                                }
                              ],
                            "dgraph.type":["Teacher","People"],
                            "uid":"_:Teacher4"
                          }
                        ],
                      "dgraph.type":["Student","People"],
                      "uid":"_:Student3"
                    }
                  ],
                "dgraph.type":["Teacher","People"],
                "uid":"_:Teacher2"
              }
            ],
          "dgraph.type":["Student","People"],
          "uid":"_:Student1"
        }

- name: "Deep XID 4 level deep 2"
  explanation: "Teacher T1 also teaches the newly added student at top level, S0."
  gqlmutation: |
    mutation addStudent($student: AddStudentInput!) {
      addStudent(input: [$student]) {
        student {
          name
        }
      }
    }
  gqlvariables: |
    {
      "student": {
        "xid": "S0",
        "name": "Student0",
        "taughtBy": [{
                "xid": "T0",
                "name": "teacher0",
                "teaches": [{
                        "xid": "S1",
                        "name": "Student1",
                        "taughtBy": [{
                                "xid": "T1",
                                "name": "teacher1",
                                "teaches": [{
                                      "xid": "S0"
                                }]
                        }]
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Student1(func: eq(People.xid, "S0")) @filter(type(Student)) {
        uid
      }
      Teacher2(func: eq(People.xid, "T0")) @filter(type(Teacher)) {
        uid
      }
      Student3(func: eq(People.xid, "S1")) @filter(type(Student)) {
        uid
      }
      Teacher4(func: eq(People.xid, "T1")) @filter(type(Teacher)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "People.name":"Student0",
          "People.xid":"S0",
          "Student.taughtBy":
            [
              {
                "People.name":"teacher0",
                "People.xid":"T0",
                "Teacher.teaches":
                  [
                    {
                      "uid":"_:Student1"
                    },
                    {
                      "People.name":"Student1",
                      "People.xid":"S1",
                      "Student.taughtBy":
                        [
                          {
                            "uid":"_:Teacher2"
                          },
                          {
                            "People.name":"teacher1",
                            "People.xid":"T1",
                            "Teacher.teaches":
                              [
                                {
                                  "uid":"_:Student3"
                                },
                                {
                                  "uid":"_:Student1",
                                  "Student.taughtBy":
                                    [
                                      {
                                        "uid":"_:Teacher4"
                                      }
                                    ]
                                }
                              ],
                            "dgraph.type":["Teacher","People"],
                            "uid":"_:Teacher4"
                          }
                        ],
                      "dgraph.type":["Student","People"],
                      "uid":"_:Student3"
                    }
                  ],
                "dgraph.type":["Teacher","People"],
                "uid":"_:Teacher2"
              }
            ],
          "dgraph.type":["Student","People"],
          "uid":"_:Student1"
        }

- name: "Deep XID Add top level hasInverse 1"
  explanation: "No nodes exists. All are created."
  gqlmutation: |
    mutation addStudent($student: AddStudentInput!) {
      addStudent(input: [$student]) {
        student {
          name
        }
      }
    }
  gqlvariables: |
    {
      "student": {
        "xid": "S0",
        "name": "Student0",
        "taughtBy": [{
                "xid": "T0",
                "name": "teacher0",
                "teaches": [{
                        "xid": "S1",
                        "name": "Student1"
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Student1(func: eq(People.xid, "S0")) @filter(type(Student)) {
        uid
      }
      Teacher2(func: eq(People.xid, "T0")) @filter(type(Teacher)) {
        uid
      }
      Student3(func: eq(People.xid, "S1")) @filter(type(Student)) {
        uid
      }
    }

  dgmutations:
    - setjson: |
        {
          "People.name":"Student0",
          "People.xid":"S0",
          "Student.taughtBy":
            [
              {
                "People.name":"teacher0",
                "People.xid":"T0",
                "Teacher.teaches":
                  [
                    {
                      "uid":"_:Student1"
                    },
                    {
                      "People.name":"Student1",
                      "People.xid":"S1",
                      "Student.taughtBy":
                        [
                          {
                            "uid":"_:Teacher2"
                          }
                        ],
                      "dgraph.type":["Student","People"],
                      "uid":"_:Student3"
                    }
                  ],
                "dgraph.type":["Teacher","People"],
                "uid":"_:Teacher2"
              }
            ],
          "dgraph.type":["Student","People"],
          "uid":"_:Student1"
        }

- name: "Deep XID Add top level hasInverse 2"
  explanation: "Teacher T0 exists and is linked to Student S0"
  gqlmutation: |
    mutation addStudent($student: AddStudentInput!) {
      addStudent(input: [$student]) {
        student {
          name
        }
      }
    }
  gqlvariables: |
    {
      "student": {
        "xid": "S0",
        "name": "Student0",
        "taughtBy": [{
                "xid": "T0",
                "name": "teacher0",
                "teaches": [{
                        "xid": "S1",
                        "name": "Student1"
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Student1(func: eq(People.xid, "S0")) @filter(type(Student)) {
        uid
      }
      Teacher2(func: eq(People.xid, "T0")) @filter(type(Teacher)) {
        uid
      }
      Student3(func: eq(People.xid, "S1")) @filter(type(Student)) {
        uid
      }
    }
  qnametouid: |
    {
      "Teacher2": "0x987"
    }
  dgmutations:
    - setjson: |
        {
          "People.name":"Student0",
          "People.xid":"S0",
          "Student.taughtBy":
            [
              {
                "Teacher.teaches":
                  [
                    {
                      "uid":"_:Student1"
                    }
                  ],
                "uid":"0x987"
              }
            ],
          "dgraph.type":["Student","People"],
          "uid":"_:Student1"
        }

- name: "Deep XID Add top level hasInverse 3"
  explanation: "Student S1 exists and is linked to Teacher T0."
  gqlmutation: |
    mutation addStudent($student: AddStudentInput!) {
      addStudent(input: [$student]) {
        student {
          name
        }
      }
    }
  gqlvariables: |
    {
      "student": {
        "xid": "S0",
        "name": "Student0",
        "taughtBy": [{
                "xid": "T0",
                "name": "teacher0",
                "teaches": [{
                        "xid": "S1",
                        "name": "Student1"
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Student1(func: eq(People.xid, "S0")) @filter(type(Student)) {
        uid
      }
      Teacher2(func: eq(People.xid, "T0")) @filter(type(Teacher)) {
        uid
      }
      Student3(func: eq(People.xid, "S1")) @filter(type(Student)) {
        uid
      }
    }
  qnametouid: |
    {
      "Student3": "0x123"
    }
  dgmutations:
    - setjson: |
        {
          "People.name":"Student0",
          "People.xid":"S0",
          "Student.taughtBy":
            [
              {
                "People.name":"teacher0",
                "People.xid":"T0",
                "Teacher.teaches":
                  [
                    {
                      "uid":"_:Student1"
                    },
                    {
                      "Student.taughtBy":
                        [
                          {
                            "uid":"_:Teacher2"
                          }
                        ],
                      "uid":"0x123"
                    }
                  ],
                "dgraph.type":["Teacher","People"],
                "uid":"_:Teacher2"
              }
            ],
          "dgraph.type":["Student","People"],
          "uid":"_:Student1"
        }


- name: "Deep XID Add lower level hasInvsere 1"
  explanation: "None of the nodes exists. All of them are created."
  gqlmutation: |
    mutation addLab($lab: AddLabInput!) {
      addLab(input: [$lab]) {
        lab {
          name
        }
      }
    }
  gqlvariables: |
    {
      "lab": {
        "name": "Lab1",
        "computers": [{
                "name": "computer1",
                "owners": [{
                        "name": "owner1"
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Lab1(func: eq(Lab.name, "Lab1")) @filter(type(Lab)) {
        uid
      }
      Computer2(func: eq(Computer.name, "computer1")) @filter(type(Computer)) {
        uid
      }
      ComputerOwner3(func: eq(ComputerOwner.name, "owner1")) @filter(type(ComputerOwner)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "Lab.computers":
            [
              {
                "Computer.name":"computer1",
                "Computer.owners":
                  [
                    {
                      "ComputerOwner.computers":
                        {
                          "uid":"_:Computer2"
                        },
                      "ComputerOwner.name":"owner1",
                      "dgraph.type":["ComputerOwner"],
                      "uid":"_:ComputerOwner3"
                    }
                  ],
                "dgraph.type":["Computer"],
                "uid":"_:Computer2"
              }
            ],
          "Lab.name":"Lab1",
          "dgraph.type":["Lab"],
          "uid":"_:Lab1"
        }

- name: "Deep XID Add lower level hasInvsere 2"
  explanation: "computer exists. Computer node is linked to Lab."
  gqlmutation: |
    mutation addLab($lab: AddLabInput!) {
      addLab(input: [$lab]) {
        lab {
          name
        }
      }
    }
  gqlvariables: |
    {
      "lab": {
        "name": "Lab1",
        "computers": [{
                "name": "computer1",
                "owners": [{
                        "name": "owner1"
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Lab1(func: eq(Lab.name, "Lab1")) @filter(type(Lab)) {
        uid
      }
      Computer2(func: eq(Computer.name, "computer1")) @filter(type(Computer)) {
        uid
      }
      ComputerOwner3(func: eq(ComputerOwner.name, "owner1")) @filter(type(ComputerOwner)) {
        uid
      }
    }
  qnametouid: |
    {
      "Computer2": "0x234"
    }
  dgmutations:
    - setjson: |
        {
          "Lab.computers":
            [
              {
                "uid":"0x234"
              }
            ],
          "Lab.name":"Lab1",
          "dgraph.type":["Lab"],
          "uid":"_:Lab1"
        }

- name: "Deep XID Add lower level hasInvsere 3"
  explanation: "Computer Owner exists and is linked to computer."
  gqlmutation: |
    mutation addLab($lab: AddLabInput!) {
      addLab(input: [$lab]) {
        lab {
          name
        }
      }
    }
  gqlvariables: |
    {
      "lab": {
        "name": "Lab1",
        "computers": [{
                "name": "computer1",
                "owners": [{
                        "name": "owner1"
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Lab1(func: eq(Lab.name, "Lab1")) @filter(type(Lab)) {
        uid
      }
      Computer2(func: eq(Computer.name, "computer1")) @filter(type(Computer)) {
        uid
      }
      ComputerOwner3(func: eq(ComputerOwner.name, "owner1")) @filter(type(ComputerOwner)) {
        uid
      }
    }
  qnametouid: |
    {
      "ComputerOwner3": "0x123"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x123)) {
        Computer4 as ComputerOwner.computers
      }
    }
  dgmutations:
    - setjson: |
        {
          "Lab.computers":
            [
              {
                "Computer.name":"computer1",
                "Computer.owners":
                  [
                    {
                      "ComputerOwner.computers":
                        {
                          "uid":"_:Computer2"
                        },
                      "uid":"0x123"
                    }
                  ],
                "dgraph.type":["Computer"],
                "uid":"_:Computer2"
              }
            ],
          "Lab.name":"Lab1",
          "dgraph.type":["Lab"],
          "uid":"_:Lab1"
        }
      deletejson: |-
        [{
            "Computer.owners": [
                {
                    "uid": "0x123"
                }
            ],
            "uid": "uid(Computer4)"
        }]

- name: "Deep mutation alternate id xid"
  gqlmutation: |
    mutation addAuthor($city: AddCityInput!) {
      addCity(input: [$city]) {
        city {
          name
          district {
            code
            name
            cities {
              name
              district {
                code
                name
              }
            }
          }
        }
      }
    }
  gqlvariables: |
    {
      "city": {
        "name": "c1",
        "district":{
                "name":"d1",
                "code":"d1",
                "cities":[{"name": "c2"}]
        }
      }
    }
  dgquery: |-
    query {
      District1(func: eq(District.code, "d1")) @filter(type(District)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "City.district":
            {
              "District.cities":
                [
                  {
                    "uid":"_:City2"
                  },
                  {
                    "City.district":
                      {
                        "uid":"_:District1"
                      },
                      "City.name":"c2",
                      "dgraph.type":["City"],
                      "uid":"_:City3"
                  }
                ],
              "District.code":"d1",
              "District.name":"d1",
              "dgraph.type":["District"],
              "uid":"_:District1"
            },
          "City.name":"c1",
          "dgraph.type":["City"],
          "uid":"_:City2"
        }

- name: "Deep mutation alternate id xid with existing XID"
  gqlmutation: |
    mutation addAuthor($city: AddCityInput!) {
      addCity(input: [$city]) {
        city {
          name
          district {
            code
            name
            cities {
              name
              district {
                code
                name
              }
            }
          }
        }
      }
    }
  gqlvariables: |
    {
      "city": {
        "name": "c1",
        "district":{
                "name":"d1",
                "code":"d1",
                "cities":[{"name": "c2"}]
        }
      }
    }
  dgquery: |-
    query {
      District1(func: eq(District.code, "d1")) @filter(type(District)) {
        uid
      }
    }
  qnametouid: |-
    {
      "District1": "0x123"
    }
  dgmutations:
    - setjson: |
        {
          "City.district":
            {
              "District.cities":
                [
                  {
                    "uid":"_:City2"
                  }
                ],
              "uid":"0x123"
            },
          "City.name":"c1",
          "dgraph.type":["City"],
          "uid":"_:City2"
        }


- name: "Additional Deletes - deep mutation"
  gqlmutation: |
    mutation addAuthor($auth: AddAuthorInput!) {
      addAuthor(input: [$auth]) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    {
      "auth": {
        "name": "A.N. Author",
        "country": {
          "name": "A Country",
          "states": [ { "code": "abc", "name": "Alphabet" } ]
        }
      }
    }
  dgquery: |-
    query {
      State1(func: eq(State.code, "abc")) @filter(type(State)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "Author.country":
            {
              "Country.name":"A Country",
              "Country.states":
                [
                  {
                    "State.code":"abc",
                    "State.country": {"uid":"_:Country3"},
                    "State.name":"Alphabet",
                    "dgraph.type":["State"],
                    "uid":"_:State1"
                  }
                ],
              "dgraph.type":["Country"],
              "uid":"_:Country3"
            },
          "Author.name":"A.N. Author",
          "dgraph.type":["Author"],
          "uid":"_:Author2"
        }

- name: "Deep mutation three level xid with no initial XID"
  gqlmutation: |
    mutation($auth: [AddPost1Input!]!) {
      addPost1(input: $auth) {
        post1 {
          id
          comments {
            id
            replies {
              id
            }
          }
        }
      }
    }

  gqlvariables: |
    {
      "auth": [{
        "id": "post1",
        "comments": [{
          "id": "comment1",
          "replies": [{
            "id": "reply1"
          }]
        }]
      },
      {
        "id": "post2",
        "comments": [{
          "id": "comment2",
          "replies": [{
            "id": "reply1"
          }]
        }]
      }]
    }
  dgquery: |-
    query {
      Post11(func: eq(Post1.id, "post1")) @filter(type(Post1)) {
        uid
      }
      Comment12(func: eq(Comment1.id, "comment1")) @filter(type(Comment1)) {
        uid
      }
      Comment13(func: eq(Comment1.id, "reply1")) @filter(type(Comment1)) {
        uid
      }
      Post14(func: eq(Post1.id, "post2")) @filter(type(Post1)) {
        uid
      }
      Comment15(func: eq(Comment1.id, "comment2")) @filter(type(Comment1)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "Post1.comments":
            [
              {
                "Comment1.id": "comment1",
                "Comment1.replies":
                  [
                    {
                     "Comment1.id":"reply1",
                     "dgraph.type": ["Comment1"],
                     "uid":"_:Comment13"
                    }
                  ],
                "dgraph.type":["Comment1"],
                "uid":"_:Comment12"
              }
            ],
          "Post1.id":"post1",
          "dgraph.type":["Post1"],
          "uid":"_:Post11"
        }
    - setjson: |
        {
          "Post1.comments":
            [
              {
                "Comment1.id":"comment2",
                "Comment1.replies":
                  [
                    {
                      "uid":"_:Comment13"
                    }
                  ],
                "dgraph.type":["Comment1"],
                "uid":"_:Comment15"
              }
            ],
          "Post1.id":"post2",
          "dgraph.type":["Post1"],
          "uid":"_:Post14"
        }

- name: "Deep mutation three level xid with existing XIDs 1"
  explanation: "reply1 and comment1 exists and is not created"
  gqlmutation: |
    mutation($auth: [AddPost1Input!]!) {
      addPost1(input: $auth) {
        post1 {
          id
          comments {
            id
            replies {
              id
            }
          }
        }
      }
    }

  gqlvariables: |
    {
      "auth": [{
        "id": "post1",
        "comments": [{
          "id": "comment1",
          "replies": [{
            "id": "reply1"
          }]
        }]
      },
      {
        "id": "post2",
        "comments": [{
          "id": "comment2",
          "replies": [{
            "id": "reply1"
          }]
        }]
      }]
    }
  dgquery: |-
    query {
      Post11(func: eq(Post1.id, "post1")) @filter(type(Post1)) {
        uid
      }
      Comment12(func: eq(Comment1.id, "comment1")) @filter(type(Comment1)) {
        uid
      }
      Comment13(func: eq(Comment1.id, "reply1")) @filter(type(Comment1)) {
        uid
      }
      Post14(func: eq(Post1.id, "post2")) @filter(type(Post1)) {
        uid
      }
      Comment15(func: eq(Comment1.id, "comment2")) @filter(type(Comment1)) {
        uid
      }
    }
  qnametouid: |
    {
      "Comment12": "0x110",
      "Comment13": "0x111"
    }
  dgmutations:
    - setjson: |
        {
          "Post1.comments":
            [
              {
                "uid":"0x110"
              }
            ],
          "Post1.id":"post1",
          "dgraph.type":["Post1"],
          "uid":"_:Post11"
        }
    - setjson: |
        {
          "Post1.comments":
            [
              {
                "Comment1.id":"comment2",
                "Comment1.replies":
                  [
                    {
                      "uid":"0x111"
                    }
                  ],
                "dgraph.type":["Comment1"],
                "uid":"_:Comment15"
              }
            ],
          "Post1.id":"post2",
          "dgraph.type":["Post1"],
          "uid":"_:Post14"
        }

- name: "Deep mutation three level xid with existing XIDs 2"
  explanation: "comment2 and comment1 exists. reply1 does not exist. reply1 is not created as its parent exists."
  gqlmutation: |
    mutation($auth: [AddPost1Input!]!) {
      addPost1(input: $auth) {
        post1 {
          id
          comments {
            id
            replies {
              id
            }
          }
        }
      }
    }

  gqlvariables: |
    {
      "auth": [{
        "id": "post1",
        "comments": [{
          "id": "comment1",
          "replies": [{
            "id": "reply1"
          }]
        }]
      },
      {
        "id": "post2",
        "comments": [{
          "id": "comment2",
          "replies": [{
            "id": "reply1"
          }]
        }]
      }]
    }
  dgquery: |-
    query {
      Post11(func: eq(Post1.id, "post1")) @filter(type(Post1)) {
        uid
      }
      Comment12(func: eq(Comment1.id, "comment1")) @filter(type(Comment1)) {
        uid
      }
      Comment13(func: eq(Comment1.id, "reply1")) @filter(type(Comment1)) {
        uid
      }
      Post14(func: eq(Post1.id, "post2")) @filter(type(Post1)) {
        uid
      }
      Comment15(func: eq(Comment1.id, "comment2")) @filter(type(Comment1)) {
        uid
      }
    }
  qnametouid: |
    {
      "Comment12": "0x110",
      "Comment15": "0x111"
    }
  dgmutations:
    - setjson: |
        {
          "Post1.comments":
            [
              {
                "uid":"0x110"
              }
            ],
          "Post1.id":"post1",
          "dgraph.type":["Post1"],
          "uid":"_:Post11"
        }
    - setjson: |
        {
          "Post1.comments":
            [
              {
                "uid":"0x111"
              }
            ],
          "Post1.id":"post2",
          "dgraph.type":["Post1"],
          "uid":"_:Post14"
        }

-
  name: "Add mutation error on @id field for empty value"
  gqlmutation: |
    mutation addState($input: AddStateInput!) {
      addState(input: [$input]) {
        state {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "code": "",
        "name": "NSW",
        "country": { "id": "0x12" }
      }
    }
  explanation: "The add mutation should not be allowed since value of @id field is empty."
  error:
    { "message": "failed to rewrite mutation payload because encountered an empty value for @id field `State.code`" }

-
  name: "Add mutation error on @id field for empty value (Nested)"
  gqlmutation: |
    mutation addCountry($input: AddCountryInput!) {
      addCountry(input: [$input]) {
        country {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "name": "Dgraph Land",
        "states": [ {
          "code": "",
          "name": "Dgraph"
        } ]
      }
    }
  explanation: "The add mutation should not be allowed since value of @id field is empty."
  error:
    { "message": "failed to rewrite mutation payload because encountered an empty value for @id field `State.code`" }

-
  name: "Add mutation for person with @hasInverse"
  gqlmutation: |
    mutation($input: [AddPersonInput!]!) {
      addPerson(input: $input) {
        person {
          name
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "name": "Or",
          "friends": [
            { "name": "Michal", "friends": [{ "name": "Justin" }] }
          ]
        }
      ]
    }
  dgmutations:
    - setjson: |
        {
          "Person.friends": [
            {
              "Person.friends": [
                {
                  "uid": "_:Person1"
                },
                {
                  "Person.friends": [
                    {
                      "uid": "_:Person2"
                    }
                  ],
                  "Person.name": "Justin",
                  "dgraph.type": [
                    "Person"
                  ],
                  "uid": "_:Person3"
                }
              ],
              "Person.name": "Michal",
              "dgraph.type": [
                "Person"
              ],
              "uid": "_:Person2"
            }
          ],
          "Person.name": "Or",
          "dgraph.type": [
            "Person"
          ],
          "uid": "_:Person1"
        }

-
  name: "Add mutation with union"
  gqlmutation: |
    mutation($input: [AddHomeInput!]!) {
      addHome(input: $input) {
        home {
          address
          members {
            ... on Dog {
              breed
            }
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "address": "United Street",
          "members": [
            { "dogRef": { "category": "Mammal", "breed": "German Shephard"} },
            { "parrotRef": { "category": "Bird", "repeatsWords": ["squawk"]} },
            { "humanRef": { "name": "Han Solo", "ename": "Han_emp"} }
          ],
          "favouriteMember": { "parrotRef": { "id": "0x123"} }
        }
      ]
    }
  qnametouid: |-
    {
      "Parrot1" : "0x123"
    }
  dgquery: |-
    query {
      Parrot1(func: uid(0x123)) @filter(type(Parrot)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "Home.address": "United Street",
          "Home.favouriteMember": {
            "uid": "0x123"
          },
          "Home.members": [{
            "Animal.category": "Mammal",
            "Dog.breed": "German Shephard",
            "dgraph.type": ["Dog", "Animal"],
            "uid": "_:Dog3"
          }, {
            "Animal.category": "Bird",
            "Parrot.repeatsWords": ["squawk"],
            "dgraph.type": ["Parrot", "Animal"],
            "uid": "_:Parrot4"
          }, {
            "Character.name": "Han Solo",
            "Employee.ename": "Han_emp",
            "dgraph.type": ["Human", "Character", "Employee"],
            "uid": "_:Human5"
          }],
          "dgraph.type": ["Home"],
          "uid": "_:Home2"
        }

-
  name: "Add mutation with union - invalid input"
  gqlmutation: |
    mutation($input: [AddHomeInput!]!) {
      addHome(input: $input) {
        home {
          address
          members {
            ... on Dog {
              breed
            }
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "address": "United Street",
          "members": [
            { "dogRef": { "category": "Mammal"}, "parrotRef": { "category": "Bird"} },
            { "parrotRef": { "category": "Bird", "repeatsWords": ["squawk"]} },
            { "humanRef": { "name": "Han Solo", "ename": "Han_emp"} }
          ],
          "favouriteMember": { }
        }
      ]
    }
  explanation: "The add mutation should not be allowed since the union input is invalid"
  error:
    message: |-
      failed to rewrite mutation payload because value for field `favouriteMember` in type `Home` must have exactly one child, found 0 children
      failed to rewrite mutation payload because value for field `members` in type `Home` index `0` must have exactly one child, found 2 children

-
  name: "Add type with multiple Xid fields"
  gqlmutation: |
    mutation($input: [AddBookInput!]!) {
    	addBook(input: $input) {
    		book {
    			title
    			ISBN
    			author {
    				name
    			}
    		}
    	}
    }

  gqlvariables: |
    {
        "input": [
            {
                "title": "Sapiens",
                "ISBN": "2312SB",
                "author": {
                    "name": "Yuval Noah Harari"
                }
            }
        ]
    }
  dgquery: |-
    query {
      Book1(func: eq(Book.ISBN, "2312SB")) @filter(type(Book)) {
        uid
      }
      Book2(func: eq(Book.title, "Sapiens")) @filter(type(Book)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
            "Book.author": {
                "author.name": "Yuval Noah Harari",
                "author.book": [
                    {
                        "uid": "_:Book2"
                    }
                ],
                "dgraph.type": [
                    "author"
                ],
                "uid": "_:author3"
            },
            "Book.ISBN": "2312SB",
            "Book.title": "Sapiens",
            "dgraph.type": [
                "Book"
            ],
            "uid": "_:Book2"
        }

-
  name: "Add type with multiple Xid fields at deep level"
  gqlmutation: |
    mutation($input: [AddauthorInput!]!) {
    	addauthor(input: $input) {
    		author {
    			name
    			book {
    				title
    				ISBN
    			}
    		}
    	}
    }

  gqlvariables: |
    {
        "input": [
            {
                "name": "Yuval Noah Harari",
                "book": {
                    "title": "Sapiens",
                    "ISBN": "2312SB"
                }
            }
        ]
    }
  dgquery: |-
    query {
      Book1(func: eq(Book.ISBN, "2312SB")) @filter(type(Book)) {
        uid
      }
      Book2(func: eq(Book.title, "Sapiens")) @filter(type(Book)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
            "author.name": "Yuval Noah Harari",
            "dgraph.type": [
                "author"
            ],
            "uid": "_:author3",
            "author.book": [
                {
                    "Book.ISBN": "2312SB",
                    "Book.title": "Sapiens",
                    "Book.author": {
                        "uid": "_:author3"
                    },
                    "dgraph.type": [
                        "Book"
                    ],
                    "uid": "_:Book2"
                }
            ]
        }

-
  name: "Add mutation for type Person1 with multiple xids referencing same node as closeFriends and friends, closeFriends refer friends with xid id"
  explanation: "The mutation adds same node as friends and closeFriends. It should
    work irrespective of the order in which the node is referenced."
  gqlmutation: |
    mutation($input: [AddPerson1Input!]!) {
      addPerson1(input: $input) {
        person1 {
          id
          name
          friends {
            id
            name
          }
          closeFriends {
            id
            name
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "id": "1",
          "name": "First Person",
          "friends": [{
            "id": "2",
            "name": "Second Person"
           }],
          "closeFriends": [{
            "id": "2"
           }]
        }
      ]
    }
  dgquery: |-
    query {
      Person11(func: eq(Person1.id, "1")) @filter(type(Person1)) {
        uid
      }
      Person12(func: eq(Person1.name, "First Person")) @filter(type(Person1)) {
        uid
      }
      Person13(func: eq(Person1.id, "2")) @filter(type(Person1)) {
        uid
      }
      Person14(func: eq(Person1.name, "Second Person")) @filter(type(Person1)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "Person1.closeFriends": [
            {
              "Person1.closeFriends": [
                {
                  "uid": "_:Person12"
                }
              ],
              "Person1.name": "Second Person",
              "Person1.id": "2",
              "dgraph.type": [
                "Person1"
              ],
              "uid": "_:Person14"
            }
          ],
          "Person1.friends": [
            {
              "uid": "_:Person14",
              "Person1.friends": [
                {
                  "uid": "_:Person12"
                }
              ]
            }
          ],
          "Person1.name": "First Person",
          "Person1.id": "1",
          "dgraph.type": [
            "Person1"
          ],
          "uid": "_:Person12"
        }

-
  name: "Add type with multiple Xids fields at deep level when deep node already exist for all existence queries"
  gqlmutation: |
    mutation($input: [AddauthorInput!]!) {
    	addauthor(input: $input) {
    		author {
    			name
    			book {
    				title
    				ISBN
    			}
    		}
    	}
    }

  gqlvariables: |
    {
        "input": [
            {
                "name": "Yuval Noah Harari",
                "book": {
                    "title": "Sapiens",
                    "ISBN": "2312SB"
                }
            }
        ]
    }
  dgquery: |-
    query {
      Book1(func: eq(Book.ISBN, "2312SB")) @filter(type(Book)) {
        uid
      }
      Book2(func: eq(Book.title, "Sapiens")) @filter(type(Book)) {
        uid
      }
    }
  dgquerysec: |-
    query {
      var(func: uid(0x117)) {
        author4 as Book.author
      }
    }
  qnametouid: |
    {
      "Book1": "0x117",
      "Book2": "0x116"
    }
  dgmutations:
    - setjson: |
        {
            "author.name": "Yuval Noah Harari",
            "dgraph.type": [
                "author"
            ],
            "uid": "_:author3",
            "author.book": [
                {
                    "Book.author": {
                        "uid": "_:author3"
                    },
                    "uid": "0x117"
                }
            ]
        }
      deletejson: |
        [
            {
                "author.book": [
                    {
                        "uid": "0x117"
                    }
                ],
                "uid": "uid(author4)"
            }
        ]

-
  name: "Add type with multiple Xids fields at deep level when deep node already exist for one existence query"
  gqlmutation: |
    mutation($input: [AddauthorInput!]!) {
    	addauthor(input: $input) {
    		author {
    			name
    			book {
    				title
    				ISBN
    			}
    		}
    	}
    }

  gqlvariables: |
    {
        "input": [
            {
                "name": "Yuval Noah Harari",
                "book": {
                    "title": "Sapiens",
                    "ISBN": "2312SB"
                }
            }
        ]
    }
  dgquery: |-
    query {
      Book1(func: eq(Book.ISBN, "2312SB")) @filter(type(Book)) {
        uid
      }
      Book2(func: eq(Book.title, "Sapiens")) @filter(type(Book)) {
        uid
      }
    }
  dgquerysec: |-
    query {
      var(func: uid(0x119)) {
        author4 as Book.author
      }
    }
  qnametouid: |
    {
      "Book2": "0x119"
    }
  dgmutations:
    - setjson: |
        {
            "author.name": "Yuval Noah Harari",
            "dgraph.type": [
                "author"
            ],
            "uid": "_:author3",
            "author.book": [
                {
                    "Book.author": {
                        "uid": "_:author3"
                    },
                    "uid": "0x119"
                }
            ]
        }
      deletejson: |
        [
            {
                "author.book": [
                    {
                        "uid": "0x119"
                    }
                ],
                "uid": "uid(author4)"
            }
        ]

-
  name: "Add mutation for type Person1 with multiple xids referencing same node as closeFriends and friends, friends refer closeFriends with xid name "
  explanation: "The mutation adds same node as friends and closeFriends. It should
    work irrespective of the order in which the node is referenced."
  gqlmutation: |
    mutation($input: [AddPerson1Input!]!) {
      addPerson1(input: $input) {
        person1 {
          id
          name
          friends {
            id
            name
          }
          closeFriends {
            id
            name
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "id": "1",
          "name": "First Person",
          "closeFriends": [{
            "id": "2",
            "name": "Second Person"
           }],
          "friends": [{
            "name": "Second Person"
           }]
        }
      ]
    }
  dgquery: |-
    query {
      Person11(func: eq(Person1.id, "1")) @filter(type(Person1)) {
        uid
      }
      Person12(func: eq(Person1.name, "First Person")) @filter(type(Person1)) {
        uid
      }
      Person13(func: eq(Person1.id, "2")) @filter(type(Person1)) {
        uid
      }
      Person14(func: eq(Person1.name, "Second Person")) @filter(type(Person1)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
            "Person1.closeFriends": [
                {
                    "Person1.closeFriends": [
                        {
                            "uid": "_:Person12"
                        }
                    ],
                    "Person1.id": "2",
                    "Person1.name": "Second Person",
                    "dgraph.type": [
                        "Person1"
                    ],
                    "uid": "_:Person14"
                }
            ],
            "Person1.friends": [
                {
                    "Person1.friends": [
                        {
                            "uid": "_:Person12"
                        }
                    ],
                    "uid": "_:Person14"
                }
            ],
            "Person1.id": "1",
            "Person1.name": "First Person",
            "dgraph.type": [
                "Person1"
            ],
            "uid": "_:Person12"
        }

- name: "Reference to inverse field should be ignored and not throw an error"
  gqlmutation: |
    mutation addDistrict($input: [AddDistrictInput!]!) {
      addDistrict(input: $input) {
        district {
          name
          code
          cities {
            name
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "name": "Dist1",
          "code": "D1",
          "cities": [{"name": "Bengaluru", "district": { "code": "non-existing" } }]
        },
        {
          "name": "Dist2",
          "code": "D2",
          "cities": [{"name": "Pune", "district": { "code": "D2" } }]
        }
      ]
    }
  explanation: "As district is inverse of city. There is no need to supply district to
    the city. In case it is supplied, it is simply ignored. The city is linked to D1 and
    district with code non-existing is ignored. Not even its existence query is generated."
  dgquery: |-
    query {
      District1(func: eq(District.code, "D1")) @filter(type(District)) {
        uid
      }
      District2(func: eq(District.code, "D2")) @filter(type(District)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "District.cities":
            [
              {
                "City.name":"Bengaluru",
                "dgraph.type":["City"],
                "City.district": {
                  "uid": "_:District1"
                },
                "uid":"_:City3"
              }
            ],
            "District.code":"D1",
            "District.name":"Dist1",
            "dgraph.type":["District"],
            "uid":"_:District1"
        }
    - setjson: |
        {
          "District.cities":
            [
              {
                "City.name":"Pune",
                "dgraph.type":["City"],
                "City.district": {
                  "uid": "_:District2"
                },
                "uid":"_:City4"
              }
            ],
            "District.code":"D2",
            "District.name":"Dist2",
            "dgraph.type":["District"],
            "uid":"_:District2"
        }

- name: "Reference to inverse field should be ignored and not throw an error 2"
  gqlmutation: |
    mutation addFoo($input: [AddFooInput!]!) {
      addFoo(input: $input) {
        foo {
          id
          bar {
            id
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "id": "123",
          "bar": {"id": "1234", "foo": { "id": "123" } }
        },
        {
          "id": "1",
          "bar": {"id": "2", "foo": { "id": "3" } }
        }
      ]
    }
  explanation: "As foo is inverse of bar. There is no need to supply bar to
    foo. In case it is supplied, it is simply ignored."
  dgquery: |-
    query {
      Foo1(func: eq(Foo.id, "123")) @filter(type(Foo)) {
        uid
      }
      Bar2(func: eq(Bar.id, "1234")) @filter(type(Bar)) {
        uid
      }
      Foo3(func: eq(Foo.id, "1")) @filter(type(Foo)) {
        uid
      }
      Bar4(func: eq(Bar.id, "2")) @filter(type(Bar)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "Foo.bar":
              {
                "Bar.id":"1234",
                "dgraph.type":["Bar"],
                "Bar.foo": {
                  "uid": "_:Foo1"
                },
                "uid":"_:Bar2"
              },
            "Foo.id":"123",
            "dgraph.type":["Foo"],
            "uid":"_:Foo1"
        }
    - setjson: |
        {
          "Foo.bar":
              {
                "Bar.id":"2",
                "dgraph.type":["Bar"],
                "Bar.foo": {
                  "uid": "_:Foo3"
                },
                "uid":"_:Bar4"
              },
            "Foo.id":"1",
            "dgraph.type":["Foo"],
            "uid":"_:Foo3"
        }
