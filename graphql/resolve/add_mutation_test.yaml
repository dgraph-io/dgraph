-
  name: "Add mutation geo field - Point type"
  gqlmutation: |
    mutation addHotel($hotel: AddHotelInput!) {
      addHotel(input: [$hotel]) {
        hotel {
          name
          location {
            latitude
            longitude
          }
        }
      }
    }
  gqlvariables: |
    { "hotel":
      { "name": "Taj Hotel",
        "location": { "latitude": 11.11 , "longitude" : 22.22}
      }
    }
  qnametouid: |
  explanation: "Add mutation should convert the Point type mutation to corresponding Dgraph JSON mutation"
  dgmutations:
    - setjson: |
        { "uid":"_:Hotel1",
          "dgraph.type":["Hotel"],
          "Hotel.name":"Taj Hotel",
          "Hotel.location": {
            "type": "Point",
            "coordinates": [22.22, 11.11]
          }
        }

-
  name: "Add mutation geo field - Polygon type"
  gqlmutation: |
    mutation addHotel($hotel: AddHotelInput!) {
      addHotel(input: [$hotel]) {
        hotel {
          name
          area {
            coordinates {
              points {
                latitude
                longitude
              }
            }
          }
        }
      }
    }
  gqlvariables: |
    { "hotel":
      { "name": "Taj Hotel",
        "area": {
          "coordinates": [{
            "points": [{
              "latitude": 11.11,
              "longitude": 22.22
            }, {
              "latitude": 15.15,
              "longitude": 16.16
            }, {
              "latitude": 20.20,
              "longitude": 21.21
            }]
          }, {
              "points": [{
                "latitude": 11.18,
                "longitude": 22.28
              }, {
                "latitude": 15.18,
                "longitude": 16.18
              }, {
                "latitude": 20.28,
                "longitude": 21.28
              }]
          }]
        }
      }
    }
  explanation: "Add mutation should convert the Polygon type mutation to corresponding Dgraph JSON mutation"
  dgmutations:
    - setjson: |
        {
          "uid":"_:Hotel1",
          "dgraph.type":["Hotel"],
          "Hotel.name":"Taj Hotel",
          "Hotel.area": {
            "type": "Polygon",
            "coordinates": [[[22.22,11.11],[16.16,15.15],[21.21,20.2]],[[22.28,11.18],[16.18,15.18],[21.28,20.28]]]
          }
        }

-
  name: "Add mutation geo field - MultiPolygon type"
  gqlmutation: |
    mutation addHotel($hotel: AddHotelInput!) {
      addHotel(input: [$hotel]) {
        hotel {
          name
          branches {
            polygons {
              coordinates {
                points {
                  latitude
                  longitude
                }
              }
            }
          }
        }
      }
    }
  gqlvariables: |
    { "hotel":
      { "name": "Taj Hotel",
        "branches": {
          "polygons": [{
            "coordinates": [{
              "points": [{
                "latitude": 11.11,
                "longitude": 22.22
              }, {
                "latitude": 15.15,
                "longitude": 16.16
              }, {
                "latitude": 20.20,
                "longitude": 21.21
              }]
            }, {
              "points": [{
                "latitude": 11.18,
                "longitude": 22.28
              }, {
                "latitude": 15.18,
                "longitude": 16.18
              }, {
                "latitude": 20.28,
                "longitude": 21.28
              }]
            }]
          }, {
            "coordinates": [{
              "points": [{
                "latitude": 91.11,
                "longitude": 92.22
              }, {
                "latitude": 15.15,
                "longitude": 16.16
              }, {
                "latitude": 20.20,
                "longitude": 21.21
              }]
            }, {
              "points": [{
                "latitude": 11.18,
                "longitude": 22.28
              }, {
                "latitude": 15.18,
                "longitude": 16.18
              }, {
                "latitude": 20.28,
                "longitude": 21.28
              }]
            }]
        }]
        }
      }
    }
  explanation: "Add mutation should convert the MultiPolygon type mutation to corresponding Dgraph JSON mutation"
  dgmutations:
    - setjson: |
        {
          "uid":"_:Hotel1",
          "dgraph.type":["Hotel"],
          "Hotel.name":"Taj Hotel",
          "Hotel.branches": {
            "type": "MultiPolygon",
            "coordinates": [[[[22.22,11.11],[16.16,15.15],[21.21,20.2]],[[22.28,11.18],[16.18,15.18],[21.28,20.28]]],[[[92.22,91.11],[16.16,15.15],[21.21,20.2]],[[22.28,11.18],[16.18,15.18],[21.28,20.28]]]]
          }
        }

-
  name: "Add mutation with variables"
  gqlmutation: |
    mutation addAuthor($auth: AddAuthorInput!) {
      addAuthor(input: [$auth]) {
        author {
          name
        }
      }
    }
  gqlvariables: |
    { "auth":
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": []
      }
    }
  explanation: "A uid and type should get injected and all data transformed to
    underlying Dgraph edge names"
  dgmutations:
    - setjson: |
        { "uid":"_:Author1",
          "dgraph.type":["Author"],
          "Author.name":"A.N. Author",
          "Author.dob":"2000-01-01",
          "Author.posts":[]
        }

-
  name: "Add deep mutation with variables"
  gqlmutation: |
    mutation addAuthor($auth: AddAuthorInput!) {
      addAuthor(input: [$auth]) {
        author {
          name
        }
      }
    }
  gqlvariables: |
    { "auth":
      { "name": "A.N. Author",
        "posts": [{
                "title": "post1",
                "ps": {"title": "ps1"}
        }, {
                "title": "post2",
                "ps": {"title": "ps2"}
        }, {
                "title": "post3",
                "ps": {"title": "ps3"}
        }, {
                "title": "post4",
                "ps": {"title": "ps4"}
        }, {
                "title": "post5",
                "ps": {"title": "ps5"}
        }, {
                "title": "post6",
                "ps": {"title": "ps6"}
        }, {
                "title": "post7",
                "ps": {"title": "ps7"}
        }, {
                "title": "post8",
                "ps": {"title": "ps8"}
        }]
      }
    }
  explanation: "A uid and type should get injected and all data transformed to
    underlying Dgraph edge names. Some PostSecrets are present and are not created."
  dgquery: |-
    query {
      PostSecret1(func: eq(PostSecret.title, "ps1")) @filter(type(PostSecret)) {
        uid
      }
      PostSecret2(func: eq(PostSecret.title, "ps2")) @filter(type(PostSecret)) {
        uid
      }
      PostSecret3(func: eq(PostSecret.title, "ps3")) @filter(type(PostSecret)) {
        uid
      }
      PostSecret4(func: eq(PostSecret.title, "ps4")) @filter(type(PostSecret)) {
        uid
      }
      PostSecret5(func: eq(PostSecret.title, "ps5")) @filter(type(PostSecret)) {
        uid
      }
      PostSecret6(func: eq(PostSecret.title, "ps6")) @filter(type(PostSecret)) {
        uid
      }
      PostSecret7(func: eq(PostSecret.title, "ps7")) @filter(type(PostSecret)) {
        uid
      }
      PostSecret8(func: eq(PostSecret.title, "ps8")) @filter(type(PostSecret)) {
        uid
      }
    }
  qnametouid: |
    {
      "PostSecret1":"0x1",
      "PostSecret2":"0x2",
      "PostSecret3":"0x3",
      "PostSecret4":"0x4"
    }
  dgmutations:
    - setjson: |
        {
          "Author.name":"A.N. Author",
          "Author.posts":
            [
              {
                "Post.author":
                  {
                    "uid":"_:Author9"
                  },
                "Post.ps":
                  {
                    "uid":"0x1"
                  },
                "Post.title":"post1",
                "dgraph.type":["Post"],
                "uid":"_:Post10"
              },
              {
                "Post.author":
                  {
                    "uid":"_:Author9"
                  },
                "Post.ps":
                  {
                    "uid":"0x2"
                  },
                "Post.title":"post2",
                "dgraph.type":["Post"],
                "uid":"_:Post11"
              },
              {
                "Post.author":
                  {
                    "uid":"_:Author9"
                  },
                "Post.ps":
                  {
                    "uid":"0x3"
                  },
                "Post.title":"post3",
                "dgraph.type":["Post"],
                "uid":"_:Post12"
              },
              {
                "Post.author":
                  {
                    "uid":"_:Author9"
                  },
                "Post.ps":
                  {
                    "uid":"0x4"
                  },
                "Post.title":"post4",
                "dgraph.type":["Post"],
                "uid":"_:Post13"
              },
              {
                "Post.author":
                  {
                    "uid":"_:Author9"
                  },
                "Post.ps":
                  {
                    "PostSecret.title":"ps5",
                    "dgraph.type":["PostSecret"],
                    "uid":"_:PostSecret5"
                  },
                "Post.title":"post5",
                "dgraph.type":["Post"],
                "uid":"_:Post14"
              },
              {
                "Post.author":
                  {
                    "uid":"_:Author9"
                  },
                "Post.ps":
                  {
                    "PostSecret.title":"ps6",
                    "dgraph.type":["PostSecret"],
                    "uid":"_:PostSecret6"
                  },
                "Post.title":"post6",
                "dgraph.type":["Post"],
                "uid":"_:Post15"
              },
              {
                "Post.author":
                  {
                    "uid":"_:Author9"
                  },
                "Post.ps":
                  {
                    "PostSecret.title":"ps7",
                    "dgraph.type":["PostSecret"],
                    "uid":"_:PostSecret7"
                  },
                "Post.title":"post7",
                "dgraph.type":["Post"],
                "uid":"_:Post16"
              },
              {
                "Post.author":
                  {
                    "uid":"_:Author9"
                  },
                "Post.ps":
                  {
                    "PostSecret.title":"ps8",
                    "dgraph.type":["PostSecret"],
                    "uid":"_:PostSecret8"
                  },
                "Post.title":"post8",
                "dgraph.type":["Post"],
                "uid":"_:Post17"
              }
            ],
          "dgraph.type":["Author"],
          "uid":"_:Author9"
        }

-
  name: "Add mutation for predicates with special characters having @dgraph directive."
  gqlmutation: |
    mutation {
      addMessage(input : [{content : "content1", author: "author1"}]) {
        message {
          content
          author
        }
      }
    }
  dgmutations:
    - setjson: |
        {
          "uid":"_:Message1",
          "dgraph.type":["Message"],
          "职业":"author1",
          "post":"content1"
        }

-
  name: "Add multiple mutation with variables"
  gqlmutation: |
    mutation addAuthor($auth: [AddAuthorInput!]!) {
      addAuthor(input: $auth) {
        author {
          name
        }
      }
    }
  gqlvariables: |
    {
      "auth": [{
          "name": "A.N. Author"
        },
        {
          "name": "Different Author"
        }
      ]
    }
  explanation: "A uid and type should get injected and all data transformed to
    underlying Dgraph edge names"
  dgmutations:
    - setjson: |
        { "uid":"_:Author1",
          "dgraph.type":["Author"],
          "Author.name":"A.N. Author"
        }
    - setjson: |
        { "uid":"_:Author2",
          "dgraph.type":["Author"],
          "Author.name":"Different Author"
        }

-
  name: "Add Mutation with object at root instead of an array"
  gqlmutation: |
    mutation addAuthor {
      addAuthor(input: { name: "A.N. Author"}) {
        author {
          name
        }
      }
    }
  explanation: "The input being an object should also work because of the input coercion rules
  for input objects."
  dgmutations:
    - setjson: |
        { "uid":"_:Author1",
          "dgraph.type":["Author"],
          "Author.name":"A.N. Author"
        }


-
  name: "Add Mutation with embedded value"
  gqlmutation: |
    mutation addAuthor {
      addAuthor(input: [{ name: "A.N. Author", posts: []}]) {
        author {
          name
        }
      }
    }
  explanation: "The input should be used for the mutation, with a uid and type getting
    injected and all data transformed to underlying Dgraph edge names"
  dgmutations:
    - setjson: |
        { "uid":"_:Author1",
          "dgraph.type":["Author"],
          "Author.name":"A.N. Author",
          "Author.posts":[]
        }

-
  name: "Add Mutation with Password field"
  gqlmutation: |
    mutation addUser($name: String!, $pwd: String!) {
      addUser(input: [{ name: $name, pwd: $pwd}]) {
        user {
          name
        }
      }
    }
  gqlvariables: |
    { "name":  "A.N. Author", "pwd": "Password" }
  explanation: "The input and variables should be used for the mutation, with a uid and type
    getting injected and all data transformed to underlying Dgraph edge names"
  dgquery: |-
    query {
      User1(func: eq(User.name, "A.N. Author")) @filter(type(User)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "uid":"_:User1",
          "dgraph.type":["User"],
          "User.name":"A.N. Author",
          "User.pwd":"Password"
        }

-
  name: "Add Multiple Mutations with embedded value"
  gqlmutation: |
    mutation addAuthor {
      addAuthor(input: [{ name: "A.N. Author", posts: []},
                        { name: "Different Author", posts: []}]) {
        author {
          name
        }
      }
    }
  explanation: "The input should be used for the mutation, with a uid and type getting
    injected and all data transformed to underlying Dgraph edge names"
  dgmutations:
    - setjson: |
        {
          "uid":"_:Author1",
          "dgraph.type":["Author"],
          "Author.name":"A.N. Author",
          "Author.posts":[]
        }
    - setjson: |
        {
          "uid":"_:Author2",
          "dgraph.type":["Author"],
          "Author.name":"Different Author",
          "Author.posts":[]
        }

-
  name: "Add mutation with reference"
  gqlmutation: |
    mutation addAuthor($auth: AddAuthorInput!) {
      addAuthor(input: [$auth]) {
        author {
          name
        }
      }
    }
  gqlvariables: |
    { "auth":
      { "name": "A.N. Author",
        "country": { "id": "0x123" },
        "posts": []
      }
    }
  explanation: "The reference to country should get transformed to 'uid' for the
    Dgraph JSON mutation"
  dgquery: |-
    query {
      Country1(func: uid(0x123)) @filter(type(Country)) {
        uid
      }
    }
  qnametouid: |-
    {
      "Country1":"0x123"
    }
  dgmutations:
    - setjson: |
        {
          "uid":"_:Author2",
          "dgraph.type":["Author"],
          "Author.name":"A.N. Author",
          "Author.country":
            {
              "uid": "0x123"
            },
          "Author.posts":[]
        }

-
  name: "Add mutation with missing reference"
  gqlmutation: |
    mutation addAuthor($auth: AddAuthorInput!) {
      addAuthor(input: [$auth]) {
        author {
          name
        }
      }
    }
  gqlvariables: |
    { "auth":
      { "name": "A.N. Author",
        "country": { "id": "0x123" },
        "posts": []
      }
    }
  explanation: "This should throw an error as 0x123 is not a valid Country node"
  dgquery: |-
    query {
      Country1(func: uid(0x123)) @filter(type(Country)) {
        uid
      }
    }
  error2:
    {
      "message": "failed to rewrite mutation payload because ID \"0x123\" isn't a Country"
    }

-
  name: "Add mutation with invalid reference"
  gqlmutation: |
    mutation addAuthor($auth: AddAuthorInput!) {
      addAuthor(input: [$auth]) {
        author {
          name
        }
      }
    }
  gqlvariables: |
    { "auth":
      { "name": "A.N. Author",
        "country": { "id": "HI!" },
        "posts": []
      }
    }
  explanation: "A reference must be a valid UID"
  error:
    { "message":
        "failed to rewrite mutation payload because ID argument (HI!) was not able to be parsed" }

-
  name: "Add mutation with inverse reference"
  gqlmutation: |
    mutation addPost($post: AddPostInput!) {
      addPost(input: [$post]) {
        post {
          postID
        }
      }
    }
  gqlvariables: |
    { "post":
      { "title": "Exciting post",
        "text": "A really good post",
        "author": { "id": "0x2" }
      }
    }
  explanation: "The reference to the author node should be transformed to include
    a new 'posts' edge."
  dgquery: |-
    query {
      Author1(func: uid(0x2)) @filter(type(Author)) {
        uid
      }
    }
  qnametouid: |-
    {
      "Author1": "0x2"
    }
  dgmutations:
    - setjson: |
        { "uid" : "_:Post2",
          "dgraph.type" : ["Post"],
          "Post.title" : "Exciting post",
          "Post.text" : "A really good post",
          "Post.author": {
            "uid" : "0x2",
            "Author.posts" : [ { "uid": "_:Post2" } ]
          }
        }

-
  name: "Add mutation for a type that implements an interface"
  gqlmutation: |
    mutation addHuman($human: AddHumanInput!) {
      addHuman(input: [$human]) {
        human {
          name
          dob
          female
        }
      }
    }
  gqlvariables: |
    { "human":
      { "name": "Bob",
        "dob": "2000-01-01",
        "female": true,
        "ename": "employee no. 1"
      }
    }
  explanation: "The mutation should get rewritten with correct edges from the interface."
  dgmutations:
    - setjson: |
        { "uid" : "_:Human1",
          "Character.name": "Bob",
          "Employee.ename": "employee no. 1",
          "Human.dob": "2000-01-01",
          "Human.female": true,
          "dgraph.type": ["Human", "Character", "Employee"]
        }

-
  name: "Add mutation using xid code 1"
  gqlmutation: |
    mutation addState($input: AddStateInput!) {
      addState(input: [$input]) {
        state {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "code": "nsw",
        "name": "NSW",
        "country": { "id": "0x12" }
      }
    }
  explanation: "The add mutation should get rewritten into a Dgraph upsert mutation"
  dgquery: |-
    query {
      State1(func: eq(State.code, "nsw")) @filter(type(State)) {
        uid
      }
      Country2(func: uid(0x12)) @filter(type(Country)) {
        uid
      }
    }
  qnametouid: |-
    {
      "Country2": "0x12"
    }
  dgmutations:
    - setjson: |
        { "uid" : "_:State1",
          "dgraph.type": ["State"],
          "State.name": "NSW",
          "State.code": "nsw",
          "State.country": {
            "uid": "0x12",
            "Country.states": [ { "uid": "_:State1" } ]
          }
        }

-
  name: "Add mutation using xid code 2"
  explanation: "Error thrown as node with code nsw exists."
  gqlmutation: |
    mutation addState($input: AddStateInput!) {
      addState(input: [$input], upsert: false) {
        state {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "code": "nsw",
        "name": "NSW",
        "country": { "id": "0x12" }
      }
    }
  dgquery: |-
    query {
      State1(func: eq(State.code, "nsw")) @filter(type(State)) {
        uid
      }
      Country2(func: uid(0x12)) @filter(type(Country)) {
        uid
      }
    }
  qnametouid: |-
    {
      "State1": "0x11",
      "Country2": "0x12"
    }
  error2:
    {
      "message": "failed to rewrite mutation payload because id nsw already exists for field code inside type State"
    }

-
  name: "Multiple Upsert Mutation 1"
  explanation: "As both states exist, the countries of the states are updated"
  gqlmutation: |
    mutation addState($input: [AddStateInput!]!) {
      addState(input: $input, upsert: true) {
        state {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      [
        {
          "code": "nsw",
          "name": "NSW",
          "country": { "id": "0x12" }
        },
        {
          "code": "mh",
          "name": "Maharashtra",
          "country": { "id": "0x14" }
        }
      ]
    }
  dgquery: |-
    query {
      State1(func: eq(State.code, "nsw")) @filter(type(State)) {
        uid
      }
      Country2(func: uid(0x12)) @filter(type(Country)) {
        uid
      }
      State3(func: eq(State.code, "mh")) @filter(type(State)) {
        uid
      }
      Country4(func: uid(0x14)) @filter(type(Country)) {
        uid
      }
    }
  qnametouid: |-
    {
      "State1": "0x11",
      "Country2": "0x12",
      "State3": "0x13",
      "Country4": "0x14"
    }
  dgquerysec: |-
    query {
      State1 as addState(func: uid(0x11)) @filter(type(State)) {
        uid
      }
      State3 as addState(func: uid(0x13)) @filter(type(State)) {
        uid
      }
      var(func: uid(State1)) {
        Country5 as State.country @filter(NOT (uid(0x12)))
      }
      var(func: uid(State3)) {
        Country7 as State.country @filter(NOT (uid(0x14)))
      }
    }
  dgmutations:
    - setjson: |
        { "uid" : "uid(State1)",
          "State.name": "NSW",
          "State.country": {
            "uid": "0x12",
            "Country.states": [ { "uid": "uid(State1)" } ]
          }
        }
      deletejson: |
        [
          {
            "uid":"uid(Country5)",
            "Country.states":
              [
                {
                  "uid":"uid(State1)"
                }
              ]
          }
        ]
      cond: "@if(gt(len(State1), 0))"
    - setjson: |
        { "uid" : "uid(State3)",
          "State.name": "Maharashtra",
          "State.country": {
            "uid": "0x14",
            "Country.states": [ { "uid": "uid(State3)" } ]
          }
        }
      deletejson: |
        [
          {
            "uid":"uid(Country7)",
            "Country.states":
              [
                {
                  "uid":"uid(State3)"
                }
              ]
          }
        ]
      cond: "@if(gt(len(State3), 0))"

-
  name: "Multiple Upsert Mutation with multiple xids where both existence queries result exist"
  gqlmutation: |
    mutation addBook($input: [AddBookInput!]!) {
      addBook(input: $input, upsert: true) {
        book {
          title
          ISBN
        }
      }
    }
  gqlvariables: |
    { "input":
      [
        {
          "title": "Sapiens",
          "ISBN": "NSW",
          "publisher": "penguin"
        }
      ]
    }
  dgquery: |-
    query {
      Book1(func: eq(Book.ISBN, "NSW")) @filter(type(Book)) {
        uid
      }
      Book2(func: eq(Book.title, "Sapiens")) @filter(type(Book)) {
        uid
      }
    }
  qnametouid: |-
    {
      "Book1": "0x11",
      "Book2": "0x11"
    }
  dgquerysec: |-
    query {
      Book2 as addBook(func: uid(0x11)) @filter(type(Book)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        { "uid" : "uid(Book2)",
          "Book.publisher": "penguin"
        }
      cond: "@if(gt(len(Book2), 0))"

-
  name: "Multiple Upsert Mutation 2"
  explanation: "The first state exists and is updated. Second is created. Country
    is also created in second"
  gqlmutation: |
    mutation addState($input: [AddStateInput!]!) {
      addState(input: $input, upsert: true) {
        state {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      [
        {
          "code": "nsw",
          "name": "NSW",
          "country": { "id": "0x12" }
        },
        {
          "code": "mh",
          "name": "Maharashtra",
          "country": { "name": "India" }
        }
      ]
    }
  dgquery: |-
    query {
      State1(func: eq(State.code, "nsw")) @filter(type(State)) {
        uid
      }
      Country2(func: uid(0x12)) @filter(type(Country)) {
        uid
      }
      State3(func: eq(State.code, "mh")) @filter(type(State)) {
        uid
      }
    }
  qnametouid: |-
    {
      "State1": "0x11",
      "Country2": "0x12"
    }
  dgquerysec: |-
    query {
      State1 as addState(func: uid(0x11)) @filter(type(State)) {
        uid
      }
      var(func: uid(State1)) {
        Country4 as State.country @filter(NOT (uid(0x12)))
      }
    }
  dgmutations:
    - setjson: |
        { "uid" : "uid(State1)",
          "State.name": "NSW",
          "State.country": {
            "uid": "0x12",
            "Country.states": [ { "uid": "uid(State1)" } ]
          }
        }
      deletejson: |
        [
          {
            "uid":"uid(Country4)",
            "Country.states":
              [
                {
                  "uid":"uid(State1)"
                }
              ]
          }
        ]
      cond: "@if(gt(len(State1), 0))"
    - setjson: |
        { "uid" : "_:State3",
          "dgraph.type": ["State"],
          "State.name": "Maharashtra",
          "State.code": "mh",
          "State.country": {
            "uid": "_:Country6",
            "dgraph.type": ["Country"],
            "Country.name": "India",
            "Country.states": [ { "uid": "_:State3" } ]
          }
        }

-
  name: "Add mutation using code on type which also has an ID field"
  gqlmutation: |
    mutation addEditor($input: AddEditorInput!) {
      addEditor(input: [$input]) {
        editor {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "code": "editor",
        "name": "A.N. Editor"
      }
    }
  explanation: "The add mutation should get rewritten into a Dgraph upsert mutation"
  dgquery: |-
    query {
      Editor1(func: eq(Editor.code, "editor")) @filter(type(Editor)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "uid" : "_:Editor1",
          "dgraph.type": ["Editor"],
          "Editor.name": "A.N. Editor",
          "Editor.code": "editor"
        }

-
  name: "Deep add mutation"
  gqlmutation: |
    mutation addAuthor($author: AddAuthorInput!) {
      addAuthor(input: [$author]) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    { "author":
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "title": "New post",
            "text": "A really new post"
          }
        ]
      }
    }
  dgmutations:
    - setjson: |
        { "uid" : "_:Author1",
          "dgraph.type" : [ "Author" ],
          "Author.name": "A.N. Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post2",
              "dgraph.type" : [ "Post" ],
              "Post.title" : "New post",
              "Post.text" : "A really new post",
              "Post.author": {
                "uid" : "_:Author1"
              }
            }
          ]
        }

-
  name: "Deep add multiple mutation"
  gqlmutation: |
    mutation addAuthor($author: [AddAuthorInput!]!) {
      addAuthor(input: $author) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    { "author": [
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "title": "New post",
            "text": "A really new post"
          }
        ]
      },
      { "name": "Different Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "title": "New New post",
            "text": "A wonderful post"
          }
        ]
      }]
    }
  dgmutations:
    - setjson: |
        { "uid" : "_:Author1",
          "dgraph.type" : [ "Author" ],
          "Author.name": "A.N. Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post2",
              "dgraph.type" : [ "Post" ],
              "Post.title" : "New post",
              "Post.text" : "A really new post",
              "Post.author": {
                "uid" : "_:Author1"
              }
            }
          ]
        }
    - setjson: |
        { "uid" : "_:Author3",
          "dgraph.type" : [ "Author" ],
          "Author.name": "Different Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post4",
              "dgraph.type" : [ "Post" ],
              "Post.title" : "New New post",
              "Post.text" : "A wonderful post",
              "Post.author": {
                "uid" : "_:Author3"
              }
            }
          ]
        }

-
  name: "Deep add with existing"
  gqlmutation: |
    mutation addAuthor($author: AddAuthorInput!) {
      addAuthor(input: [$author]) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    { "author":
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "title": "New post",
            "text": "A really new post"
          },
          {
            "postID": "0x123",
            "title": "Old post",
            "text": "A really old post"
          }
        ]
      }
    }
  dgquery: |-
    query {
      Post1(func: uid(0x123)) @filter(type(Post)) {
        uid
      }
    }
  qnametouid: |-
    {
      "Post1":"0x123"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x123)) {
        Author4 as Post.author
      }
    }
  dgmutations:
    - setjson: |
        { "uid": "_:Author2",
          "dgraph.type": [ "Author" ],
          "Author.name": "A.N. Author",
          "Author.dob": "2000-01-01",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post3",
              "dgraph.type": [ "Post" ],
              "Post.title": "New post",
              "Post.text": "A really new post",
              "Post.author": {
                "uid": "_:Author2"
              }
            },
            {
              "uid": "0x123",
              "Post.author": {
                "uid": "_:Author2"
              }
            }
          ]
        }
      deletejson: |
        [
          {
            "uid": "uid(Author4)",
            "Author.posts": [{"uid": "0x123"}]
          }
        ]

-
  name: "Deep add multiple with existing"
  gqlmutation: |
    mutation addAuthor($author: [AddAuthorInput!]!) {
      addAuthor(input: $author) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    { "author": [
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "title": "New post",
            "text": "A really new post"
          },
          {
            "postID": "0x123",
            "title": "Old post",
            "text": "A really old post"
          }
        ]
      },
      { "name": "Different Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "title": "New new post",
            "text": "A wonderful post"
          },
          {
            "postID": "0x124",
            "title": "Another Old post",
            "text": "Another old post text"
          }
        ]
      }]
    }
  dgquery: |-
    query {
      Post1(func: uid(0x123)) @filter(type(Post)) {
        uid
      }
      Post2(func: uid(0x124)) @filter(type(Post)) {
        uid
      }
    }
  qnametouid: |-
    {
      "Post1":"0x123",
      "Post2":"0x124"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x123)) {
        Author5 as Post.author
      }
      var(func: uid(0x124)) {
        Author8 as Post.author
      }
    }
  dgmutations:
    - setjson: |
        { "uid": "_:Author3",
          "dgraph.type": [ "Author" ],
          "Author.name": "A.N. Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post4",
              "dgraph.type": [ "Post" ],
              "Post.title": "New post",
              "Post.text": "A really new post",
              "Post.author": {
                "uid": "_:Author3"
              }
            },
            {
              "uid": "0x123",
              "Post.author": {
                "uid": "_:Author3"
              }
            }
          ]
        }
      deletejson: |
        [
          {
            "uid": "uid(Author5)",
            "Author.posts": [
              {
              "uid": "0x123"
              }
            ]
          }
        ]
    - setjson: |
        {
          "uid": "_:Author6",
          "dgraph.type": [ "Author" ],
          "Author.name": "Different Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post7",
              "dgraph.type": [ "Post" ],
              "Post.title": "New new post",
              "Post.text": "A wonderful post",
              "Post.author": {
                "uid": "_:Author6"
              }
            },
            {
              "uid": "0x124",
              "Post.author": {
                "uid": "_:Author6"
              }
            }
          ]
        }
      deletejson: |
        [
          {
            "uid": "uid(Author8)",
            "Author.posts": [
              {
                "uid": "0x124"
              }
            ]
          }
        ]

-
  name: "Deep add with two existing"
  gqlmutation: |
    mutation addAuthor($author: AddAuthorInput!) {
      addAuthor(input: [$author]) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    { "author":
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "postID": "0x123",
            "title": "Old post",
            "text": "A really old post"
          },
          {
            "postID": "0x456"
          }
        ]
      }
    }
  dgquery: |-
    query {
      Post1(func: uid(0x123)) @filter(type(Post)) {
        uid
      }
      Post2(func: uid(0x456)) @filter(type(Post)) {
        uid
      }
    }
  qnametouid: |-
    {
      "Post1":"0x123",
      "Post2":"0x456"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x123)) {
        Author4 as Post.author
      }
      var(func: uid(0x456)) {
        Author5 as Post.author
      }
    }
  dgmutations:
    - setjson: |
        { "uid": "_:Author3",
          "dgraph.type": [ "Author" ],
          "Author.name": "A.N. Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "0x123",
              "Post.author": {
                "uid": "_:Author3"
              }
            },
            {
              "uid": "0x456",
              "Post.author": {
                "uid": "_:Author3"
              }
            }
          ]
        }
      deletejson: |
        [
          {
            "uid": "uid(Author4)",
            "Author.posts": [{"uid": "0x123"}]
          },
          {
            "uid": "uid(Author5)",
            "Author.posts": [{"uid": "0x456"}]
          }
        ]

-
  name: "Deep add with null"
  gqlmutation: |
    mutation addAuthor($author: AddAuthorInput!) {
      addAuthor(input: [$author]) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    { "author":
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "postID": null,
            "title": "New post",
            "text": "A really new post"
          }
        ]
      }
    }
  dgmutations:
    - setjson: |
        { "uid" : "_:Author1",
          "dgraph.type" : [ "Author" ],
          "Author.name": "A.N. Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post2",
              "dgraph.type" : [ "Post" ],
              "Post.title" : "New post",
              "Post.text" : "A really new post",
              "Post.author": {
                "uid" : "_:Author1"
              }
            }
          ]
        }

-
  name: "Add three deep"
  gqlmutation: |
    mutation addAuthor($author: AddAuthorInput!) {
      addAuthor(input: [$author]) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    { "author":
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "title": "Exciting post",
            "text": "A really good post",
            "category": {
              "name": "New Category"
            }
          }
        ]
      }
    }
  dgmutations:
    - setjson: |
        { "uid": "_:Author1",
          "dgraph.type": [ "Author" ],
          "Author.name": "A.N. Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post2",
              "dgraph.type": [ "Post" ],
              "Post.title": "Exciting post",
              "Post.text": "A really good post",
              "Post.author": {
                "uid": "_:Author1"
              },
              "Post.category": {
                "uid": "_:Category3",
                "dgraph.type": [ "Category" ],
                "Category.name": "New Category",
                "Category.posts": [
                  { "uid": "_:Post2" }
                ]
              }
            }
          ]
        }

-
  name: "Add mutation with deep xid choices 1"
  gqlmutation: |
    mutation addCountry($input: AddCountryInput!) {
      addCountry(input: [$input]) {
        country {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "name": "Dgraph Land",
        "states": [ {
          "code": "dg",
          "name": "Dgraph"
        } ]
      }
    }
  explanation: "No nodes exist. Both nodes are created."
  dgquery: |-
    query {
      State1(func: eq(State.code, "dg")) @filter(type(State)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "Country.name":"Dgraph Land",
          "Country.states":
            [
              {
                "State.code":"dg",
                "State.country":
                  {
                    "uid":"_:Country2"
                  },
                "State.name":"Dgraph",
                "dgraph.type":["State"],
                "uid":"_:State1"
              }
            ],
          "dgraph.type":["Country"],
          "uid":"_:Country2"
        }

-
  name: "Add mutation with deep xid choices 2"
  gqlmutation: |
    mutation addCountry($input: AddCountryInput!) {
      addCountry(input: [$input]) {
        country {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "name": "Dgraph Land",
        "states": [ {
          "code": "dg",
          "name": "Dgraph"
        } ]
      }
    }
  explanation: "The state exists. It is linked to the new Country. Its link to old country is deleted."
  dgquery: |-
    query {
      State1(func: eq(State.code, "dg")) @filter(type(State)) {
        uid
      }
    }
  qnametouid: |-
    {
      "State1":"0x12"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x12)) {
        Country3 as State.country
      }
    }
  dgmutations:
    - setjson: |
        {
          "Country.name":"Dgraph Land",
          "Country.states":
            [
              {
                "State.country":
                  {
                    "uid":"_:Country2"
                  },
                "uid":"0x12"
              }
            ],
          "dgraph.type":["Country"],
          "uid":"_:Country2"
        }
      deletejson: |
        [
          {
            "uid":"uid(Country3)",
            "Country.states":
              [
                {
                  "uid":"0x12"
                }
              ]
          }
        ]

-
  name: "Add mutation with deep xid that must be reference 1"
  gqlmutation: |
    mutation addCountry($input: AddCountryInput!) {
      addCountry(input: [$input]) {
        country {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "name": "Dgraph Land",
        "states": [ {
          "code": "dg"
        } ]
      }
    }
  explanation: "The add mutation has only one option because the state isn't a valid create
    because it's missing required field name"
  dgquery: |-
    query {
      State1(func: eq(State.code, "dg")) @filter(type(State)) {
        uid
      }
    }
  qnametouid: |-
    {
      "State1":"0x12"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x12)) {
        Country3 as State.country
      }
    }
  dgmutations:
    - setjson: |
        {
          "uid": "_:Country2",
          "dgraph.type": ["Country"],
          "Country.name": "Dgraph Land",
          "Country.states":
            [
              {
                "uid": "0x12",
                "State.country":
                  {
                    "uid": "_:Country2"
                  }
              }
            ]
        }
      deletejson: |
        [
          {
            "uid": "uid(Country3)",
            "Country.states": [{"uid": "0x12"}]
          }
        ]

-
  name: "Add mutation with deep xid that must be reference 2"
  gqlmutation: |
    mutation addCountry($input: AddCountryInput!) {
      addCountry(input: [$input]) {
        country {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "name": "Dgraph Land",
        "states": [ {
          "code": "dg"
        } ]
      }
    }
  explanation: "Error is thrown as State with code dg does not exist"
  dgquery: |-
    query {
      State1(func: eq(State.code, "dg")) @filter(type(State)) {
        uid
      }
    }
  error2:
    {
      "message": "failed to rewrite mutation payload because type State requires a value for field name, but no value present"
    }


-
  name: "deprecated fields can be mutated"
  gqlmutation: |
    mutation addCategory($cat: AddCategoryInput!) {
      addCategory(input: [$cat]) {
        category {
          name
          iAmDeprecated
        }
      }
    }
  gqlvariables: |
    { "cat":
      { "name": "A Category",
        "iAmDeprecated": "but I can be written to"
      }
    }
  dgmutations:
    - setjson: |
        { "uid": "_:Category1",
          "dgraph.type": ["Category"],
          "Category.name": "A Category",
          "Category.iAmDeprecated": "but I can be written to"
        }

-
  name: "Add mutation with reverse predicate"
  gqlmutation: |
    mutation addMovieDirector($dir: AddMovieDirectorInput!) {
      addMovieDirector(input: [$dir]) {
        movieDirector {
          id
        }
      }
    }
  gqlvariables: |
    { "dir":
      { "name": "Steven Spielberg",
        "directed": [{ "id": "0x2" }]
      }
    }
  explanation: "Movie node exists and is not created"
  dgquery: |-
    query {
      Movie1(func: uid(0x2)) @filter(type(Movie)) {
        uid
      }
    }
  qnametouid: |-
    {
      "Movie1":"0x2"
    }
  dgmutations:
    - setjson: |
        { "uid" : "_:MovieDirector2",
          "dgraph.type" : ["MovieDirector"],
          "MovieDirector.name" : "Steven Spielberg",
          "directed.movies": [{
            "uid" : "0x2"
          }]
        }

- name: "Top Level Duplicate XIDs with same object Test"
  gqlmutation: |
    mutation addState($input: [AddStateInput!]!) {
      addState(input: $input) {
        state {
          code
          name
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {"name": "State1", "code": "S1"},
        {"name": "State1", "code": "S1"}
      ]
    }
  explanation: "When duplicate XIDs are given as input at top level, but the object structure is
  same, it should return error."
  error:
    message: "failed to rewrite mutation payload because duplicate XID found: S1"

- name: "Top Level Duplicate XIDs with different object Test"
  gqlmutation: |
    mutation addState($input: [AddStateInput!]!) {
      addState(input: $input) {
        state {
          code
          name
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {"name": "State1", "code": "S1"},
        {"name": "State2", "code": "S1"}
      ]
    }
  explanation: "When duplicate XIDs are given as input at top level, but the object structure is
  different, it should still return error."
  error:
    message: "failed to rewrite mutation payload because duplicate XID found: S1"

- name: "Deep Mutation Duplicate XIDs with same object Test"
  gqlmutation: |
    mutation addCity($input: [AddCityInput!]!) {
      addCity(input: $input) {
        city {
          name
          district {
            code
            name
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "name": "Bengaluru",
          "district": {"code": "D1", "name": "Dist1"}
        },
        {
          "name": "NY",
          "district": {"code": "D1", "name": "Dist1"}
        },
        {
         "name": "Sydney",
         "district": {"code": "D1"}
        }
      ]
    }
  explanation: "When duplicate XIDs are given as input to deep mutation but the object structure
  is same or contains just xid, it should not return error."
  dgquery: |-
    query {
      District1(func: eq(District.code, "D1")) @filter(type(District)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "City.district":
            {
              "District.cities":
                [
                  {
                    "uid":"_:City2"
                  }
                ],
              "District.code":"D1",
              "District.name":"Dist1",
              "dgraph.type":["District"],
              "uid":"_:District1"
            },
          "City.name":"Bengaluru",
          "dgraph.type":["City"],
          "uid":"_:City2"
        }
    - setjson: |
        {
          "City.district":
            {
              "District.cities":
                [
                  {
                    "uid":"_:City3"
                  }
                ],
              "uid":"_:District1"
            },
          "City.name":"NY",
          "dgraph.type":["City"],
          "uid":"_:City3"
        }
    - setjson: |
        {
          "City.district":
            {
              "District.cities":
                [
                  {
                    "uid":"_:City4"
                  }
                ],
              "uid":"_:District1"
            },
          "City.name":"Sydney",
          "dgraph.type":["City"],
          "uid":"_:City4"
        }

- name: "Deep Mutation Duplicate XIDs with same object with @hasInverse Test"
  gqlmutation: |
    mutation addCountry($input: [AddCountryInput!]!) {
      addCountry(input: $input) {
        country {
          id
          name
          states {
            code
            name
            capital
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "name": "Country1",
          "states": [
            {"code": "S1", "name": "State1", "capital": "Cap1"},
            {"code": "S1", "name": "State1", "capital": "Cap1"}
          ]
        },
        {
          "name": "Country2",
          "states": [
            {"code": "S2", "name": "State2", "capital": "Cap2"}
          ]
        },
        {
          "name": "Country3",
          "states": [
            {"code": "S2", "name": "State2", "capital": "Cap2"}
          ]
        }
      ]
    }
  explanation: "When duplicate XIDs are given as input to deep mutation and the object structure
  is same and the containing object has @hasInverse on its xid object field, but the xid object
  does not have the @hasInverse field of List type, it should return error."
  error:
    message: |-
      failed to rewrite mutation payload because duplicate XID found: S1
      failed to rewrite mutation payload because duplicate XID found: S2

- name: "Deep Mutation Duplicate XIDs with different object Test"
  gqlmutation: |
    mutation addStudent($input: [AddStudentInput!]!) {
      addStudent(input: $input) {
        student {
          xid
          name
          taughtBy {
            xid
            name
            subject
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "xid": "S1",
          "name": "Stud1",
          "taughtBy": [
            {"xid": "T1", "name": "Teacher1", "subject": "Sub1"}
          ]
        },
        {
          "xid": "S2",
          "name": "Stud2",
          "taughtBy": [
            {"xid": "T1", "name": "Teacher1", "subject": "Sub2"}
          ]
        },
        {
          "xid": "S3",
          "name": "Stud3",
          "taughtBy": [
            {"xid": "T1", "name": "Teacher1"}
          ]
        }
      ]
    }
  explanation: "When duplicate XIDs are given as input to deep mutation but the object structure
  is different, it should return error."
  error:
    message: |-
      failed to rewrite mutation payload because duplicate XID found: T1
      failed to rewrite mutation payload because duplicate XID found: T1

- name: "Circular Duplicate XIDs in single mutation"
  gqlmutation: |
    mutation addStudent($input: [AddStudentInput!]!) {
      addStudent(input: $input) {
        student {
          xid
          name
          taughtBy {
            xid
            name
            subject
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "xid": "S1",
          "name": "Stud1",
          "taughtBy": [
            {"xid": "T1", "name": "Teacher1", "teaches": [{"xid": "S1", "name": "Stud1"}]}
          ]
        }
      ]
    }
  explanation: "When duplicate XIDs are given as input circularly in a single mutation, it
  should return error."
  error:
    message: |-
      failed to rewrite mutation payload because duplicate XID found: S1

- name: "Duplicate XIDs in single mutation for Interface"
  gqlmutation: |
    mutation addStudent($input: [AddStudentInput!]!) {
      addStudent(input: $input) {
        student {
          xid
          name
          taughtBy {
            xid
            name
            subject
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "xid": "S1",
          "name": "Stud1"
        },
        {
          "xid": "S2",
          "name": "Stud2",
          "taughtBy": [
            {"xid": "S1", "name": "Teacher1", "subject": "Sub1"}
          ]
        }
      ]
    }
  explanation: "When duplicate XIDs are given as input for an Interface in a single mutation, it
  should return error."
  error:
    message: |-
      failed to rewrite mutation payload because duplicate XID found: S1

# Additional Deletes
#
# If we have
#
# type Post { ... author: Author @hasInverse(field: posts) ... }
# type Author { ... posts: [Post] ... }
#
# and existing edge
#
# Post1 --- author --> Author1
#
# there must also exist edge
#
# Author1 --- posts --> Post1
#
# So if we did an add Author2 and connect the author to Post1, that changes the
# author of Post1 to Author2, we need to
#  * add edge Post1 --- author --> Author2 (done by asIDReference/asXIDReference)
#  * add edge Author2 --- posts --> Post1 (done by addInverseLink)
#  * delete edge Author1 --- posts --> Post1 (done by addAdditionalDeletes)
#
# This delete only needs to be done when there is a singular edge in the mutation:
# i.e. if both directions of the edge are [], then it's just an add.
#
# There's three cases to consider: add by ID, add by XID, deep add

- name: "Additional Deletes - Add connects to existing node by ID"
  gqlmutation: |
    mutation addAuthor($auth: AddAuthorInput!) {
      addAuthor(input: [$auth]) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    {
      "auth": {
        "name": "A.N. Author",
        "posts": [ { "postID": "0x456" }, {"title": "New Post", "author": {"name": "Abhimanyu"}} ]
      }
    }
  dgquery: |-
    query {
      Post1(func: uid(0x456)) @filter(type(Post)) {
        uid
      }
    }
  qnametouid: |-
    {
      "Post1": "0x456"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x456)) {
        Author3 as Post.author
      }
    }
  dgmutations:
    - setjson: |
        {
          "uid":"_:Author2",
          "dgraph.type":["Author"],
          "Author.name":"A.N. Author",
          "Author.posts": [
            {
              "uid": "0x456",
              "Post.author": { "uid": "_:Author2" }
            },
            {
              "uid": "_:Post4",
              "dgraph.type": ["Post"],
              "Post.title": "New Post",
              "Post.author": { "uid": "_:Author2" }
            }
          ]
        }
      deletejson: |
        [
          {
            "uid": "uid(Author3)",
            "Author.posts": [ { "uid": "0x456" } ]
          }
        ]

- name: "Additional Deletes - Add connects to existing node by XID"
  explanation: "One of the states exists. Country attached to that state is deleted."
  gqlmutation: |
    mutation addCountry($inp: AddCountryInput!) {
      addCountry(input: [$inp]) {
        country {
          id
        }
      }
    }
  gqlvariables: |
    {
      "inp": {
        "name": "A Country",
        "states": [
          { "code": "abc", "name": "Alphabet" },
          { "code": "def", "name": "Vowel", "country": { "name": "B country" } }
        ]
      }
    }
  dgquery: |-
    query {
      State1(func: eq(State.code, "abc")) @filter(type(State)) {
        uid
      }
      State2(func: eq(State.code, "def")) @filter(type(State)) {
        uid
      }
    }
  qnametouid: |-
    {
      "State1": "0x1234"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x1234)) {
        Country4 as State.country
      }
    }
  dgmutations:
    - setjson: |
        {
          "Country.name":"A Country",
          "Country.states":
            [
              {
                "State.country":
                  {
                    "uid":"_:Country3"
                  },
                "uid":"0x1234"
              },
              {
                "State.code":"def",
                "State.country":
                  {
                    "uid":"_:Country3"
                  },
                "State.name":"Vowel",
                "dgraph.type":["State"],
                "uid":"_:State2"
              }
            ],
          "dgraph.type":["Country"],
          "uid":"_:Country3"
        }
      deletejson: |
        [
          {
            "uid":"uid(Country4)",
            "Country.states":
              [
                {"uid":"0x1234"}
              ]
          }
        ]

- name: "Deep XID 4 level deep 1"
  explanation: "No nodes exist. All nodes are created."
  gqlmutation: |
    mutation addStudent($student: AddStudentInput!) {
      addStudent(input: [$student]) {
        student {
          name
        }
      }
    }
  gqlvariables: |
    {
      "student": {
        "xid": "S0",
        "name": "Student0",
        "taughtBy": [{
                "xid": "T0",
                "name": "teacher0",
                "teaches": [{
                        "xid": "S1",
                        "name": "Student1",
                        "taughtBy": [{
                                "xid": "T1",
                                "name": "teacher1"
                        }]
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Student1(func: eq(People.xid, "S0")) @filter(type(Student)) {
        uid
      }
      Teacher2(func: eq(People.xid, "T0")) @filter(type(Teacher)) {
        uid
      }
      Student3(func: eq(People.xid, "S1")) @filter(type(Student)) {
        uid
      }
      Teacher4(func: eq(People.xid, "T1")) @filter(type(Teacher)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "People.name":"Student0",
          "People.xid":"S0",
          "Student.taughtBy":
            [
              {
                "People.name":"teacher0",
                "People.xid":"T0",
                "Teacher.teaches":
                  [
                    {
                      "uid":"_:Student1"
                    },
                    {
                      "People.name":"Student1",
                      "People.xid":"S1",
                      "Student.taughtBy":
                        [
                          {
                            "uid":"_:Teacher2"
                          },
                          {
                            "People.name":"teacher1",
                            "People.xid":"T1",
                            "Teacher.teaches":
                              [
                                {
                                  "uid":"_:Student3"
                                }
                              ],
                            "dgraph.type":["Teacher","People"],
                            "uid":"_:Teacher4"
                          }
                        ],
                      "dgraph.type":["Student","People"],
                      "uid":"_:Student3"
                    }
                  ],
                "dgraph.type":["Teacher","People"],
                "uid":"_:Teacher2"
              }
            ],
          "dgraph.type":["Student","People"],
          "uid":"_:Student1"
        }

- name: "Deep XID 4 level deep 2"
  explanation: "Teacher T1 also teaches the newly added student at top level, S0."
  gqlmutation: |
    mutation addStudent($student: AddStudentInput!) {
      addStudent(input: [$student]) {
        student {
          name
        }
      }
    }
  gqlvariables: |
    {
      "student": {
        "xid": "S0",
        "name": "Student0",
        "taughtBy": [{
                "xid": "T0",
                "name": "teacher0",
                "teaches": [{
                        "xid": "S1",
                        "name": "Student1",
                        "taughtBy": [{
                                "xid": "T1",
                                "name": "teacher1",
                                "teaches": [{
                                      "xid": "S0"
                                }]
                        }]
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Student1(func: eq(People.xid, "S0")) @filter(type(Student)) {
        uid
      }
      Teacher2(func: eq(People.xid, "T0")) @filter(type(Teacher)) {
        uid
      }
      Student3(func: eq(People.xid, "S1")) @filter(type(Student)) {
        uid
      }
      Teacher4(func: eq(People.xid, "T1")) @filter(type(Teacher)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "People.name":"Student0",
          "People.xid":"S0",
          "Student.taughtBy":
            [
              {
                "People.name":"teacher0",
                "People.xid":"T0",
                "Teacher.teaches":
                  [
                    {
                      "uid":"_:Student1"
                    },
                    {
                      "People.name":"Student1",
                      "People.xid":"S1",
                      "Student.taughtBy":
                        [
                          {
                            "uid":"_:Teacher2"
                          },
                          {
                            "People.name":"teacher1",
                            "People.xid":"T1",
                            "Teacher.teaches":
                              [
                                {
                                  "uid":"_:Student3"
                                },
                                {
                                  "uid":"_:Student1",
                                  "Student.taughtBy":
                                    [
                                      {
                                        "uid":"_:Teacher4"
                                      }
                                    ]
                                }
                              ],
                            "dgraph.type":["Teacher","People"],
                            "uid":"_:Teacher4"
                          }
                        ],
                      "dgraph.type":["Student","People"],
                      "uid":"_:Student3"
                    }
                  ],
                "dgraph.type":["Teacher","People"],
                "uid":"_:Teacher2"
              }
            ],
          "dgraph.type":["Student","People"],
          "uid":"_:Student1"
        }

- name: "Deep XID Add top level hasInverse 1"
  explanation: "No nodes exists. All are created."
  gqlmutation: |
    mutation addStudent($student: AddStudentInput!) {
      addStudent(input: [$student]) {
        student {
          name
        }
      }
    }
  gqlvariables: |
    {
      "student": {
        "xid": "S0",
        "name": "Student0",
        "taughtBy": [{
                "xid": "T0",
                "name": "teacher0",
                "teaches": [{
                        "xid": "S1",
                        "name": "Student1"
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Student1(func: eq(People.xid, "S0")) @filter(type(Student)) {
        uid
      }
      Teacher2(func: eq(People.xid, "T0")) @filter(type(Teacher)) {
        uid
      }
      Student3(func: eq(People.xid, "S1")) @filter(type(Student)) {
        uid
      }
    }

  dgmutations:
    - setjson: |
        {
          "People.name":"Student0",
          "People.xid":"S0",
          "Student.taughtBy":
            [
              {
                "People.name":"teacher0",
                "People.xid":"T0",
                "Teacher.teaches":
                  [
                    {
                      "uid":"_:Student1"
                    },
                    {
                      "People.name":"Student1",
                      "People.xid":"S1",
                      "Student.taughtBy":
                        [
                          {
                            "uid":"_:Teacher2"
                          }
                        ],
                      "dgraph.type":["Student","People"],
                      "uid":"_:Student3"
                    }
                  ],
                "dgraph.type":["Teacher","People"],
                "uid":"_:Teacher2"
              }
            ],
          "dgraph.type":["Student","People"],
          "uid":"_:Student1"
        }

- name: "Deep XID Add top level hasInverse 2"
  explanation: "Teacher T0 exists and is linked to Student S0"
  gqlmutation: |
    mutation addStudent($student: AddStudentInput!) {
      addStudent(input: [$student]) {
        student {
          name
        }
      }
    }
  gqlvariables: |
    {
      "student": {
        "xid": "S0",
        "name": "Student0",
        "taughtBy": [{
                "xid": "T0",
                "name": "teacher0",
                "teaches": [{
                        "xid": "S1",
                        "name": "Student1"
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Student1(func: eq(People.xid, "S0")) @filter(type(Student)) {
        uid
      }
      Teacher2(func: eq(People.xid, "T0")) @filter(type(Teacher)) {
        uid
      }
      Student3(func: eq(People.xid, "S1")) @filter(type(Student)) {
        uid
      }
    }
  qnametouid: |
    {
      "Teacher2": "0x987"
    }
  dgmutations:
    - setjson: |
        {
          "People.name":"Student0",
          "People.xid":"S0",
          "Student.taughtBy":
            [
              {
                "Teacher.teaches":
                  [
                    {
                      "uid":"_:Student1"
                    }
                  ],
                "uid":"0x987"
              }
            ],
          "dgraph.type":["Student","People"],
          "uid":"_:Student1"
        }

- name: "Deep XID Add top level hasInverse 3"
  explanation: "Student S1 exists and is linked to Teacher T0."
  gqlmutation: |
    mutation addStudent($student: AddStudentInput!) {
      addStudent(input: [$student]) {
        student {
          name
        }
      }
    }
  gqlvariables: |
    {
      "student": {
        "xid": "S0",
        "name": "Student0",
        "taughtBy": [{
                "xid": "T0",
                "name": "teacher0",
                "teaches": [{
                        "xid": "S1",
                        "name": "Student1"
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Student1(func: eq(People.xid, "S0")) @filter(type(Student)) {
        uid
      }
      Teacher2(func: eq(People.xid, "T0")) @filter(type(Teacher)) {
        uid
      }
      Student3(func: eq(People.xid, "S1")) @filter(type(Student)) {
        uid
      }
    }
  qnametouid: |
    {
      "Student3": "0x123"
    }
  dgmutations:
    - setjson: |
        {
          "People.name":"Student0",
          "People.xid":"S0",
          "Student.taughtBy":
            [
              {
                "People.name":"teacher0",
                "People.xid":"T0",
                "Teacher.teaches":
                  [
                    {
                      "uid":"_:Student1"
                    },
                    {
                      "Student.taughtBy":
                        [
                          {
                            "uid":"_:Teacher2"
                          }
                        ],
                      "uid":"0x123"
                    }
                  ],
                "dgraph.type":["Teacher","People"],
                "uid":"_:Teacher2"
              }
            ],
          "dgraph.type":["Student","People"],
          "uid":"_:Student1"
        }


- name: "Deep XID Add lower level hasInvsere 1"
  explanation: "None of the nodes exists. All of them are created."
  gqlmutation: |
    mutation addLab($lab: AddLabInput!) {
      addLab(input: [$lab]) {
        lab {
          name
        }
      }
    }
  gqlvariables: |
    {
      "lab": {
        "name": "Lab1",
        "computers": [{
                "name": "computer1",
                "owners": [{
                        "name": "owner1"
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Lab1(func: eq(Lab.name, "Lab1")) @filter(type(Lab)) {
        uid
      }
      Computer2(func: eq(Computer.name, "computer1")) @filter(type(Computer)) {
        uid
      }
      ComputerOwner3(func: eq(ComputerOwner.name, "owner1")) @filter(type(ComputerOwner)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "Lab.computers":
            [
              {
                "Computer.name":"computer1",
                "Computer.owners":
                  [
                    {
                      "ComputerOwner.computers":
                        {
                          "uid":"_:Computer2"
                        },
                      "ComputerOwner.name":"owner1",
                      "dgraph.type":["ComputerOwner"],
                      "uid":"_:ComputerOwner3"
                    }
                  ],
                "dgraph.type":["Computer"],
                "uid":"_:Computer2"
              }
            ],
          "Lab.name":"Lab1",
          "dgraph.type":["Lab"],
          "uid":"_:Lab1"
        }

- name: "Deep XID Add lower level hasInvsere 2"
  explanation: "computer exists. Computer node is linked to Lab."
  gqlmutation: |
    mutation addLab($lab: AddLabInput!) {
      addLab(input: [$lab]) {
        lab {
          name
        }
      }
    }
  gqlvariables: |
    {
      "lab": {
        "name": "Lab1",
        "computers": [{
                "name": "computer1",
                "owners": [{
                        "name": "owner1"
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Lab1(func: eq(Lab.name, "Lab1")) @filter(type(Lab)) {
        uid
      }
      Computer2(func: eq(Computer.name, "computer1")) @filter(type(Computer)) {
        uid
      }
      ComputerOwner3(func: eq(ComputerOwner.name, "owner1")) @filter(type(ComputerOwner)) {
        uid
      }
    }
  qnametouid: |
    {
      "Computer2": "0x234"
    }
  dgmutations:
    - setjson: |
        {
          "Lab.computers":
            [
              {
                "uid":"0x234"
              }
            ],
          "Lab.name":"Lab1",
          "dgraph.type":["Lab"],
          "uid":"_:Lab1"
        }

- name: "Deep XID Add lower level hasInvsere 3"
  explanation: "Computer Owner exists and is linked to computer."
  gqlmutation: |
    mutation addLab($lab: AddLabInput!) {
      addLab(input: [$lab]) {
        lab {
          name
        }
      }
    }
  gqlvariables: |
    {
      "lab": {
        "name": "Lab1",
        "computers": [{
                "name": "computer1",
                "owners": [{
                        "name": "owner1"
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Lab1(func: eq(Lab.name, "Lab1")) @filter(type(Lab)) {
        uid
      }
      Computer2(func: eq(Computer.name, "computer1")) @filter(type(Computer)) {
        uid
      }
      ComputerOwner3(func: eq(ComputerOwner.name, "owner1")) @filter(type(ComputerOwner)) {
        uid
      }
    }
  qnametouid: |
    {
      "ComputerOwner3": "0x123"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x123)) {
        Computer4 as ComputerOwner.computers
      }
    }
  dgmutations:
    - setjson: |
        {
          "Lab.computers":
            [
              {
                "Computer.name":"computer1",
                "Computer.owners":
                  [
                    {
                      "ComputerOwner.computers":
                        {
                          "uid":"_:Computer2"
                        },
                      "uid":"0x123"
                    }
                  ],
                "dgraph.type":["Computer"],
                "uid":"_:Computer2"
              }
            ],
          "Lab.name":"Lab1",
          "dgraph.type":["Lab"],
          "uid":"_:Lab1"
        }
      deletejson: |-
        [{
            "Computer.owners": [
                {
                    "uid": "0x123"
                }
            ],
            "uid": "uid(Computer4)"
        }]

- name: "Deep mutation alternate id xid"
  gqlmutation: |
    mutation addAuthor($city: AddCityInput!) {
      addCity(input: [$city]) {
        city {
          name
          district {
            code
            name
            cities {
              name
              district {
                code
                name
              }
            }
          }
        }
      }
    }
  gqlvariables: |
    {
      "city": {
        "name": "c1",
        "district":{
                "name":"d1",
                "code":"d1",
                "cities":[{"name": "c2"}]
        }
      }
    }
  dgquery: |-
    query {
      District1(func: eq(District.code, "d1")) @filter(type(District)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "City.district":
            {
              "District.cities":
                [
                  {
                    "uid":"_:City2"
                  },
                  {
                    "City.district":
                      {
                        "uid":"_:District1"
                      },
                      "City.name":"c2",
                      "dgraph.type":["City"],
                      "uid":"_:City3"
                  }
                ],
              "District.code":"d1",
              "District.name":"d1",
              "dgraph.type":["District"],
              "uid":"_:District1"
            },
          "City.name":"c1",
          "dgraph.type":["City"],
          "uid":"_:City2"
        }

- name: "Deep mutation alternate id xid with existing XID"
  gqlmutation: |
    mutation addAuthor($city: AddCityInput!) {
      addCity(input: [$city]) {
        city {
          name
          district {
            code
            name
            cities {
              name
              district {
                code
                name
              }
            }
          }
        }
      }
    }
  gqlvariables: |
    {
      "city": {
        "name": "c1",
        "district":{
                "name":"d1",
                "code":"d1",
                "cities":[{"name": "c2"}]
        }
      }
    }
  dgquery: |-
    query {
      District1(func: eq(District.code, "d1")) @filter(type(District)) {
        uid
      }
    }
  qnametouid: |-
    {
      "District1": "0x123"
    }
  dgmutations:
    - setjson: |
        {
          "City.district":
            {
              "District.cities":
                [
                  {
                    "uid":"_:City2"
                  }
                ],
              "uid":"0x123"
            },
          "City.name":"c1",
          "dgraph.type":["City"],
          "uid":"_:City2"
        }


- name: "Additional Deletes - deep mutation"
  gqlmutation: |
    mutation addAuthor($auth: AddAuthorInput!) {
      addAuthor(input: [$auth]) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    {
      "auth": {
        "name": "A.N. Author",
        "country": {
          "name": "A Country",
          "states": [ { "code": "abc", "name": "Alphabet" } ]
        }
      }
    }
  dgquery: |-
    query {
      State1(func: eq(State.code, "abc")) @filter(type(State)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "Author.country":
            {
              "Country.name":"A Country",
              "Country.states":
                [
                  {
                    "State.code":"abc",
                    "State.country": {"uid":"_:Country3"},
                    "State.name":"Alphabet",
                    "dgraph.type":["State"],
                    "uid":"_:State1"
                  }
                ],
              "dgraph.type":["Country"],
              "uid":"_:Country3"
            },
          "Author.name":"A.N. Author",
          "dgraph.type":["Author"],
          "uid":"_:Author2"
        }

- name: "Deep mutation three level xid with no initial XID"
  gqlmutation: |
    mutation($auth: [AddPost1Input!]!) {
      addPost1(input: $auth) {
        post1 {
          id
          comments {
            id
            replies {
              id
            }
          }
        }
      }
    }

  gqlvariables: |
    {
      "auth": [{
        "id": "post1",
        "comments": [{
          "id": "comment1",
          "replies": [{
            "id": "reply1"
          }]
        }]
      },
      {
        "id": "post2",
        "comments": [{
          "id": "comment2",
          "replies": [{
            "id": "reply1"
          }]
        }]
      }]
    }
  dgquery: |-
    query {
      Post11(func: eq(Post1.id, "post1")) @filter(type(Post1)) {
        uid
      }
      Comment12(func: eq(Comment1.id, "comment1")) @filter(type(Comment1)) {
        uid
      }
      Comment13(func: eq(Comment1.id, "reply1")) @filter(type(Comment1)) {
        uid
      }
      Post14(func: eq(Post1.id, "post2")) @filter(type(Post1)) {
        uid
      }
      Comment15(func: eq(Comment1.id, "comment2")) @filter(type(Comment1)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "Post1.comments":
            [
              {
                "Comment1.id": "comment1",
                "Comment1.replies":
                  [
                    {
                     "Comment1.id":"reply1",
                     "dgraph.type": ["Comment1"],
                     "uid":"_:Comment13"
                    }
                  ],
                "dgraph.type":["Comment1"],
                "uid":"_:Comment12"
              }
            ],
          "Post1.id":"post1",
          "dgraph.type":["Post1"],
          "uid":"_:Post11"
        }
    - setjson: |
        {
          "Post1.comments":
            [
              {
                "Comment1.id":"comment2",
                "Comment1.replies":
                  [
                    {
                      "uid":"_:Comment13"
                    }
                  ],
                "dgraph.type":["Comment1"],
                "uid":"_:Comment15"
              }
            ],
          "Post1.id":"post2",
          "dgraph.type":["Post1"],
          "uid":"_:Post14"
        }

- name: "Deep mutation three level xid with existing XIDs 1"
  explanation: "reply1 and comment1 exists and is not created"
  gqlmutation: |
    mutation($auth: [AddPost1Input!]!) {
      addPost1(input: $auth) {
        post1 {
          id
          comments {
            id
            replies {
              id
            }
          }
        }
      }
    }

  gqlvariables: |
    {
      "auth": [{
        "id": "post1",
        "comments": [{
          "id": "comment1",
          "replies": [{
            "id": "reply1"
          }]
        }]
      },
      {
        "id": "post2",
        "comments": [{
          "id": "comment2",
          "replies": [{
            "id": "reply1"
          }]
        }]
      }]
    }
  dgquery: |-
    query {
      Post11(func: eq(Post1.id, "post1")) @filter(type(Post1)) {
        uid
      }
      Comment12(func: eq(Comment1.id, "comment1")) @filter(type(Comment1)) {
        uid
      }
      Comment13(func: eq(Comment1.id, "reply1")) @filter(type(Comment1)) {
        uid
      }
      Post14(func: eq(Post1.id, "post2")) @filter(type(Post1)) {
        uid
      }
      Comment15(func: eq(Comment1.id, "comment2")) @filter(type(Comment1)) {
        uid
      }
    }
  qnametouid: |
    {
      "Comment12": "0x110",
      "Comment13": "0x111"
    }
  dgmutations:
    - setjson: |
        {
          "Post1.comments":
            [
              {
                "uid":"0x110"
              }
            ],
          "Post1.id":"post1",
          "dgraph.type":["Post1"],
          "uid":"_:Post11"
        }
    - setjson: |
        {
          "Post1.comments":
            [
              {
                "Comment1.id":"comment2",
                "Comment1.replies":
                  [
                    {
                      "uid":"0x111"
                    }
                  ],
                "dgraph.type":["Comment1"],
                "uid":"_:Comment15"
              }
            ],
          "Post1.id":"post2",
          "dgraph.type":["Post1"],
          "uid":"_:Post14"
        }

- name: "Deep mutation three level xid with existing XIDs 2"
  explanation: "comment2 and comment1 exists. reply1 does not exist. reply1 is not created as its parent exists."
  gqlmutation: |
    mutation($auth: [AddPost1Input!]!) {
      addPost1(input: $auth) {
        post1 {
          id
          comments {
            id
            replies {
              id
            }
          }
        }
      }
    }

  gqlvariables: |
    {
      "auth": [{
        "id": "post1",
        "comments": [{
          "id": "comment1",
          "replies": [{
            "id": "reply1"
          }]
        }]
      },
      {
        "id": "post2",
        "comments": [{
          "id": "comment2",
          "replies": [{
            "id": "reply1"
          }]
        }]
      }]
    }
  dgquery: |-
    query {
      Post11(func: eq(Post1.id, "post1")) @filter(type(Post1)) {
        uid
      }
      Comment12(func: eq(Comment1.id, "comment1")) @filter(type(Comment1)) {
        uid
      }
      Comment13(func: eq(Comment1.id, "reply1")) @filter(type(Comment1)) {
        uid
      }
      Post14(func: eq(Post1.id, "post2")) @filter(type(Post1)) {
        uid
      }
      Comment15(func: eq(Comment1.id, "comment2")) @filter(type(Comment1)) {
        uid
      }
    }
  qnametouid: |
    {
      "Comment12": "0x110",
      "Comment15": "0x111"
    }
  dgmutations:
    - setjson: |
        {
          "Post1.comments":
            [
              {
                "uid":"0x110"
              }
            ],
          "Post1.id":"post1",
          "dgraph.type":["Post1"],
          "uid":"_:Post11"
        }
    - setjson: |
        {
          "Post1.comments":
            [
              {
                "uid":"0x111"
              }
            ],
          "Post1.id":"post2",
          "dgraph.type":["Post1"],
          "uid":"_:Post14"
        }

-
  name: "Add mutation error on @id field for empty value"
  gqlmutation: |
    mutation addState($input: AddStateInput!) {
      addState(input: [$input]) {
        state {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "code": "",
        "name": "NSW",
        "country": { "id": "0x12" }
      }
    }
  explanation: "The add mutation should not be allowed since value of @id field is empty."
  error:
    { "message": "failed to rewrite mutation payload because encountered an empty value for @id field `State.code`" }

-
  name: "Add mutation error on @id field for empty value (Nested)"
  gqlmutation: |
    mutation addCountry($input: AddCountryInput!) {
      addCountry(input: [$input]) {
        country {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "name": "Dgraph Land",
        "states": [ {
          "code": "",
          "name": "Dgraph"
        } ]
      }
    }
  explanation: "The add mutation should not be allowed since value of @id field is empty."
  error:
    { "message": "failed to rewrite mutation payload because encountered an empty value for @id field `State.code`" }

-
  name: "Add mutation for person with @hasInverse"
  gqlmutation: |
    mutation($input: [AddPersonInput!]!) {
      addPerson(input: $input) {
        person {
          name
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "name": "Or",
          "friends": [
            { "name": "Michal", "friends": [{ "name": "Justin" }] }
          ]
        }
      ]
    }
  dgmutations:
    - setjson: |
        {
          "Person.friends": [
            {
              "Person.friends": [
                {
                  "uid": "_:Person1"
                },
                {
                  "Person.friends": [
                    {
                      "uid": "_:Person2"
                    }
                  ],
                  "Person.name": "Justin",
                  "dgraph.type": [
                    "Person"
                  ],
                  "uid": "_:Person3"
                }
              ],
              "Person.name": "Michal",
              "dgraph.type": [
                "Person"
              ],
              "uid": "_:Person2"
            }
          ],
          "Person.name": "Or",
          "dgraph.type": [
            "Person"
          ],
          "uid": "_:Person1"
        }

-
  name: "Add mutation with union"
  gqlmutation: |
    mutation($input: [AddHomeInput!]!) {
      addHome(input: $input) {
        home {
          address
          members {
            ... on Dog {
              breed
            }
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "address": "United Street",
          "members": [
            { "dogRef": { "category": "Mammal", "breed": "German Shephard"} },
            { "parrotRef": { "category": "Bird", "repeatsWords": ["squawk"]} },
            { "humanRef": { "name": "Han Solo", "ename": "Han_emp"} }
          ],
          "favouriteMember": { "parrotRef": { "id": "0x123"} }
        }
      ]
    }
  qnametouid: |-
    {
      "Parrot1" : "0x123"
    }
  dgquery: |-
    query {
      Parrot1(func: uid(0x123)) @filter(type(Parrot)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "Home.address": "United Street",
          "Home.favouriteMember": {
            "uid": "0x123"
          },
          "Home.members": [{
            "Animal.category": "Mammal",
            "Dog.breed": "German Shephard",
            "dgraph.type": ["Dog", "Animal"],
            "uid": "_:Dog3"
          }, {
            "Animal.category": "Bird",
            "Parrot.repeatsWords": ["squawk"],
            "dgraph.type": ["Parrot", "Animal"],
            "uid": "_:Parrot4"
          }, {
            "Character.name": "Han Solo",
            "Employee.ename": "Han_emp",
            "dgraph.type": ["Human", "Character", "Employee"],
            "uid": "_:Human5"
          }],
          "dgraph.type": ["Home"],
          "uid": "_:Home2"
        }

-
  name: "Add mutation with union - invalid input"
  gqlmutation: |
    mutation($input: [AddHomeInput!]!) {
      addHome(input: $input) {
        home {
          address
          members {
            ... on Dog {
              breed
            }
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "address": "United Street",
          "members": [
            { "dogRef": { "category": "Mammal"}, "parrotRef": { "category": "Bird"} },
            { "parrotRef": { "category": "Bird", "repeatsWords": ["squawk"]} },
            { "humanRef": { "name": "Han Solo", "ename": "Han_emp"} }
          ],
          "favouriteMember": { }
        }
      ]
    }
  explanation: "The add mutation should not be allowed since the union input is invalid"
  error:
    message: |-
      failed to rewrite mutation payload because value for field `favouriteMember` in type `Home` must have exactly one child, found 0 children
      failed to rewrite mutation payload because value for field `members` in type `Home` index `0` must have exactly one child, found 2 children

-
  name: "Add type with multiple Xid fields"
  gqlmutation: |
    mutation($input: [AddBookInput!]!) {
    	addBook(input: $input) {
    		book {
    			title
    			ISBN
    			author {
    				name
    			}
    		}
    	}
    }

  gqlvariables: |
    {
        "input": [
            {
                "title": "Sapiens",
                "ISBN": "2312SB",
                "author": {
                    "name": "Yuval Noah Harari"
                }
            }
        ]
    }
  dgquery: |-
    query {
      Book1(func: eq(Book.ISBN, "2312SB")) @filter(type(Book)) {
        uid
      }
      Book2(func: eq(Book.title, "Sapiens")) @filter(type(Book)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
            "Book.author": {
                "author.name": "Yuval Noah Harari",
                "author.book": [
                    {
                        "uid": "_:Book2"
                    }
                ],
                "dgraph.type": [
                    "author"
                ],
                "uid": "_:author3"
            },
            "Book.ISBN": "2312SB",
            "Book.title": "Sapiens",
            "dgraph.type": [
                "Book"
            ],
            "uid": "_:Book2"
        }

-
  name: "Add type with multiple Xid fields at deep level"
  gqlmutation: |
    mutation($input: [AddauthorInput!]!) {
    	addauthor(input: $input) {
    		author {
    			name
    			book {
    				title
    				ISBN
    			}
    		}
    	}
    }

  gqlvariables: |
    {
        "input": [
            {
                "name": "Yuval Noah Harari",
                "book": {
                    "title": "Sapiens",
                    "ISBN": "2312SB"
                }
            }
        ]
    }
  dgquery: |-
    query {
      Book1(func: eq(Book.ISBN, "2312SB")) @filter(type(Book)) {
        uid
      }
      Book2(func: eq(Book.title, "Sapiens")) @filter(type(Book)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
            "author.name": "Yuval Noah Harari",
            "dgraph.type": [
                "author"
            ],
            "uid": "_:author3",
            "author.book": [
                {
                    "Book.ISBN": "2312SB",
                    "Book.title": "Sapiens",
                    "Book.author": {
                        "uid": "_:author3"
                    },
                    "dgraph.type": [
                        "Book"
                    ],
                    "uid": "_:Book2"
                }
            ]
        }

-
  name: "Add mutation for type Person1 with multiple xids referencing same node as closeFriends and friends, closeFriends refer friends with xid id"
  explanation: "The mutation adds same node as friends and closeFriends. It should
    work irrespective of the order in which the node is referenced."
  gqlmutation: |
    mutation($input: [AddPerson1Input!]!) {
      addPerson1(input: $input) {
        person1 {
          id
          name
          friends {
            id
            name
          }
          closeFriends {
            id
            name
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "id": "1",
          "name": "First Person",
          "friends": [{
            "id": "2",
            "name": "Second Person"
           }],
          "closeFriends": [{
            "id": "2"
           }]
        }
      ]
    }
  dgquery: |-
    query {
      Person11(func: eq(Person1.id, "1")) @filter(type(Person1)) {
        uid
      }
      Person12(func: eq(Person1.name, "First Person")) @filter(type(Person1)) {
        uid
      }
      Person13(func: eq(Person1.id, "2")) @filter(type(Person1)) {
        uid
      }
      Person14(func: eq(Person1.name, "Second Person")) @filter(type(Person1)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "Person1.closeFriends": [
            {
              "Person1.closeFriends": [
                {
                  "uid": "_:Person12"
                }
              ],
              "Person1.name": "Second Person",
              "Person1.id": "2",
              "dgraph.type": [
                "Person1"
              ],
              "uid": "_:Person14"
            }
          ],
          "Person1.friends": [
            {
              "uid": "_:Person14",
              "Person1.friends": [
                {
                  "uid": "_:Person12"
                }
              ]
            }
          ],
          "Person1.name": "First Person",
          "Person1.id": "1",
          "dgraph.type": [
            "Person1"
          ],
          "uid": "_:Person12"
        }

-
  name: "Add type with multiple Xids fields at deep level when deep node already exist for all existence queries"
  gqlmutation: |
    mutation($input: [AddauthorInput!]!) {
    	addauthor(input: $input) {
    		author {
    			name
    			book {
    				title
    				ISBN
    			}
    		}
    	}
    }

  gqlvariables: |
    {
        "input": [
            {
                "name": "Yuval Noah Harari",
                "book": {
                    "title": "Sapiens",
                    "ISBN": "2312SB"
                }
            }
        ]
    }
  dgquery: |-
    query {
      Book1(func: eq(Book.ISBN, "2312SB")) @filter(type(Book)) {
        uid
      }
      Book2(func: eq(Book.title, "Sapiens")) @filter(type(Book)) {
        uid
      }
    }
  dgquerysec: |-
    query {
      var(func: uid(0x117)) {
        author4 as Book.author
      }
    }
  qnametouid: |
    {
      "Book1": "0x117",
      "Book2": "0x116"
    }
  dgmutations:
    - setjson: |
        {
            "author.name": "Yuval Noah Harari",
            "dgraph.type": [
                "author"
            ],
            "uid": "_:author3",
            "author.book": [
                {
                    "Book.author": {
                        "uid": "_:author3"
                    },
                    "uid": "0x117"
                }
            ]
        }
      deletejson: |
        [
            {
                "author.book": [
                    {
                        "uid": "0x117"
                    }
                ],
                "uid": "uid(author4)"
            }
        ]

-
  name: "Add type with multiple Xids fields at deep level when deep node already exist for one existence query"
  gqlmutation: |
    mutation($input: [AddauthorInput!]!) {
    	addauthor(input: $input) {
    		author {
    			name
    			book {
    				title
    				ISBN
    			}
    		}
    	}
    }

  gqlvariables: |
    {
        "input": [
            {
                "name": "Yuval Noah Harari",
                "book": {
                    "title": "Sapiens",
                    "ISBN": "2312SB"
                }
            }
        ]
    }
  dgquery: |-
    query {
      Book1(func: eq(Book.ISBN, "2312SB")) @filter(type(Book)) {
        uid
      }
      Book2(func: eq(Book.title, "Sapiens")) @filter(type(Book)) {
        uid
      }
    }
  dgquerysec: |-
    query {
      var(func: uid(0x119)) {
        author4 as Book.author
      }
    }
  qnametouid: |
    {
      "Book2": "0x119"
    }
  dgmutations:
    - setjson: |
        {
            "author.name": "Yuval Noah Harari",
            "dgraph.type": [
                "author"
            ],
            "uid": "_:author3",
            "author.book": [
                {
                    "Book.author": {
                        "uid": "_:author3"
                    },
                    "uid": "0x119"
                }
            ]
        }
      deletejson: |
        [
            {
                "author.book": [
                    {
                        "uid": "0x119"
                    }
                ],
                "uid": "uid(author4)"
            }
        ]

-
  name: "Add mutation for type Person1 with multiple xids referencing same node as closeFriends and friends, friends refer closeFriends with xid name "
  explanation: "The mutation adds same node as friends and closeFriends. It should
    work irrespective of the order in which the node is referenced."
  gqlmutation: |
    mutation($input: [AddPerson1Input!]!) {
      addPerson1(input: $input) {
        person1 {
          id
          name
          friends {
            id
            name
          }
          closeFriends {
            id
            name
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "id": "1",
          "name": "First Person",
          "closeFriends": [{
            "id": "2",
            "name": "Second Person"
           }],
          "friends": [{
            "name": "Second Person"
           }]
        }
      ]
    }
  dgquery: |-
    query {
      Person11(func: eq(Person1.id, "1")) @filter(type(Person1)) {
        uid
      }
      Person12(func: eq(Person1.name, "First Person")) @filter(type(Person1)) {
        uid
      }
      Person13(func: eq(Person1.id, "2")) @filter(type(Person1)) {
        uid
      }
      Person14(func: eq(Person1.name, "Second Person")) @filter(type(Person1)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
            "Person1.closeFriends": [
                {
                    "Person1.closeFriends": [
                        {
                            "uid": "_:Person12"
                        }
                    ],
                    "Person1.id": "2",
                    "Person1.name": "Second Person",
                    "dgraph.type": [
                        "Person1"
                    ],
                    "uid": "_:Person14"
                }
            ],
            "Person1.friends": [
                {
                    "Person1.friends": [
                        {
                            "uid": "_:Person12"
                        }
                    ],
                    "uid": "_:Person14"
                }
            ],
            "Person1.id": "1",
            "Person1.name": "First Person",
            "dgraph.type": [
                "Person1"
            ],
            "uid": "_:Person12"
        }