-
  name: "Add mutation geo field - Point type"
  gqlmutation: |
    mutation addHotel($hotel: AddHotelInput!) {
      addHotel(input: [$hotel]) {
        hotel {
          name
          location {
            latitude
            longitude
          }
        }
      }
    }
  gqlvariables: |
    { "hotel":
      { "name": "Taj Hotel",
        "location": { "latitude": 11.11 , "longitude" : 22.22}
      }
    }
  qnametouid: |
  explanation: "Add mutation should convert the Point type mutation to corresponding Dgraph JSON mutation"
  dgmutations:
    - setjson: |
        { "uid":"_:Hotel_1",
          "dgraph.type":["Hotel"],
          "Hotel.name":"Taj Hotel",
          "Hotel.location": {
            "type": "Point",
            "coordinates": [22.22, 11.11]
          }
        }

-
  name: "Add mutation geo field - Polygon type"
  gqlmutation: |
    mutation addHotel($hotel: AddHotelInput!) {
      addHotel(input: [$hotel]) {
        hotel {
          name
          area {
            coordinates {
              points {
                latitude
                longitude
              }
            }
          }
        }
      }
    }
  gqlvariables: |
    { "hotel":
      { "name": "Taj Hotel",
        "area": {
          "coordinates": [{
            "points": [{
              "latitude": 11.11,
              "longitude": 22.22
            }, {
              "latitude": 15.15,
              "longitude": 16.16
            }, {
              "latitude": 20.20,
              "longitude": 21.21
            }]
          }, {
              "points": [{
                "latitude": 11.18,
                "longitude": 22.28
              }, {
                "latitude": 15.18,
                "longitude": 16.18
              }, {
                "latitude": 20.28,
                "longitude": 21.28
              }]
          }]
        }
      }
    }
  explanation: "Add mutation should convert the Polygon type mutation to corresponding Dgraph JSON mutation"
  dgmutations:
    - setjson: |
        {
          "uid":"_:Hotel_1",
          "dgraph.type":["Hotel"],
          "Hotel.name":"Taj Hotel",
          "Hotel.area": {
            "type": "Polygon",
            "coordinates": [[[22.22,11.11],[16.16,15.15],[21.21,20.2]],[[22.28,11.18],[16.18,15.18],[21.28,20.28]]]
          }
        }

-
  name: "Add mutation geo field - MultiPolygon type"
  gqlmutation: |
    mutation addHotel($hotel: AddHotelInput!) {
      addHotel(input: [$hotel]) {
        hotel {
          name
          branches {
            polygons {
              coordinates {
                points {
                  latitude
                  longitude
                }
              }
            }
          }
        }
      }
    }
  gqlvariables: |
    { "hotel":
      { "name": "Taj Hotel",
        "branches": {
          "polygons": [{
            "coordinates": [{
              "points": [{
                "latitude": 11.11,
                "longitude": 22.22
              }, {
                "latitude": 15.15,
                "longitude": 16.16
              }, {
                "latitude": 20.20,
                "longitude": 21.21
              }]
            }, {
              "points": [{
                "latitude": 11.18,
                "longitude": 22.28
              }, {
                "latitude": 15.18,
                "longitude": 16.18
              }, {
                "latitude": 20.28,
                "longitude": 21.28
              }]
            }]
          }, {
            "coordinates": [{
              "points": [{
                "latitude": 91.11,
                "longitude": 92.22
              }, {
                "latitude": 15.15,
                "longitude": 16.16
              }, {
                "latitude": 20.20,
                "longitude": 21.21
              }]
            }, {
              "points": [{
                "latitude": 11.18,
                "longitude": 22.28
              }, {
                "latitude": 15.18,
                "longitude": 16.18
              }, {
                "latitude": 20.28,
                "longitude": 21.28
              }]
            }]
        }]
        }
      }
    }
  explanation: "Add mutation should convert the MultiPolygon type mutation to corresponding Dgraph JSON mutation"
  dgmutations:
    - setjson: |
        {
          "uid":"_:Hotel_1",
          "dgraph.type":["Hotel"],
          "Hotel.name":"Taj Hotel",
          "Hotel.branches": {
            "type": "MultiPolygon",
            "coordinates": [[[[22.22,11.11],[16.16,15.15],[21.21,20.2]],[[22.28,11.18],[16.18,15.18],[21.28,20.28]]],[[[92.22,91.11],[16.16,15.15],[21.21,20.2]],[[22.28,11.18],[16.18,15.18],[21.28,20.28]]]]
          }
        }

-
  name: "Add mutation with variables"
  gqlmutation: |
    mutation addAuthor($auth: AddAuthorInput!) {
      addAuthor(input: [$auth]) {
        author {
          name
        }
      }
    }
  gqlvariables: |
    { "auth":
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": []
      }
    }
  explanation: "A uid and type should get injected and all data transformed to
    underlying Dgraph edge names"
  dgmutations:
    - setjson: |
        { "uid":"_:Author_1",
          "dgraph.type":["Author"],
          "Author.name":"A.N. Author",
          "Author.dob":"2000-01-01",
          "Author.posts":[]
        }

-
  name: "Add deep mutation with variables"
  gqlmutation: |
    mutation addAuthor($auth: AddAuthorInput!) {
      addAuthor(input: [$auth]) {
        author {
          name
        }
      }
    }
  gqlvariables: |
    { "auth":
      { "name": "A.N. Author",
        "posts": [{
                "title": "post1",
                "ps": {"title": "ps1"}
        }, {
                "title": "post2",
                "ps": {"title": "ps2"}
        }, {
                "title": "post3",
                "ps": {"title": "ps3"}
        }, {
                "title": "post4",
                "ps": {"title": "ps4"}
        }, {
                "title": "post5",
                "ps": {"title": "ps5"}
        }, {
                "title": "post6",
                "ps": {"title": "ps6"}
        }, {
                "title": "post7",
                "ps": {"title": "ps7"}
        }, {
                "title": "post8",
                "ps": {"title": "ps8"}
        }]
      }
    }
  explanation: "A uid and type should get injected and all data transformed to
    underlying Dgraph edge names. Some PostSecrets are present and are not created."
  dgquery: |-
    query {
      PostSecret_1(func: eq(PostSecret.title, "ps1")) {
        uid
        dgraph.type
      }
      PostSecret_2(func: eq(PostSecret.title, "ps2")) {
        uid
        dgraph.type
      }
      PostSecret_3(func: eq(PostSecret.title, "ps3")) {
        uid
        dgraph.type
      }
      PostSecret_4(func: eq(PostSecret.title, "ps4")) {
        uid
        dgraph.type
      }
      PostSecret_5(func: eq(PostSecret.title, "ps5")) {
        uid
        dgraph.type
      }
      PostSecret_6(func: eq(PostSecret.title, "ps6")) {
        uid
        dgraph.type
      }
      PostSecret_7(func: eq(PostSecret.title, "ps7")) {
        uid
        dgraph.type
      }
      PostSecret_8(func: eq(PostSecret.title, "ps8")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |
    {
      "PostSecret_1":"0x1",
      "PostSecret_2":"0x2",
      "PostSecret_3":"0x3",
      "PostSecret_4":"0x4"
    }
  dgmutations:
    - setjson: |
        {
          "Author.name":"A.N. Author",
          "Author.posts":
            [
              {
                "Post.author":
                  {
                    "uid":"_:Author_9"
                  },
                "Post.ps":
                  {
                    "uid":"0x1"
                  },
                "Post.title":"post1",
                "dgraph.type":["Post"],
                "uid":"_:Post_10"
              },
              {
                "Post.author":
                  {
                    "uid":"_:Author_9"
                  },
                "Post.ps":
                  {
                    "uid":"0x2"
                  },
                "Post.title":"post2",
                "dgraph.type":["Post"],
                "uid":"_:Post_11"
              },
              {
                "Post.author":
                  {
                    "uid":"_:Author_9"
                  },
                "Post.ps":
                  {
                    "uid":"0x3"
                  },
                "Post.title":"post3",
                "dgraph.type":["Post"],
                "uid":"_:Post_12"
              },
              {
                "Post.author":
                  {
                    "uid":"_:Author_9"
                  },
                "Post.ps":
                  {
                    "uid":"0x4"
                  },
                "Post.title":"post4",
                "dgraph.type":["Post"],
                "uid":"_:Post_13"
              },
              {
                "Post.author":
                  {
                    "uid":"_:Author_9"
                  },
                "Post.ps":
                  {
                    "PostSecret.title":"ps5",
                    "dgraph.type":["PostSecret"],
                    "uid":"_:PostSecret_5"
                  },
                "Post.title":"post5",
                "dgraph.type":["Post"],
                "uid":"_:Post_14"
              },
              {
                "Post.author":
                  {
                    "uid":"_:Author_9"
                  },
                "Post.ps":
                  {
                    "PostSecret.title":"ps6",
                    "dgraph.type":["PostSecret"],
                    "uid":"_:PostSecret_6"
                  },
                "Post.title":"post6",
                "dgraph.type":["Post"],
                "uid":"_:Post_15"
              },
              {
                "Post.author":
                  {
                    "uid":"_:Author_9"
                  },
                "Post.ps":
                  {
                    "PostSecret.title":"ps7",
                    "dgraph.type":["PostSecret"],
                    "uid":"_:PostSecret_7"
                  },
                "Post.title":"post7",
                "dgraph.type":["Post"],
                "uid":"_:Post_16"
              },
              {
                "Post.author":
                  {
                    "uid":"_:Author_9"
                  },
                "Post.ps":
                  {
                    "PostSecret.title":"ps8",
                    "dgraph.type":["PostSecret"],
                    "uid":"_:PostSecret_8"
                  },
                "Post.title":"post8",
                "dgraph.type":["Post"],
                "uid":"_:Post_17"
              }
            ],
          "dgraph.type":["Author"],
          "uid":"_:Author_9"
        }

-
  name: "Add mutation for predicates with special characters having @dgraph directive."
  gqlmutation: |
    mutation {
      addMessage(input : [{content : "content1", author: "author1"}]) {
        message {
          content
          author
        }
      }
    }
  dgmutations:
    - setjson: |
        {
          "uid":"_:Message_1",
          "dgraph.type":["Message"],
          "职业":"author1",
          "post":"content1"
        }

-
  name: "Add multiple mutation with variables"
  gqlmutation: |
    mutation addAuthor($auth: [AddAuthorInput!]!) {
      addAuthor(input: $auth) {
        author {
          name
        }
      }
    }
  gqlvariables: |
    {
      "auth": [{
          "name": "A.N. Author"
        },
        {
          "name": "Different Author"
        }
      ]
    }
  explanation: "A uid and type should get injected and all data transformed to
    underlying Dgraph edge names"
  dgmutations:
    - setjson: |
        { "uid":"_:Author_1",
          "dgraph.type":["Author"],
          "Author.name":"A.N. Author"
        }
    - setjson: |
        { "uid":"_:Author_2",
          "dgraph.type":["Author"],
          "Author.name":"Different Author"
        }

-
  name: "Add Mutation with object at root instead of an array"
  gqlmutation: |
    mutation addAuthor {
      addAuthor(input: { name: "A.N. Author"}) {
        author {
          name
        }
      }
    }
  explanation: "The input being an object should also work because of the input coercion rules
  for input objects."
  dgmutations:
    - setjson: |
        { "uid":"_:Author_1",
          "dgraph.type":["Author"],
          "Author.name":"A.N. Author"
        }


-
  name: "Add Mutation with embedded value"
  gqlmutation: |
    mutation addAuthor {
      addAuthor(input: [{ name: "A.N. Author", posts: []}]) {
        author {
          name
        }
      }
    }
  explanation: "The input should be used for the mutation, with a uid and type getting
    injected and all data transformed to underlying Dgraph edge names"
  dgmutations:
    - setjson: |
        { "uid":"_:Author_1",
          "dgraph.type":["Author"],
          "Author.name":"A.N. Author",
          "Author.posts":[]
        }

-
  name: "Add Mutation with Password field"
  gqlmutation: |
    mutation addUser($name: String!, $pwd: String!) {
      addUser(input: [{ name: $name, pwd: $pwd}]) {
        user {
          name
        }
      }
    }
  gqlvariables: |
    { "name":  "A.N. Author", "pwd": "Password" }
  explanation: "The input and variables should be used for the mutation, with a uid and type
    getting injected and all data transformed to underlying Dgraph edge names"
  dgquery: |-
    query {
      User_1(func: eq(User.name, "A.N. Author")) {
        uid
        dgraph.type
      }
    }
  dgmutations:
    - setjson: |
        {
          "uid":"_:User_1",
          "dgraph.type":["User"],
          "User.name":"A.N. Author",
          "User.pwd":"Password"
        }

-
  name: "Add Multiple Mutations with embedded value"
  gqlmutation: |
    mutation addAuthor {
      addAuthor(input: [{ name: "A.N. Author", posts: []},
                        { name: "Different Author", posts: []}]) {
        author {
          name
        }
      }
    }
  explanation: "The input should be used for the mutation, with a uid and type getting
    injected and all data transformed to underlying Dgraph edge names"
  dgmutations:
    - setjson: |
        {
          "uid":"_:Author_1",
          "dgraph.type":["Author"],
          "Author.name":"A.N. Author",
          "Author.posts":[]
        }
    - setjson: |
        {
          "uid":"_:Author_2",
          "dgraph.type":["Author"],
          "Author.name":"Different Author",
          "Author.posts":[]
        }

-
  name: "Add mutation with reference"
  gqlmutation: |
    mutation addAuthor($auth: AddAuthorInput!) {
      addAuthor(input: [$auth]) {
        author {
          name
        }
      }
    }
  gqlvariables: |
    { "auth":
      { "name": "A.N. Author",
        "country": { "id": "0x123" },
        "posts": []
      }
    }
  explanation: "The reference to country should get transformed to 'uid' for the
    Dgraph JSON mutation"
  dgquery: |-
    query {
      Country_1(func: uid(0x123)) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "Country_1":"0x123"
    }
  dgmutations:
    - setjson: |
        {
          "uid":"_:Author_2",
          "dgraph.type":["Author"],
          "Author.name":"A.N. Author",
          "Author.country":
            {
              "uid": "0x123"
            },
          "Author.posts":[]
        }

-
  name: "Add mutation with missing reference"
  gqlmutation: |
    mutation addAuthor($auth: AddAuthorInput!) {
      addAuthor(input: [$auth]) {
        author {
          name
        }
      }
    }
  gqlvariables: |
    { "auth":
      { "name": "A.N. Author",
        "country": { "id": "0x123" },
        "posts": []
      }
    }
  explanation: "This should throw an error as 0x123 is not a valid Country node"
  dgquery: |-
    query {
      Country_1(func: uid(0x123)) {
        uid
        dgraph.type
      }
    }
  error2:
    {
      "message": "failed to rewrite mutation payload because ID \"0x123\" isn't a Country"
    }

-
  name: "Add mutation with invalid reference"
  gqlmutation: |
    mutation addAuthor($auth: AddAuthorInput!) {
      addAuthor(input: [$auth]) {
        author {
          name
        }
      }
    }
  gqlvariables: |
    { "auth":
      { "name": "A.N. Author",
        "country": { "id": "HI!" },
        "posts": []
      }
    }
  explanation: "A reference must be a valid UID"
  error:
    {
      "message":
        "failed to rewrite mutation payload because ID argument (HI!) was not able to be parsed"
    }

-
  name: "Add mutation with inverse reference"
  gqlmutation: |
    mutation addPost($post: AddPostInput!) {
      addPost(input: [$post]) {
        post {
          postID
        }
      }
    }
  gqlvariables: |
    { "post":
      { "title": "Exciting post",
        "text": "A really good post",
        "author": { "id": "0x2" }
      }
    }
  explanation: "The reference to the author node should be transformed to include
    a new 'posts' edge."
  dgquery: |-
    query {
      Author_1(func: uid(0x2)) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "Author_1": "0x2"
    }
  dgmutations:
    - setjson: |
        { "uid" : "_:Post_2",
          "dgraph.type" : ["Post"],
          "Post.title" : "Exciting post",
          "Post.text" : "A really good post",
          "Post.author": {
            "uid" : "0x2",
            "Author.posts" : [ { "uid": "_:Post_2" } ]
          }
        }

-
  name: "Add mutation for a type that implements an interface"
  gqlmutation: |
    mutation addHuman($human: AddHumanInput!) {
      addHuman(input: [$human]) {
        human {
          name
          dob
          female
        }
      }
    }
  gqlvariables: |
    { "human":
      { "name": "Bob",
        "dob": "2000-01-01",
        "female": true,
        "ename": "employee no. 1"
      }
    }
  explanation: "The mutation should get rewritten with correct edges from the interface."
  dgmutations:
    - setjson: |
        { "uid" : "_:Human_1",
          "Character.name": "Bob",
          "Employee.ename": "employee no. 1",
          "Human.dob": "2000-01-01",
          "Human.female": true,
          "dgraph.type": ["Human", "Character", "Employee"]
        }

-
  name: "Add mutation using xid code 1"
  gqlmutation: |
    mutation addState($input: AddStateInput!) {
      addState(input: [$input]) {
        state {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "code": "nsw",
        "name": "NSW",
        "country": { "id": "0x12" }
      }
    }
  explanation: "The add mutation should get rewritten into a Dgraph upsert mutation"
  dgquery: |-
    query {
      State_1(func: eq(State.code, "nsw")) {
        uid
        dgraph.type
      }
      Country_2(func: uid(0x12)) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "Country_2": "0x12"
    }
  dgmutations:
    - setjson: |
        { "uid" : "_:State_1",
          "dgraph.type": ["State"],
          "State.name": "NSW",
          "State.code": "nsw",
          "State.country": {
            "uid": "0x12",
            "Country.states": [ { "uid": "_:State_1" } ]
          }
        }

-
  name: "Add mutation using xid code 2"
  explanation: "Error thrown as node with code nsw exists."
  gqlmutation: |
    mutation addState($input: AddStateInput!) {
      addState(input: [$input], upsert: false) {
        state {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "code": "nsw",
        "name": "NSW",
        "country": { "id": "0x12" }
      }
    }
  dgquery: |-
    query {
      State_1(func: eq(State.code, "nsw")) {
        uid
        dgraph.type
      }
      Country_2(func: uid(0x12)) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "State_1": "0x11",
      "Country_2": "0x12"
    }
  error2:
    {
      "message": "failed to rewrite mutation payload because id nsw already exists for field code inside type State"
    }

-
  name: "Multiple Upsert Mutation 1"
  explanation: "As both states exist, the countries of the states are updated"
  gqlmutation: |
    mutation addState($input: [AddStateInput!]!) {
      addState(input: $input, upsert: true) {
        state {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      [
        {
          "code": "nsw",
          "name": "NSW",
          "country": { "id": "0x12" }
        },
        {
          "code": "mh",
          "name": "Maharashtra",
          "country": { "id": "0x14" }
        }
      ]
    }
  dgquery: |-
    query {
      State_1(func: eq(State.code, "nsw")) {
        uid
        dgraph.type
      }
      Country_2(func: uid(0x12)) {
        uid
        dgraph.type
      }
      State_3(func: eq(State.code, "mh")) {
        uid
        dgraph.type
      }
      Country_4(func: uid(0x14)) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "State_1": "0x11",
      "Country_2": "0x12",
      "State_3": "0x13",
      "Country_4": "0x14"
    }
  dgquerysec: |-
    query {
      State_1 as State_1(func: uid(0x11)) @filter(type(State)) {
        uid
      }
      State_3 as State_3(func: uid(0x13)) @filter(type(State)) {
        uid
      }
      var(func: uid(State_1)) {
        Country_5 as State.country @filter(NOT (uid(0x12)))
      }
      var(func: uid(State_3)) {
        Country_7 as State.country @filter(NOT (uid(0x14)))
      }
    }
  dgmutations:
    - setjson: |
        { "uid" : "uid(State_1)",
          "State.code":"nsw",
          "State.name": "NSW",
          "State.country": {
            "uid": "0x12",
            "Country.states": [ { "uid": "uid(State_1)" } ]
          }
        }
      deletejson: |
        [
          {
            "uid":"uid(Country_5)",
            "Country.states":
              [
                {
                  "uid":"uid(State_1)"
                }
              ]
          }
        ]
      cond: "@if(gt(len(State_1), 0))"
    - setjson: |
        { "uid" : "uid(State_3)",
          "State.name": "Maharashtra",
          "State.code": "mh",
          "State.country": {
            "uid": "0x14",
            "Country.states": [ { "uid": "uid(State_3)" } ]
          }
        }
      deletejson: |
        [
          {
            "uid":"uid(Country_7)",
            "Country.states":
              [
                {
                  "uid":"uid(State_3)"
                }
              ]
          }
        ]
      cond: "@if(gt(len(State_3), 0))"

-
  name: "Upsert Mutation with multiple xids where both existence queries result exist"
  gqlmutation: |
    mutation addBook($input: [AddBookInput!]!) {
      addBook(input: $input, upsert: true) {
        book {
          title
          ISBN
        }
      }
    }
  gqlvariables: |
    { "input":
      [
        {
          "title": "Sapiens",
          "ISBN": "NSW",
          "publisher": "penguin"
        }
      ]
    }
  dgquery: |-
    query {
      Book_1(func: eq(Book.ISBN, "NSW")) {
        uid
        dgraph.type
      }
      Book_2(func: eq(Book.title, "Sapiens")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "Book_1": "0x11",
      "Book_2": "0x11"
    }
  dgquerysec: |-
    query {
      Book_2 as Book_2(func: uid(0x11)) @filter(type(Book)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        { "uid" : "uid(Book_2)",
          "Book.ISBN":"NSW",
          "Book.title":"Sapiens",
          "Book.publisher": "penguin"
        }
      cond: "@if(gt(len(Book_2), 0))"

-
  name: "Upsert Mutation with multiple xids where only one of existence queries result exist"
  explanation: "Book1 does not exist but Book2 exists. As Book2 exists, this is an upsert.
    Even though, Book1 does not exist, the mutation should not update ISBN as it is also an XID."
  gqlmutation: |
    mutation addBook($input: [AddBookInput!]!) {
      addBook(input: $input, upsert: true) {
        book {
          title
          ISBN
        }
      }
    }
  gqlvariables: |
    { "input":
      [
        {
          "title": "Sapiens",
          "ISBN": "NSW",
          "publisher": "penguin"
        }
      ]
    }
  dgquery: |-
    query {
      Book_1(func: eq(Book.ISBN, "NSW")) {
        uid
        dgraph.type
      }
      Book_2(func: eq(Book.title, "Sapiens")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "Book_2": "0x11"
    }
  dgquerysec: |-
    query {
      Book_2 as Book_2(func: uid(0x11)) @filter(type(Book)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
          "uid" : "uid(Book_2)",
          "Book.ISBN":"NSW",
          "Book.publisher": "penguin",
          "Book.title":"Sapiens"
        }
      cond: "@if(gt(len(Book_2), 0))"

-
  name: "Multiple Upsert Mutation 2"
  explanation: "The first state exists and is updated. Second is created. Country
    is also created in second"
  gqlmutation: |
    mutation addState($input: [AddStateInput!]!) {
      addState(input: $input, upsert: true) {
        state {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      [
        {
          "code": "nsw",
          "name": "NSW",
          "country": { "id": "0x12" }
        },
        {
          "code": "mh",
          "name": "Maharashtra",
          "country": { "name": "India" }
        }
      ]
    }
  dgquery: |-
    query {
      State_1(func: eq(State.code, "nsw")) {
        uid
        dgraph.type
      }
      Country_2(func: uid(0x12)) {
        uid
        dgraph.type
      }
      State_3(func: eq(State.code, "mh")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "State_1": "0x11",
      "Country_2": "0x12"
    }
  dgquerysec: |-
    query {
      State_1 as State_1(func: uid(0x11)) @filter(type(State)) {
        uid
      }
      var(func: uid(State_1)) {
        Country_4 as State.country @filter(NOT (uid(0x12)))
      }
    }
  dgmutations:
    - setjson: |
        { "uid" : "uid(State_1)",
          "State.name": "NSW",
          "State.code": "nsw",
          "State.country": {
            "uid": "0x12",
            "Country.states": [ { "uid": "uid(State_1)" } ]
          }
        }
      deletejson: |
        [
          {
            "uid":"uid(Country_4)",
            "Country.states":
              [
                {
                  "uid":"uid(State_1)"
                }
              ]
          }
        ]
      cond: "@if(gt(len(State_1), 0))"
    - setjson: |
        { "uid" : "_:State_3",
          "dgraph.type": ["State"],
          "State.name": "Maharashtra",
          "State.code": "mh",
          "State.country": {
            "uid": "_:Country_6",
            "dgraph.type": ["Country"],
            "Country.name": "India",
            "Country.states": [ { "uid": "_:State_3" } ]
          }
        }

-
  name: "Add mutation on implementation type which have inherited @id field with interface argument -1"
  explanation: "This mutation will generate three existence queries two for xid - refID (one for interface and one
  for implementing type) and one for xid - name"
  gqlmutation: |
    mutation addLibraryMember($input: AddLibraryMemberInput!) {
      addLibraryMember(input: [$input], upsert: false) {
        libraryMember {
          refID
        }
      }
    }
  gqlvariables: |
    {
        "input": {
            "refID": "101",
            "name": "Alice",
            "itemsIssued": [
                "Intro to Go",
                "Parallel Programming"
            ],
            "readHours": "4d2hr"
        }
    }
  dgquery: |-
    query {
      LibraryMember_1(func: eq(Member.name, "Alice")) {
        uid
        dgraph.type
      }
      LibraryMember_2(func: eq(Member.refID, "101")) {
        uid
        dgraph.type
      }
      LibraryMember_3(func: eq(Member.refID, "101")) {
        uid
        dgraph.type
      }
    }
  dgmutations:
    - setjson: |
        {
            "LibraryMember.readHours": "4d2hr",
            "Member.itemsIssued": [
                "Intro to Go",
                "Parallel Programming"
            ],
            "Member.name": "Alice",
            "Member.refID": "101",
            "dgraph.type": [
                "LibraryMember",
                "Member"
            ],
            "uid": "_:LibraryMember_2"
        }

-
  name: "Add mutation on implementation type which have inherited @id field with interface argument -2"
  explanation: "Node with refID:101 already exist in other implementing type of interface, mutation not allowed
   in this case and we will return error"
  gqlmutation: |
    mutation addLibraryMember($input: AddLibraryMemberInput!) {
      addLibraryMember(input: [$input], upsert: false) {
        libraryMember {
          refID
        }
      }
    }
  gqlvariables: |
    {
        "input": {
            "refID": "101",
            "name": "Alice",
            "itemsIssued": [
                "Intro to Go",
                "Parallel Programming"
            ],
            "readHours": "4d2hr"
        }
    }
  dgquery: |-
    query {
      LibraryMember_1(func: eq(Member.name, "Alice")) {
        uid
        dgraph.type
      }
      LibraryMember_2(func: eq(Member.refID, "101")) {
        uid
        dgraph.type
      }
      LibraryMember_3(func: eq(Member.refID, "101")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "LibraryMember_3": "0x11"
    }
  error2:
    {
      "message": "failed to rewrite mutation payload because id 101 already exists for field refID
       in some other implementing type of interface Member"
    }

-
  name: "Add mutation on implementation type which have inherited @id field with interface argument -3"
  explanation: "Node with refID:101 already exist in same mutated type, returns error "
  gqlmutation: |
    mutation addLibraryMember($input: AddLibraryMemberInput!) {
      addLibraryMember(input: [$input], upsert: false) {
        libraryMember {
          refID
        }
      }
    }
  gqlvariables: |
    {
        "input": {
            "refID": "101",
            "name": "Alice",
            "itemsIssued": [
                "Intro to Go",
                "Parallel Programming"
            ],
            "readHours": "4d2hr"
        }
    }
  dgquery: |-
    query {
      LibraryMember_1(func: eq(Member.name, "Alice")) {
        uid
        dgraph.type
      }
      LibraryMember_2(func: eq(Member.refID, "101")) {
        uid
        dgraph.type
      }
      LibraryMember_3(func: eq(Member.refID, "101")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "LibraryMember_2": "0x11"
    }
  error2:
    {
      "message": "failed to rewrite mutation payload because id 101 already exists for field
       refID inside type LibraryMember"
    }

-
  name: "Add upsert mutation on implementation type which have inherited @id field with interface argument -1"
  explanation: "node with @id field doesn't exist in any of the implementing type, we will add the node"
  gqlmutation: |
    mutation addLibraryMember($input: AddLibraryMemberInput!) {
      addLibraryMember(input: [$input], upsert: true) {
        libraryMember {
          refID
        }
      }
    }
  gqlvariables: |
    {
        "input": {
            "refID": "101",
            "name": "Alice",
            "itemsIssued": [
                "Intro to Go",
                "Parallel Programming"
            ],
            "readHours": "4d2hr"
        }
    }
  dgquery: |-
    query {
      LibraryMember_1(func: eq(Member.name, "Alice")) {
        uid
        dgraph.type
      }
      LibraryMember_2(func: eq(Member.refID, "101")) {
        uid
        dgraph.type
      }
      LibraryMember_3(func: eq(Member.refID, "101")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "LibraryMember_1": "0x11"
    }
  dgquerysec: |-
    query {
      LibraryMember_1 as LibraryMember_1(func: uid(0x11)) @filter(type(LibraryMember)) {
        uid
      }
    }
  dgmutations:
    - setjson: |
        {
            "Member.name": "Alice",
            "Member.refID": "101",
            "LibraryMember.readHours": "4d2hr",
            "Member.itemsIssued": [
                "Intro to Go",
                "Parallel Programming"
            ],
            "uid": "uid(LibraryMember_1)"
        }
      cond: "@if(gt(len(LibraryMember_1), 0))"
-
  name: "Add upsert mutation on implementation type which have inherited @id field with interface argument -2"
  explanation: "node with @id field already exist in one of the implementing type, returns error"
  gqlmutation: |
    mutation addLibraryMember($input: AddLibraryMemberInput!) {
      addLibraryMember(input: [$input], upsert: true) {
        libraryMember {
          refID
        }
      }
    }
  gqlvariables: |
    {
        "input": {
            "refID": "101",
            "name": "Alice",
            "itemsIssued": [
                "Intro to Go",
                "Parallel Programming"
            ],
            "readHours": "4d2hr"
        }
    }
  dgquery: |-
    query {
      LibraryMember_1(func: eq(Member.name, "Alice")) {
        uid
        dgraph.type
      }
      LibraryMember_2(func: eq(Member.refID, "101")) {
        uid
        dgraph.type
      }
      LibraryMember_3(func: eq(Member.refID, "101")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "LibraryMember_3": "0x11"
    }
  error2:
    {
      "message": "failed to rewrite mutation payload because id 101 already exists for
       field refID in some other implementing type of interface Member"
    }

-
  name: "Add mutation with nested object which have inherited @id field with interface argument -1"
  explanation: "There is no node with refID 101 of interface type or it's implementation type,hence will wii add
    nested object and link that to parent object"
  gqlmutation: |
    mutation addLibraryManager($input: AddLibraryManagerInput!) {
      addLibraryManager(input: [$input], upsert: false) {
        libraryManager {
          name
        }
      }
    }
  gqlvariables: |
    {
        "input": {
            "name": "Alice",
            "manages": [
                {
                    "refID": "101",
                    "name": "Bob",
                    "itemsIssued": [
                        "Intro to Go",
                        "Parallel Programming"
                    ],
                    "readHours": "4d2hr"
                }
            ]
        }
    }
  dgquery: |-
    query {
      LibraryManager_1(func: eq(LibraryManager.name, "Alice")) {
        uid
        dgraph.type
      }
      LibraryMember_2(func: eq(Member.name, "Bob")) {
        uid
        dgraph.type
      }
      LibraryMember_3(func: eq(Member.refID, "101")) {
        uid
        dgraph.type
      }
      LibraryMember_4(func: eq(Member.refID, "101")) {
        uid
        dgraph.type
      }
    }
  dgmutations:
    - setjson: |
        {
            "LibraryManager.manages": [
                {
                    "LibraryMember.readHours": "4d2hr",
                    "Member.itemsIssued": [
                        "Intro to Go",
                        "Parallel Programming"
                    ],
                    "Member.name": "Bob",
                    "Member.refID": "101",
                    "dgraph.type": [
                        "LibraryMember",
                        "Member"
                    ],
                    "uid": "_:LibraryMember_3"
                }
            ],
            "LibraryManager.name": "Alice",
            "dgraph.type": [
                "LibraryManager"
            ],
            "uid": "_:LibraryManager_1"
        }

-
  name: "Add mutation with nested object which have inherited @id field with interface argument -2"
  explanation: "node with refID 101 already exist in one of the implementing type other than mutated type,returns error"
  gqlmutation: |
    mutation addLibraryManager($input: AddLibraryManagerInput!) {
      addLibraryManager(input: [$input], upsert: false) {
        libraryManager {
          name
        }
      }
    }
  gqlvariables: |
    {
        "input": {
            "name": "Alice",
            "manages": [
                {
                    "refID": "101",
                    "name": "Bob",
                    "itemsIssued": [
                        "Intro to Go",
                        "Parallel Programming"
                    ],
                    "readHours": "4d2hr"
                }
            ]
        }
    }
  dgquery: |-
    query {
      LibraryManager_1(func: eq(LibraryManager.name, "Alice")) {
        uid
        dgraph.type
      }
      LibraryMember_2(func: eq(Member.name, "Bob")) {
        uid
        dgraph.type
      }
      LibraryMember_3(func: eq(Member.refID, "101")) {
        uid
        dgraph.type
      }
      LibraryMember_4(func: eq(Member.refID, "101")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "LibraryMember_4": "0x11"
    }
  error2:
    {
        "message": "failed to rewrite mutation payload because id 101 already exists for field
         refID in some other implementing type of interface Member"
    }

-
  name: "Add mutation with nested object which have inherited @id field with interface argument -3"
  explanation: "node with refID 101 already exist for mutated type,link child node to parent"
  gqlmutation: |
    mutation addLibraryManager($input: AddLibraryManagerInput!) {
      addLibraryManager(input: [$input], upsert: false) {
        libraryManager {
          name
        }
      }
    }
  gqlvariables: |
    {
        "input": {
            "name": "Alice",
            "manages": [
                {
                    "refID": "101",
                    "name": "Bob",
                    "itemsIssued": [
                        "Intro to Go",
                        "Parallel Programming"
                    ],
                    "readHours": "4d2hr"
                }
            ]
        }
    }
  dgquery: |-
    query {
      LibraryManager_1(func: eq(LibraryManager.name, "Alice")) {
        uid
        dgraph.type
      }
      LibraryMember_2(func: eq(Member.name, "Bob")) {
        uid
        dgraph.type
      }
      LibraryMember_3(func: eq(Member.refID, "101")) {
        uid
        dgraph.type
      }
      LibraryMember_4(func: eq(Member.refID, "101")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "LibraryMember_3": "0x11",
      "LibraryMember_4": "0x11"
    }
  dgmutations:
    - setjson: |
        {
            "LibraryManager.manages": [
                {
                    "uid":"0x11"
                }
            ],
            "LibraryManager.name": "Alice",
            "dgraph.type": [
                "LibraryManager"
            ],
            "uid": "_:LibraryManager_1"
        }

-
  name: "Add mutation on implementation type which have inherited @id fields with interface argument from multiple interfaces"
  explanation: "This mutation will generate six existence queries, 2 existence queries for each of the inherited @id fields
  with interface arg and one for each @id field,none of the existence query return uid,so we successfully add the object in this case"
  gqlmutation: |
    mutation addSportsMember($input: AddSportsMemberInput!) {
      addSportsMember(input: [$input], upsert: false) {
        sportsMember {
          refID
        }
      }
    }
  gqlvariables: |
    {
        "input": {
            "refID": "101",
            "name": "Alice",
            "teamID": "T01",
            "teamName": "GraphQL",
            "itemsIssued": [
                "2-Bats",
                "1-football"
            ],
            "plays": "football and cricket"
        }
    }
  dgquery: |-
    query {
      SportsMember_1(func: eq(Member.name, "Alice")) {
        uid
        dgraph.type
      }
      SportsMember_2(func: eq(Member.refID, "101")) {
        uid
        dgraph.type
      }
      SportsMember_3(func: eq(Member.refID, "101")) {
        uid
        dgraph.type
      }
      SportsMember_4(func: eq(Team.teamID, "T01")) {
        uid
        dgraph.type
      }
      SportsMember_5(func: eq(Team.teamID, "T01")) {
        uid
        dgraph.type
      }
      SportsMember_6(func: eq(Team.teamName, "GraphQL")) {
        uid
        dgraph.type
      }
    }
  dgmutations:
    - setjson: |
        {
            "Member.itemsIssued": [
                "2-Bats",
                "1-football"
            ],
            "Member.name": "Alice",
            "Member.refID": "101",
            "SportsMember.plays": "football and cricket",
            "Team.teamID": "T01",
            "Team.teamName": "GraphQL",
            "dgraph.type": [
                "SportsMember",
                "Member",
                "Team"
            ],
            "uid": "_:SportsMember_6"
        }

-
  name: "Add mutation using code on type which also has an ID field"
  gqlmutation: |
    mutation addEditor($input: AddEditorInput!) {
      addEditor(input: [$input]) {
        editor {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "code": "editor",
        "name": "A.N. Editor"
      }
    }
  explanation: "The add mutation should get rewritten into a Dgraph upsert mutation"
  dgquery: |-
    query {
      Editor_1(func: eq(Editor.code, "editor")) {
        uid
        dgraph.type
      }
    }
  dgmutations:
    - setjson: |
        {
          "uid" : "_:Editor_1",
          "dgraph.type": ["Editor"],
          "Editor.name": "A.N. Editor",
          "Editor.code": "editor"
        }

-
  name: "Deep add mutation"
  gqlmutation: |
    mutation addAuthor($author: AddAuthorInput!) {
      addAuthor(input: [$author]) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    { "author":
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "title": "New post",
            "text": "A really new post"
          }
        ]
      }
    }
  dgmutations:
    - setjson: |
        { "uid" : "_:Author_1",
          "dgraph.type" : [ "Author" ],
          "Author.name": "A.N. Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post_2",
              "dgraph.type" : [ "Post" ],
              "Post.title" : "New post",
              "Post.text" : "A really new post",
              "Post.author": {
                "uid" : "_:Author_1"
              }
            }
          ]
        }

-
  name: "Deep add multiple mutation"
  gqlmutation: |
    mutation addAuthor($author: [AddAuthorInput!]!) {
      addAuthor(input: $author) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    { "author": [
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "title": "New post",
            "text": "A really new post"
          }
        ]
      },
      { "name": "Different Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "title": "New New post",
            "text": "A wonderful post"
          }
        ]
      }]
    }
  dgmutations:
    - setjson: |
        { "uid" : "_:Author_1",
          "dgraph.type" : [ "Author" ],
          "Author.name": "A.N. Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post_2",
              "dgraph.type" : [ "Post" ],
              "Post.title" : "New post",
              "Post.text" : "A really new post",
              "Post.author": {
                "uid" : "_:Author_1"
              }
            }
          ]
        }
    - setjson: |
        { "uid" : "_:Author_3",
          "dgraph.type" : [ "Author" ],
          "Author.name": "Different Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post_4",
              "dgraph.type" : [ "Post" ],
              "Post.title" : "New New post",
              "Post.text" : "A wonderful post",
              "Post.author": {
                "uid" : "_:Author_3"
              }
            }
          ]
        }

-
  name: "Deep add with existing"
  gqlmutation: |
    mutation addAuthor($author: AddAuthorInput!) {
      addAuthor(input: [$author]) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    { "author":
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "title": "New post",
            "text": "A really new post"
          },
          {
            "postID": "0x123",
            "title": "Old post",
            "text": "A really old post"
          }
        ]
      }
    }
  dgquery: |-
    query {
      Post_1(func: uid(0x123)) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "Post_1":"0x123"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x123)) {
        Author_4 as Post.author
      }
    }
  dgmutations:
    - setjson: |
        { "uid": "_:Author_2",
          "dgraph.type": [ "Author" ],
          "Author.name": "A.N. Author",
          "Author.dob": "2000-01-01",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post_3",
              "dgraph.type": [ "Post" ],
              "Post.title": "New post",
              "Post.text": "A really new post",
              "Post.author": {
                "uid": "_:Author_2"
              }
            },
            {
              "uid": "0x123",
              "Post.author": {
                "uid": "_:Author_2"
              }
            }
          ]
        }
      deletejson: |
        [
          {
            "uid": "uid(Author_4)",
            "Author.posts": [{"uid": "0x123"}]
          }
        ]

-
  name: "Deep add multiple with existing"
  gqlmutation: |
    mutation addAuthor($author: [AddAuthorInput!]!) {
      addAuthor(input: $author) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    { "author": [
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "title": "New post",
            "text": "A really new post"
          },
          {
            "postID": "0x123",
            "title": "Old post",
            "text": "A really old post"
          }
        ]
      },
      { "name": "Different Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "title": "New new post",
            "text": "A wonderful post"
          },
          {
            "postID": "0x124",
            "title": "Another Old post",
            "text": "Another old post text"
          }
        ]
      }]
    }
  dgquery: |-
    query {
      Post_1(func: uid(0x123)) {
        uid
        dgraph.type
      }
      Post_2(func: uid(0x124)) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "Post_1":"0x123",
      "Post_2":"0x124"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x123)) {
        Author_5 as Post.author
      }
      var(func: uid(0x124)) {
        Author_8 as Post.author
      }
    }
  dgmutations:
    - setjson: |
        { "uid": "_:Author_3",
          "dgraph.type": [ "Author" ],
          "Author.name": "A.N. Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post_4",
              "dgraph.type": [ "Post" ],
              "Post.title": "New post",
              "Post.text": "A really new post",
              "Post.author": {
                "uid": "_:Author_3"
              }
            },
            {
              "uid": "0x123",
              "Post.author": {
                "uid": "_:Author_3"
              }
            }
          ]
        }
      deletejson: |
        [
          {
            "uid": "uid(Author_5)",
            "Author.posts": [
              {
              "uid": "0x123"
              }
            ]
          }
        ]
    - setjson: |
        {
          "uid": "_:Author_6",
          "dgraph.type": [ "Author" ],
          "Author.name": "Different Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post_7",
              "dgraph.type": [ "Post" ],
              "Post.title": "New new post",
              "Post.text": "A wonderful post",
              "Post.author": {
                "uid": "_:Author_6"
              }
            },
            {
              "uid": "0x124",
              "Post.author": {
                "uid": "_:Author_6"
              }
            }
          ]
        }
      deletejson: |
        [
          {
            "uid": "uid(Author_8)",
            "Author.posts": [
              {
                "uid": "0x124"
              }
            ]
          }
        ]

-
  name: "Deep add with two existing"
  gqlmutation: |
    mutation addAuthor($author: AddAuthorInput!) {
      addAuthor(input: [$author]) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    { "author":
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "postID": "0x123",
            "title": "Old post",
            "text": "A really old post"
          },
          {
            "postID": "0x456"
          }
        ]
      }
    }
  dgquery: |-
    query {
      Post_1(func: uid(0x123)) {
        uid
        dgraph.type
      }
      Post_2(func: uid(0x456)) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "Post_1":"0x123",
      "Post_2":"0x456"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x123)) {
        Author_4 as Post.author
      }
      var(func: uid(0x456)) {
        Author_5 as Post.author
      }
    }
  dgmutations:
    - setjson: |
        { "uid": "_:Author_3",
          "dgraph.type": [ "Author" ],
          "Author.name": "A.N. Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "0x123",
              "Post.author": {
                "uid": "_:Author_3"
              }
            },
            {
              "uid": "0x456",
              "Post.author": {
                "uid": "_:Author_3"
              }
            }
          ]
        }
      deletejson: |
        [
          {
            "uid": "uid(Author_4)",
            "Author.posts": [{"uid": "0x123"}]
          },
          {
            "uid": "uid(Author_5)",
            "Author.posts": [{"uid": "0x456"}]
          }
        ]

-
  name: "Deep add with null"
  gqlmutation: |
    mutation addAuthor($author: AddAuthorInput!) {
      addAuthor(input: [$author]) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    { "author":
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "postID": null,
            "title": "New post",
            "text": "A really new post"
          }
        ]
      }
    }
  dgmutations:
    - setjson: |
        { "uid" : "_:Author_1",
          "dgraph.type" : [ "Author" ],
          "Author.name": "A.N. Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post_2",
              "dgraph.type" : [ "Post" ],
              "Post.title" : "New post",
              "Post.text" : "A really new post",
              "Post.author": {
                "uid" : "_:Author_1"
              }
            }
          ]
        }

-
  name: "Add three deep"
  gqlmutation: |
    mutation addAuthor($author: AddAuthorInput!) {
      addAuthor(input: [$author]) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    { "author":
      { "name": "A.N. Author",
        "dob": "2000-01-01",
        "posts": [
          {
            "title": "Exciting post",
            "text": "A really good post",
            "category": {
              "name": "New Category"
            }
          }
        ]
      }
    }
  dgmutations:
    - setjson: |
        { "uid": "_:Author_1",
          "dgraph.type": [ "Author" ],
          "Author.name": "A.N. Author",
          "Author.dob": "2000-01-01",
          "Author.posts": [
            {
              "uid": "_:Post_2",
              "dgraph.type": [ "Post" ],
              "Post.title": "Exciting post",
              "Post.text": "A really good post",
              "Post.author": {
                "uid": "_:Author_1"
              },
              "Post.category": {
                "uid": "_:Category_3",
                "dgraph.type": [ "Category" ],
                "Category.name": "New Category",
                "Category.posts": [
                  { "uid": "_:Post_2" }
                ]
              }
            }
          ]
        }

-
  name: "Add mutation with deep xid choices 1"
  gqlmutation: |
    mutation addCountry($input: AddCountryInput!) {
      addCountry(input: [$input]) {
        country {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "name": "Dgraph Land",
        "states": [ {
          "code": "dg",
          "name": "Dgraph"
        } ]
      }
    }
  explanation: "No nodes exist. Both nodes are created."
  dgquery: |-
    query {
      State_1(func: eq(State.code, "dg")) {
        uid
        dgraph.type
      }
    }
  dgmutations:
    - setjson: |
        {
          "Country.name":"Dgraph Land",
          "Country.states":
            [
              {
                "State.code":"dg",
                "State.country":
                  {
                    "uid":"_:Country_2"
                  },
                "State.name":"Dgraph",
                "dgraph.type":["State"],
                "uid":"_:State_1"
              }
            ],
          "dgraph.type":["Country"],
          "uid":"_:Country_2"
        }

-
  name: "Add mutation with deep xid choices 2"
  gqlmutation: |
    mutation addCountry($input: AddCountryInput!) {
      addCountry(input: [$input]) {
        country {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "name": "Dgraph Land",
        "states": [ {
          "code": "dg",
          "name": "Dgraph"
        } ]
      }
    }
  explanation: "The state exists. It is linked to the new Country. Its link to old country is deleted."
  dgquery: |-
    query {
      State_1(func: eq(State.code, "dg")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "State_1":"0x12"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x12)) {
        Country_3 as State.country
      }
    }
  dgmutations:
    - setjson: |
        {
          "Country.name":"Dgraph Land",
          "Country.states":
            [
              {
                "State.country":
                  {
                    "uid":"_:Country_2"
                  },
                "uid":"0x12"
              }
            ],
          "dgraph.type":["Country"],
          "uid":"_:Country_2"
        }
      deletejson: |
        [
          {
            "uid":"uid(Country_3)",
            "Country.states":
              [
                {
                  "uid":"0x12"
                }
              ]
          }
        ]

-
  name: "Add mutation with deep xid that must be reference 1"
  gqlmutation: |
    mutation addCountry($input: AddCountryInput!) {
      addCountry(input: [$input]) {
        country {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "name": "Dgraph Land",
        "states": [ {
          "code": "dg"
        } ]
      }
    }
  explanation: "The add mutation has only one option because the state isn't a valid create
    because it's missing required field name"
  dgquery: |-
    query {
      State_1(func: eq(State.code, "dg")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "State_1":"0x12"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x12)) {
        Country_3 as State.country
      }
    }
  dgmutations:
    - setjson: |
        {
          "uid": "_:Country_2",
          "dgraph.type": ["Country"],
          "Country.name": "Dgraph Land",
          "Country.states":
            [
              {
                "uid": "0x12",
                "State.country":
                  {
                    "uid": "_:Country_2"
                  }
              }
            ]
        }
      deletejson: |
        [
          {
            "uid": "uid(Country_3)",
            "Country.states": [{"uid": "0x12"}]
          }
        ]

-
  name: "Add mutation with deep xid that must be reference 2"
  gqlmutation: |
    mutation addCountry($input: AddCountryInput!) {
      addCountry(input: [$input]) {
        country {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "name": "Dgraph Land",
        "states": [ {
          "code": "dg"
        } ]
      }
    }
  explanation: "Error is thrown as State with code dg does not exist"
  dgquery: |-
    query {
      State_1(func: eq(State.code, "dg")) {
        uid
        dgraph.type
      }
    }
  error2:
    {
      "message": "failed to rewrite mutation payload because type State requires a value for field name, but no value present"
    }


-
  name: "deprecated fields can be mutated"
  gqlmutation: |
    mutation addCategory($cat: AddCategoryInput!) {
      addCategory(input: [$cat]) {
        category {
          name
          iAmDeprecated
        }
      }
    }
  gqlvariables: |
    { "cat":
      { "name": "A Category",
        "iAmDeprecated": "but I can be written to"
      }
    }
  dgmutations:
    - setjson: |
        { "uid": "_:Category_1",
          "dgraph.type": ["Category"],
          "Category.name": "A Category",
          "Category.iAmDeprecated": "but I can be written to"
        }

-
  name: "Add mutation with reverse predicate"
  gqlmutation: |
    mutation addMovieDirector($dir: AddMovieDirectorInput!) {
      addMovieDirector(input: [$dir]) {
        movieDirector {
          id
        }
      }
    }
  gqlvariables: |
    { "dir":
      { "name": "Steven Spielberg",
        "directed": [{ "id": "0x2" }]
      }
    }
  explanation: "Movie node exists and is not created"
  dgquery: |-
    query {
      Movie_1(func: uid(0x2)) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "Movie_1":"0x2"
    }
  dgmutations:
    - setjson: |
        { "uid" : "_:MovieDirector_2",
          "dgraph.type" : ["MovieDirector"],
          "MovieDirector.name" : "Steven Spielberg",
          "directed.movies": [{
            "uid" : "0x2"
          }]
        }

- name: "Top Level Duplicate XIDs with same object Test"
  gqlmutation: |
    mutation addState($input: [AddStateInput!]!) {
      addState(input: $input) {
        state {
          code
          name
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {"name": "State1", "code": "S1"},
        {"name": "State1", "code": "S1"}
      ]
    }
  explanation: "When duplicate XIDs are given as input at top level, but the object structure is
  same, it should return error."
  error:
    message: "failed to rewrite mutation payload because duplicate XID found: S1"

- name: "Top Level Duplicate XIDs with different object Test"
  gqlmutation: |
    mutation addState($input: [AddStateInput!]!) {
      addState(input: $input) {
        state {
          code
          name
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {"name": "State1", "code": "S1"},
        {"name": "State2", "code": "S1"}
      ]
    }
  explanation: "When duplicate XIDs are given as input at top level, but the object structure is
  different, it should still return error."
  error:
    message: "failed to rewrite mutation payload because duplicate XID found: S1"

- name: "Deep Mutation Duplicate XIDs with same object Test"
  gqlmutation: |
    mutation addCity($input: [AddCityInput!]!) {
      addCity(input: $input) {
        city {
          name
          district {
            code
            name
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "name": "Bengaluru",
          "district": {"code": "D1", "name": "Dist1"}
        },
        {
          "name": "NY",
          "district": {"code": "D1", "name": "Dist1"}
        },
        {
         "name": "Sydney",
         "district": {"code": "D1"}
        }
      ]
    }
  explanation: "When duplicate XIDs are given as input to deep mutation but the object structure
  is same or contains just xid, it should not return error."
  dgquery: |-
    query {
      District_1(func: eq(District.code, "D1")) {
        uid
        dgraph.type
      }
    }
  dgmutations:
    - setjson: |
        {
          "City.district":
            {
              "District.cities":
                [
                  {
                    "uid":"_:City_2"
                  }
                ],
              "District.code":"D1",
              "District.name":"Dist1",
              "dgraph.type":["District"],
              "uid":"_:District_1"
            },
          "City.name":"Bengaluru",
          "dgraph.type":["City"],
          "uid":"_:City_2"
        }
    - setjson: |
        {
          "City.district":
            {
              "District.cities":
                [
                  {
                    "uid":"_:City_3"
                  }
                ],
              "uid":"_:District_1"
            },
          "City.name":"NY",
          "dgraph.type":["City"],
          "uid":"_:City_3"
        }
    - setjson: |
        {
          "City.district":
            {
              "District.cities":
                [
                  {
                    "uid":"_:City_4"
                  }
                ],
              "uid":"_:District_1"
            },
          "City.name":"Sydney",
          "dgraph.type":["City"],
          "uid":"_:City_4"
        }

- name: "Deep Mutation Duplicate XIDs with same object with @hasInverse Test"
  gqlmutation: |
    mutation addCountry($input: [AddCountryInput!]!) {
      addCountry(input: $input) {
        country {
          id
          name
          states {
            code
            name
            capital
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "name": "Country1",
          "states": [
            {"code": "S1", "name": "State1", "capital": "Cap1"},
            {"code": "S1", "name": "State1", "capital": "Cap1"}
          ]
        },
        {
          "name": "Country2",
          "states": [
            {"code": "S2", "name": "State2", "capital": "Cap2"}
          ]
        },
        {
          "name": "Country3",
          "states": [
            {"code": "S2", "name": "State2", "capital": "Cap2"}
          ]
        }
      ]
    }
  explanation: "When duplicate XIDs are given as input to deep mutation and the object structure
  is same and the containing object has @hasInverse on its xid object field, but the xid object
  does not have the @hasInverse field of List type, it should return error."
  error:
    message: |-
      failed to rewrite mutation payload because duplicate XID found: S1
      failed to rewrite mutation payload because duplicate XID found: S2

- name: "Deep Mutation Duplicate XIDs with different object Test"
  gqlmutation: |
    mutation addStudent($input: [AddStudentInput!]!) {
      addStudent(input: $input) {
        student {
          xid
          name
          taughtBy {
            xid
            name
            subject
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "xid": "S1",
          "name": "Stud1",
          "taughtBy": [
            {"xid": "T1", "name": "Teacher1", "subject": "Sub1"}
          ]
        },
        {
          "xid": "S2",
          "name": "Stud2",
          "taughtBy": [
            {"xid": "T1", "name": "Teacher1", "subject": "Sub2"}
          ]
        },
        {
          "xid": "S3",
          "name": "Stud3",
          "taughtBy": [
            {"xid": "T1", "name": "Teacher1"}
          ]
        }
      ]
    }
  explanation: "When duplicate XIDs are given as input to deep mutation but the object structure
  is different, it should return error."
  error:
    message: |-
      failed to rewrite mutation payload because duplicate XID found: T1
      failed to rewrite mutation payload because duplicate XID found: T1

- name: "Circular Duplicate XIDs in single mutation"
  gqlmutation: |
    mutation addStudent($input: [AddStudentInput!]!) {
      addStudent(input: $input) {
        student {
          xid
          name
          taughtBy {
            xid
            name
            subject
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "xid": "S1",
          "name": "Stud1",
          "taughtBy": [
            {"xid": "T1", "name": "Teacher1", "teaches": [{"xid": "S1", "name": "Stud1"}]}
          ]
        }
      ]
    }
  explanation: "When duplicate XIDs are given as input circularly in a single mutation, it
  should return error."
  error:
    message: |-
      failed to rewrite mutation payload because duplicate XID found: S1

# Additional Deletes
#
# If we have
#
# type Post { ... author: Author @hasInverse(field: posts) ... }
# type Author { ... posts: [Post] ... }
#
# and existing edge
#
# Post1 --- author --> Author1
#
# there must also exist edge
#
# Author1 --- posts --> Post1
#
# So if we did an add Author2 and connect the author to Post1, that changes the
# author of Post1 to Author2, we need to
#  * add edge Post1 --- author --> Author2 (done by asIDReference/asXIDReference)
#  * add edge Author2 --- posts --> Post1 (done by addInverseLink)
#  * delete edge Author1 --- posts --> Post1 (done by addAdditionalDeletes)
#
# This delete only needs to be done when there is a singular edge in the mutation:
# i.e. if both directions of the edge are [], then it's just an add.
#
# There's three cases to consider: add by ID, add by XID, deep add

- name: "Additional Deletes - Add connects to existing node by ID"
  gqlmutation: |
    mutation addAuthor($auth: AddAuthorInput!) {
      addAuthor(input: [$auth]) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    {
      "auth": {
        "name": "A.N. Author",
        "posts": [ { "postID": "0x456" }, {"title": "New Post", "author": {"name": "Abhimanyu"}} ]
      }
    }
  dgquery: |-
    query {
      Post_1(func: uid(0x456)) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "Post_1": "0x456"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x456)) {
        Author_3 as Post.author
      }
    }
  dgmutations:
    - setjson: |
        {
          "uid":"_:Author_2",
          "dgraph.type":["Author"],
          "Author.name":"A.N. Author",
          "Author.posts": [
            {
              "uid": "0x456",
              "Post.author": { "uid": "_:Author_2" }
            },
            {
              "uid": "_:Post_4",
              "dgraph.type": ["Post"],
              "Post.title": "New Post",
              "Post.author": { "uid": "_:Author_2" }
            }
          ]
        }
      deletejson: |
        [
          {
            "uid": "uid(Author_3)",
            "Author.posts": [ { "uid": "0x456" } ]
          }
        ]

- name: "Additional Deletes - Add connects to existing node by XID"
  explanation: "One of the states exists. Country attached to that state is deleted."
  gqlmutation: |
    mutation addCountry($inp: AddCountryInput!) {
      addCountry(input: [$inp]) {
        country {
          id
        }
      }
    }
  gqlvariables: |
    {
      "inp": {
        "name": "A Country",
        "states": [
          { "code": "abc", "name": "Alphabet" },
          { "code": "def", "name": "Vowel", "country": { "name": "B country" } }
        ]
      }
    }
  dgquery: |-
    query {
      State_1(func: eq(State.code, "abc")) {
        uid
        dgraph.type
      }
      State_2(func: eq(State.code, "def")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "State_1": "0x1234"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x1234)) {
        Country_4 as State.country
      }
    }
  dgmutations:
    - setjson: |
        {
          "Country.name":"A Country",
          "Country.states":
            [
              {
                "State.country":
                  {
                    "uid":"_:Country_3"
                  },
                "uid":"0x1234"
              },
              {
                "State.code":"def",
                "State.country":
                  {
                    "uid":"_:Country_3"
                  },
                "State.name":"Vowel",
                "dgraph.type":["State"],
                "uid":"_:State_2"
              }
            ],
          "dgraph.type":["Country"],
          "uid":"_:Country_3"
        }
      deletejson: |
        [
          {
            "uid":"uid(Country_4)",
            "Country.states":
              [
                {"uid":"0x1234"}
              ]
          }
        ]

- name: "Deep XID 4 level deep 1"
  explanation: "No nodes exist. All nodes are created."
  gqlmutation: |
    mutation addStudent($student: AddStudentInput!) {
      addStudent(input: [$student]) {
        student {
          name
        }
      }
    }
  gqlvariables: |
    {
      "student": {
        "xid": "S0",
        "name": "Student0",
        "taughtBy": [{
                "xid": "T0",
                "name": "teacher0",
                "teaches": [{
                        "xid": "S1",
                        "name": "Student1",
                        "taughtBy": [{
                                "xid": "T1",
                                "name": "teacher1"
                        }]
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Student_1(func: eq(People.xid, "S0")) {
        uid
        dgraph.type
      }
      Teacher_2(func: eq(People.xid, "T0")) {
        uid
        dgraph.type
      }
      Student_3(func: eq(People.xid, "S1")) {
        uid
        dgraph.type
      }
      Teacher_4(func: eq(People.xid, "T1")) {
        uid
        dgraph.type
      }
    }
  dgmutations:
    - setjson: |
        {
          "People.name":"Student0",
          "People.xid":"S0",
          "Student.taughtBy":
            [
              {
                "People.name":"teacher0",
                "People.xid":"T0",
                "Teacher.teaches":
                  [
                    {
                      "uid":"_:Student_1"
                    },
                    {
                      "People.name":"Student1",
                      "People.xid":"S1",
                      "Student.taughtBy":
                        [
                          {
                            "uid":"_:Teacher_2"
                          },
                          {
                            "People.name":"teacher1",
                            "People.xid":"T1",
                            "Teacher.teaches":
                              [
                                {
                                  "uid":"_:Student_3"
                                }
                              ],
                            "dgraph.type":["Teacher","People"],
                            "uid":"_:Teacher_4"
                          }
                        ],
                      "dgraph.type":["Student","People"],
                      "uid":"_:Student_3"
                    }
                  ],
                "dgraph.type":["Teacher","People"],
                "uid":"_:Teacher_2"
              }
            ],
          "dgraph.type":["Student","People"],
          "uid":"_:Student_1"
        }

- name: "Deep XID 4 level deep 2"
  explanation: "Teacher T1 also teaches the newly added student at top level, S0."
  gqlmutation: |
    mutation addStudent($student: AddStudentInput!) {
      addStudent(input: [$student]) {
        student {
          name
        }
      }
    }
  gqlvariables: |
    {
      "student": {
        "xid": "S0",
        "name": "Student0",
        "taughtBy": [{
                "xid": "T0",
                "name": "teacher0",
                "teaches": [{
                        "xid": "S1",
                        "name": "Student1",
                        "taughtBy": [{
                                "xid": "T1",
                                "name": "teacher1",
                                "teaches": [{
                                      "xid": "S0"
                                }]
                        }]
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Student_1(func: eq(People.xid, "S0")) {
        uid
        dgraph.type
      }
      Teacher_2(func: eq(People.xid, "T0")) {
        uid
        dgraph.type
      }
      Student_3(func: eq(People.xid, "S1")) {
        uid
        dgraph.type
      }
      Teacher_4(func: eq(People.xid, "T1")) {
        uid
        dgraph.type
      }
    }
  dgmutations:
    - setjson: |
        {
          "People.name":"Student0",
          "People.xid":"S0",
          "Student.taughtBy":
            [
              {
                "People.name":"teacher0",
                "People.xid":"T0",
                "Teacher.teaches":
                  [
                    {
                      "uid":"_:Student_1"
                    },
                    {
                      "People.name":"Student1",
                      "People.xid":"S1",
                      "Student.taughtBy":
                        [
                          {
                            "uid":"_:Teacher_2"
                          },
                          {
                            "People.name":"teacher1",
                            "People.xid":"T1",
                            "Teacher.teaches":
                              [
                                {
                                  "uid":"_:Student_3"
                                },
                                {
                                  "uid":"_:Student_1",
                                  "Student.taughtBy":
                                    [
                                      {
                                        "uid":"_:Teacher_4"
                                      }
                                    ]
                                }
                              ],
                            "dgraph.type":["Teacher","People"],
                            "uid":"_:Teacher_4"
                          }
                        ],
                      "dgraph.type":["Student","People"],
                      "uid":"_:Student_3"
                    }
                  ],
                "dgraph.type":["Teacher","People"],
                "uid":"_:Teacher_2"
              }
            ],
          "dgraph.type":["Student","People"],
          "uid":"_:Student_1"
        }

- name: "Deep XID Add top level hasInverse 1"
  explanation: "No nodes exists. All are created."
  gqlmutation: |
    mutation addStudent($student: AddStudentInput!) {
      addStudent(input: [$student]) {
        student {
          name
        }
      }
    }
  gqlvariables: |
    {
      "student": {
        "xid": "S0",
        "name": "Student0",
        "taughtBy": [{
                "xid": "T0",
                "name": "teacher0",
                "teaches": [{
                        "xid": "S1",
                        "name": "Student1"
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Student_1(func: eq(People.xid, "S0")) {
        uid
        dgraph.type
      }
      Teacher_2(func: eq(People.xid, "T0")) {
        uid
        dgraph.type
      }
      Student_3(func: eq(People.xid, "S1")) {
        uid
        dgraph.type
      }
    }

  dgmutations:
    - setjson: |
        {
          "People.name":"Student0",
          "People.xid":"S0",
          "Student.taughtBy":
            [
              {
                "People.name":"teacher0",
                "People.xid":"T0",
                "Teacher.teaches":
                  [
                    {
                      "uid":"_:Student_1"
                    },
                    {
                      "People.name":"Student1",
                      "People.xid":"S1",
                      "Student.taughtBy":
                        [
                          {
                            "uid":"_:Teacher_2"
                          }
                        ],
                      "dgraph.type":["Student","People"],
                      "uid":"_:Student_3"
                    }
                  ],
                "dgraph.type":["Teacher","People"],
                "uid":"_:Teacher_2"
              }
            ],
          "dgraph.type":["Student","People"],
          "uid":"_:Student_1"
        }

- name: "Deep XID Add top level hasInverse 2"
  explanation: "Teacher T0 exists and is linked to Student S0"
  gqlmutation: |
    mutation addStudent($student: AddStudentInput!) {
      addStudent(input: [$student]) {
        student {
          name
        }
      }
    }
  gqlvariables: |
    {
      "student": {
        "xid": "S0",
        "name": "Student0",
        "taughtBy": [{
                "xid": "T0",
                "name": "teacher0",
                "teaches": [{
                        "xid": "S1",
                        "name": "Student1"
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Student_1(func: eq(People.xid, "S0")) {
        uid
        dgraph.type
      }
      Teacher_2(func: eq(People.xid, "T0")) {
        uid
        dgraph.type
      }
      Student_3(func: eq(People.xid, "S1")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |
    {
      "Teacher_2": "0x987"
    }
  dgmutations:
    - setjson: |
        {
          "People.name":"Student0",
          "People.xid":"S0",
          "Student.taughtBy":
            [
              {
                "Teacher.teaches":
                  [
                    {
                      "uid":"_:Student_1"
                    }
                  ],
                "uid":"0x987"
              }
            ],
          "dgraph.type":["Student","People"],
          "uid":"_:Student_1"
        }

- name: "Deep XID Add top level hasInverse 3"
  explanation: "Student S1 exists and is linked to Teacher T0."
  gqlmutation: |
    mutation addStudent($student: AddStudentInput!) {
      addStudent(input: [$student]) {
        student {
          name
        }
      }
    }
  gqlvariables: |
    {
      "student": {
        "xid": "S0",
        "name": "Student0",
        "taughtBy": [{
                "xid": "T0",
                "name": "teacher0",
                "teaches": [{
                        "xid": "S1",
                        "name": "Student1"
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Student_1(func: eq(People.xid, "S0")) {
        uid
        dgraph.type
      }
      Teacher_2(func: eq(People.xid, "T0")) {
        uid
        dgraph.type
      }
      Student_3(func: eq(People.xid, "S1")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |
    {
      "Student_3": "0x123"
    }
  dgmutations:
    - setjson: |
        {
          "People.name":"Student0",
          "People.xid":"S0",
          "Student.taughtBy":
            [
              {
                "People.name":"teacher0",
                "People.xid":"T0",
                "Teacher.teaches":
                  [
                    {
                      "uid":"_:Student_1"
                    },
                    {
                      "Student.taughtBy":
                        [
                          {
                            "uid":"_:Teacher_2"
                          }
                        ],
                      "uid":"0x123"
                    }
                  ],
                "dgraph.type":["Teacher","People"],
                "uid":"_:Teacher_2"
              }
            ],
          "dgraph.type":["Student","People"],
          "uid":"_:Student_1"
        }


- name: "Deep XID Add lower level hasInvsere 1"
  explanation: "None of the nodes exists. All of them are created."
  gqlmutation: |
    mutation addLab($lab: AddLabInput!) {
      addLab(input: [$lab]) {
        lab {
          name
        }
      }
    }
  gqlvariables: |
    {
      "lab": {
        "name": "Lab1",
        "computers": [{
                "name": "computer1",
                "owners": [{
                        "name": "owner1"
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Lab_1(func: eq(Lab.name, "Lab1")) {
        uid
        dgraph.type
      }
      Computer_2(func: eq(Computer.name, "computer1")) {
        uid
        dgraph.type
      }
      ComputerOwner_3(func: eq(ComputerOwner.name, "owner1")) {
        uid
        dgraph.type
      }
    }
  dgmutations:
    - setjson: |
        {
          "Lab.computers":
            [
              {
                "Computer.name":"computer1",
                "Computer.owners":
                  [
                    {
                      "ComputerOwner.computers":
                        {
                          "uid":"_:Computer_2"
                        },
                      "ComputerOwner.name":"owner1",
                      "dgraph.type":["ComputerOwner"],
                      "uid":"_:ComputerOwner_3"
                    }
                  ],
                "dgraph.type":["Computer"],
                "uid":"_:Computer_2"
              }
            ],
          "Lab.name":"Lab1",
          "dgraph.type":["Lab"],
          "uid":"_:Lab_1"
        }

- name: "Deep XID Add lower level hasInvsere 2"
  explanation: "computer exists. Computer node is linked to Lab."
  gqlmutation: |
    mutation addLab($lab: AddLabInput!) {
      addLab(input: [$lab]) {
        lab {
          name
        }
      }
    }
  gqlvariables: |
    {
      "lab": {
        "name": "Lab1",
        "computers": [{
                "name": "computer1",
                "owners": [{
                        "name": "owner1"
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Lab_1(func: eq(Lab.name, "Lab1")) {
        uid
        dgraph.type
      }
      Computer_2(func: eq(Computer.name, "computer1")) {
        uid
        dgraph.type
      }
      ComputerOwner_3(func: eq(ComputerOwner.name, "owner1")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |
    {
      "Computer_2": "0x234"
    }
  dgmutations:
    - setjson: |
        {
          "Lab.computers":
            [
              {
                "uid":"0x234"
              }
            ],
          "Lab.name":"Lab1",
          "dgraph.type":["Lab"],
          "uid":"_:Lab_1"
        }

- name: "Deep XID Add lower level hasInvsere 3"
  explanation: "Computer Owner exists and is linked to computer."
  gqlmutation: |
    mutation addLab($lab: AddLabInput!) {
      addLab(input: [$lab]) {
        lab {
          name
        }
      }
    }
  gqlvariables: |
    {
      "lab": {
        "name": "Lab1",
        "computers": [{
                "name": "computer1",
                "owners": [{
                        "name": "owner1"
                }]
        }]
      }
    }
  dgquery: |-
    query {
      Lab_1(func: eq(Lab.name, "Lab1")) {
        uid
        dgraph.type
      }
      Computer_2(func: eq(Computer.name, "computer1")) {
        uid
        dgraph.type
      }
      ComputerOwner_3(func: eq(ComputerOwner.name, "owner1")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |
    {
      "ComputerOwner_3": "0x123"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x123)) {
        Computer_4 as ComputerOwner.computers
      }
    }
  dgmutations:
    - setjson: |
        {
          "Lab.computers":
            [
              {
                "Computer.name":"computer1",
                "Computer.owners":
                  [
                    {
                      "ComputerOwner.computers":
                        {
                          "uid":"_:Computer_2"
                        },
                      "uid":"0x123"
                    }
                  ],
                "dgraph.type":["Computer"],
                "uid":"_:Computer_2"
              }
            ],
          "Lab.name":"Lab1",
          "dgraph.type":["Lab"],
          "uid":"_:Lab_1"
        }
      deletejson: |-
        [{
            "Computer.owners": [
                {
                    "uid": "0x123"
                }
            ],
            "uid": "uid(Computer_4)"
        }]

- name: "Deep mutation alternate id xid"
  gqlmutation: |
    mutation addAuthor($city: AddCityInput!) {
      addCity(input: [$city]) {
        city {
          name
          district {
            code
            name
            cities {
              name
              district {
                code
                name
              }
            }
          }
        }
      }
    }
  gqlvariables: |
    {
      "city": {
        "name": "c1",
        "district":{
                "name":"d1",
                "code":"d1",
                "cities":[{"name": "c2"}]
        }
      }
    }
  dgquery: |-
    query {
      District_1(func: eq(District.code, "d1")) {
        uid
        dgraph.type
      }
    }
  dgmutations:
    - setjson: |
        {
          "City.district":
            {
              "District.cities":
                [
                  {
                    "uid":"_:City_2"
                  },
                  {
                    "City.district":
                      {
                        "uid":"_:District_1"
                      },
                      "City.name":"c2",
                      "dgraph.type":["City"],
                      "uid":"_:City_3"
                  }
                ],
              "District.code":"d1",
              "District.name":"d1",
              "dgraph.type":["District"],
              "uid":"_:District_1"
            },
          "City.name":"c1",
          "dgraph.type":["City"],
          "uid":"_:City_2"
        }

- name: "Deep mutation alternate id xid with existing XID"
  gqlmutation: |
    mutation addAuthor($city: AddCityInput!) {
      addCity(input: [$city]) {
        city {
          name
          district {
            code
            name
            cities {
              name
              district {
                code
                name
              }
            }
          }
        }
      }
    }
  gqlvariables: |
    {
      "city": {
        "name": "c1",
        "district":{
                "name":"d1",
                "code":"d1",
                "cities":[{"name": "c2"}]
        }
      }
    }
  dgquery: |-
    query {
      District_1(func: eq(District.code, "d1")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "District_1": "0x123"
    }
  dgmutations:
    - setjson: |
        {
          "City.district":
            {
              "District.cities":
                [
                  {
                    "uid":"_:City_2"
                  }
                ],
              "uid":"0x123"
            },
          "City.name":"c1",
          "dgraph.type":["City"],
          "uid":"_:City_2"
        }


- name: "Additional Deletes - deep mutation"
  gqlmutation: |
    mutation addAuthor($auth: AddAuthorInput!) {
      addAuthor(input: [$auth]) {
        author {
          id
        }
      }
    }
  gqlvariables: |
    {
      "auth": {
        "name": "A.N. Author",
        "country": {
          "name": "A Country",
          "states": [ { "code": "abc", "name": "Alphabet" } ]
        }
      }
    }
  dgquery: |-
    query {
      State_1(func: eq(State.code, "abc")) {
        uid
        dgraph.type
      }
    }
  dgmutations:
    - setjson: |
        {
          "Author.country":
            {
              "Country.name":"A Country",
              "Country.states":
                [
                  {
                    "State.code":"abc",
                    "State.country": {"uid":"_:Country_3"},
                    "State.name":"Alphabet",
                    "dgraph.type":["State"],
                    "uid":"_:State_1"
                  }
                ],
              "dgraph.type":["Country"],
              "uid":"_:Country_3"
            },
          "Author.name":"A.N. Author",
          "dgraph.type":["Author"],
          "uid":"_:Author_2"
        }

- name: "Deep mutation three level xid with no initial XID "
  gqlmutation: |
    mutation($auth: [AddPost1Input!]!) {
      addPost1(input: $auth) {
        post1 {
          id
          comments {
            id
            replies {
              id
            }
          }
        }
      }
    }

  gqlvariables: |
    {
      "auth": [{
        "id": "post1",
        "comments": [{
          "id": "comment1",
          "replies": [{
            "id": "reply1"
          }]
        }]
      },
      {
        "id": "post2",
        "comments": [{
          "id": "comment2",
          "replies": [{
            "id": "reply1"
          }]
        }]
      }]
    }
  dgquery: |-
    query {
      Post1_1(func: eq(Post1.id, "post1")) {
        uid
        dgraph.type
      }
      Comment1_2(func: eq(Comment1.id, "comment1")) {
        uid
        dgraph.type
      }
      Comment1_3(func: eq(Comment1.id, "reply1")) {
        uid
        dgraph.type
      }
      Post1_4(func: eq(Post1.id, "post2")) {
        uid
        dgraph.type
      }
      Comment1_5(func: eq(Comment1.id, "comment2")) {
        uid
        dgraph.type
      }
    }
  dgmutations:
    - setjson: |
        {
          "Post1.comments":
            [
              {
                "Comment1.id": "comment1",
                "Comment1.replies":
                  [
                    {
                     "Comment1.id":"reply1",
                     "dgraph.type": ["Comment1"],
                     "uid":"_:Comment1_3"
                    }
                  ],
                "dgraph.type":["Comment1"],
                "uid":"_:Comment1_2"
              }
            ],
          "Post1.id":"post1",
          "dgraph.type":["Post1"],
          "uid":"_:Post1_1"
        }
    - setjson: |
        {
          "Post1.comments":
            [
              {
                "Comment1.id":"comment2",
                "Comment1.replies":
                  [
                    {
                      "uid":"_:Comment1_3"
                    }
                  ],
                "dgraph.type":["Comment1"],
                "uid":"_:Comment1_5"
              }
            ],
          "Post1.id":"post2",
          "dgraph.type":["Post1"],
          "uid":"_:Post1_4"
        }

- name: "Deep mutation three level xid with existing XIDs 1"
  explanation: "reply1 and comment1 exists and is not created"
  gqlmutation: |
    mutation($auth: [AddPost1Input!]!) {
      addPost1(input: $auth) {
        post1 {
          id
          comments {
            id
            replies {
              id
            }
          }
        }
      }
    }

  gqlvariables: |
    {
      "auth": [{
        "id": "post1",
        "comments": [{
          "id": "comment1",
          "replies": [{
            "id": "reply1"
          }]
        }]
      },
      {
        "id": "post2",
        "comments": [{
          "id": "comment2",
          "replies": [{
            "id": "reply1"
          }]
        }]
      }]
    }
  dgquery: |-
    query {
      Post1_1(func: eq(Post1.id, "post1")) {
        uid
        dgraph.type
      }
      Comment1_2(func: eq(Comment1.id, "comment1")) {
        uid
        dgraph.type
      }
      Comment1_3(func: eq(Comment1.id, "reply1")) {
        uid
        dgraph.type
      }
      Post1_4(func: eq(Post1.id, "post2")) {
        uid
        dgraph.type
      }
      Comment1_5(func: eq(Comment1.id, "comment2")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |
    {
      "Comment1_2": "0x110",
      "Comment1_3": "0x111"
    }
  dgmutations:
    - setjson: |
        {
          "Post1.comments":
            [
              {
                "uid":"0x110"
              }
            ],
          "Post1.id":"post1",
          "dgraph.type":["Post1"],
          "uid":"_:Post1_1"
        }
    - setjson: |
        {
          "Post1.comments":
            [
              {
                "Comment1.id":"comment2",
                "Comment1.replies":
                  [
                    {
                      "uid":"0x111"
                    }
                  ],
                "dgraph.type":["Comment1"],
                "uid":"_:Comment1_5"
              }
            ],
          "Post1.id":"post2",
          "dgraph.type":["Post1"],
          "uid":"_:Post1_4"
        }

- name: "Deep mutation three level xid with existing XIDs 2"
  explanation: "comment2 and comment1 exists. reply1 does not exist. reply1 is not created as its parent exists."
  gqlmutation: |
    mutation($auth: [AddPost1Input!]!) {
      addPost1(input: $auth) {
        post1 {
          id
          comments {
            id
            replies {
              id
            }
          }
        }
      }
    }

  gqlvariables: |
    {
      "auth": [{
        "id": "post1",
        "comments": [{
          "id": "comment1",
          "replies": [{
            "id": "reply1"
          }]
        }]
      },
      {
        "id": "post2",
        "comments": [{
          "id": "comment2",
          "replies": [{
            "id": "reply1"
          }]
        }]
      }]
    }
  dgquery: |-
    query {
      Post1_1(func: eq(Post1.id, "post1")) {
        uid
        dgraph.type
      }
      Comment1_2(func: eq(Comment1.id, "comment1")) {
        uid
        dgraph.type
      }
      Comment1_3(func: eq(Comment1.id, "reply1")) {
        uid
        dgraph.type
      }
      Post1_4(func: eq(Post1.id, "post2")) {
        uid
        dgraph.type
      }
      Comment1_5(func: eq(Comment1.id, "comment2")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |
    {
      "Comment1_2": "0x110",
      "Comment1_5": "0x111"
    }
  dgmutations:
    - setjson: |
        {
          "Post1.comments":
            [
              {
                "uid":"0x110"
              }
            ],
          "Post1.id":"post1",
          "dgraph.type":["Post1"],
          "uid":"_:Post1_1"
        }
    - setjson: |
        {
          "Post1.comments":
            [
              {
                "uid":"0x111"
              }
            ],
          "Post1.id":"post2",
          "dgraph.type":["Post1"],
          "uid":"_:Post1_4"
        }

-
  name: "Add mutation error on @id field for empty value"
  gqlmutation: |
    mutation addState($input: AddStateInput!) {
      addState(input: [$input]) {
        state {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "code": "",
        "name": "NSW",
        "country": { "id": "0x12" }
      }
    }
  explanation: "The add mutation should not be allowed since value of @id field is empty."
  error:
    { "message": "failed to rewrite mutation payload because encountered an empty value for @id field `State.code`" }

-
  name: "Add mutation error on @id field for empty value (Nested)"
  gqlmutation: |
    mutation addCountry($input: AddCountryInput!) {
      addCountry(input: [$input]) {
        country {
          name
        }
      }
    }
  gqlvariables: |
    { "input":
      {
        "name": "Dgraph Land",
        "states": [ {
          "code": "",
          "name": "Dgraph"
        } ]
      }
    }
  explanation: "The add mutation should not be allowed since value of @id field is empty."
  error:
    { "message": "failed to rewrite mutation payload because encountered an empty value for @id field `State.code`" }

-
  name: "Add mutation for person with @hasInverse"
  gqlmutation: |
    mutation($input: [AddPersonInput!]!) {
      addPerson(input: $input) {
        person {
          name
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "name": "Or",
          "friends": [
            { "name": "Michal", "friends": [{ "name": "Justin" }] }
          ]
        }
      ]
    }
  dgmutations:
    - setjson: |
        {
          "Person.friends": [
            {
              "Person.friends": [
                {
                  "uid": "_:Person_1"
                },
                {
                  "Person.friends": [
                    {
                      "uid": "_:Person_2"
                    }
                  ],
                  "Person.name": "Justin",
                  "dgraph.type": [
                    "Person"
                  ],
                  "uid": "_:Person_3"
                }
              ],
              "Person.name": "Michal",
              "dgraph.type": [
                "Person"
              ],
              "uid": "_:Person_2"
            }
          ],
          "Person.name": "Or",
          "dgraph.type": [
            "Person"
          ],
          "uid": "_:Person_1"
        }

-
  name: "Add mutation with union"
  gqlmutation: |
    mutation($input: [AddHomeInput!]!) {
      addHome(input: $input) {
        home {
          address
          members {
            ... on Dog {
              breed
            }
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "address": "United Street",
          "members": [
            { "dogRef": { "category": "Mammal", "breed": "German Shephard"} },
            { "parrotRef": { "category": "Bird", "repeatsWords": ["squawk"]} },
            { "humanRef": { "name": "Han Solo", "ename": "Han_emp"} }
          ],
          "favouriteMember": { "parrotRef": { "id": "0x123"} }
        }
      ]
    }
  dgquery: |-
    query {
      Parrot_1(func: uid(0x123)) {
        uid
        dgraph.type
      }
    }
  qnametouid: |-
    {
      "Parrot_1" : "0x123"
    }
  dgmutations:
    - setjson: |
        {
          "Home.address": "United Street",
          "Home.favouriteMember": {
            "uid": "0x123"
          },
          "Home.members": [{
            "Animal.category": "Mammal",
            "Dog.breed": "German Shephard",
            "dgraph.type": ["Dog", "Animal"],
            "uid": "_:Dog_3"
          }, {
            "Animal.category": "Bird",
            "Parrot.repeatsWords": ["squawk"],
            "dgraph.type": ["Parrot", "Animal"],
            "uid": "_:Parrot_4"
          }, {
            "Character.name": "Han Solo",
            "Employee.ename": "Han_emp",
            "dgraph.type": ["Human", "Character", "Employee"],
            "uid": "_:Human_5"
          }],
          "dgraph.type": ["Home"],
          "uid": "_:Home_2"
        }

-
  name: "Add mutation with union - invalid input"
  gqlmutation: |
    mutation($input: [AddHomeInput!]!) {
      addHome(input: $input) {
        home {
          address
          members {
            ... on Dog {
              breed
            }
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "address": "United Street",
          "members": [
            { "dogRef": { "category": "Mammal"}, "parrotRef": { "category": "Bird"} },
            { "parrotRef": { "category": "Bird", "repeatsWords": ["squawk"]} },
            { "humanRef": { "name": "Han Solo", "ename": "Han_emp"} }
          ],
          "favouriteMember": { }
        }
      ]
    }
  explanation: "The add mutation should not be allowed since the union input is invalid"
  error:
    message: |-
      failed to rewrite mutation payload because value for field `favouriteMember` in type `Home` must have exactly one child, found 0 children
      failed to rewrite mutation payload because value for field `members` in type `Home` index `0` must have exactly one child, found 2 children

-
  name: "Add type with multiple Xid fields"
  gqlmutation: |
    mutation($input: [AddBookInput!]!) {
    	addBook(input: $input) {
    		book {
    			title
    			ISBN
    			author {
    				name
    			}
    		}
    	}
    }

  gqlvariables: |
    {
        "input": [
            {
                "title": "Sapiens",
                "ISBN": "2312SB",
                "author": {
                    "name": "Yuval Noah Harari"
                }
            }
        ]
    }
  dgquery: |-
    query {
      Book_1(func: eq(Book.ISBN, "2312SB")) {
        uid
        dgraph.type
      }
      Book_2(func: eq(Book.title, "Sapiens")) {
        uid
        dgraph.type
      }
    }
  dgmutations:
    - setjson: |
        {
            "Book.author": {
                "author.name": "Yuval Noah Harari",
                "author.book": [
                    {
                        "uid": "_:Book_2"
                    }
                ],
                "dgraph.type": [
                    "author"
                ],
                "uid": "_:author_3"
            },
            "Book.ISBN": "2312SB",
            "Book.title": "Sapiens",
            "dgraph.type": [
                "Book"
            ],
            "uid": "_:Book_2"
        }

-
  name: "Add mutation with multiple Xid fields shouldn't give error if xidName+xidVal is equal for two different xid fields in a type"
  gqlmutation: |
    mutation($input: [AddABCInput!]!) {
    	addABC(input: $input) {
    		aBC {
    			ab
    			abc
    		}
    	}
    }

  gqlvariables: |
    {
        "input": [
            {
                "ab": "cd",
                "abc": "d"
            }
        ]
    }
  dgquery: |-
    query {
      ABC_1(func: eq(ABC.ab, "cd")) {
        uid
        dgraph.type
      }
      ABC_2(func: eq(ABC.abc, "d")) {
        uid
        dgraph.type
      }
    }
  explanation: "We should generate different variables as ABC_1 and ABC_2 if xidName+xidValue is same as in above case
  i.e. ab+cd and abc+d both equals to abcd"
  dgmutations:
    - setjson: |
        {
            "ABC.ab": "cd",
            "ABC.abc": "d",
            "dgraph.type": [
                "ABC"
            ],
            "uid":"_:ABC_2"
        }

-
  name: "Add mutation with multiple Xid fields shouldn't give error if xidName+xidVal is equal for two different xid fields in different objects"
  gqlmutation: |
    mutation($input: [AddABCInput!]!) {
    	addABC(input: $input) {
    		aBC {
    			ab
    			abc
    		}
    	}
    }

  gqlvariables: |
    {
        "input": [
            {
                "ab": "cd",
                "abc": "de"
            },
            {
                 "ab": "ef",
                 "abc": "d"
            }
        ]
    }
  dgquery: |-
    query {
      ABC_1(func: eq(ABC.ab, "cd")) {
        uid
        dgraph.type
      }
      ABC_2(func: eq(ABC.abc, "de")) {
        uid
        dgraph.type
      }
      ABC_3(func: eq(ABC.ab, "ef")) {
        uid
        dgraph.type
      }
      ABC_4(func: eq(ABC.abc, "d")) {
        uid
        dgraph.type
      }
    }
  explanation: "We should generate different variables as ABC_1 and ABC_4 if xidName+xidValue is same in two different objects as in above case
  i.e. ab+cd and abc+d both equals to abcd"
  dgmutations:
    - setjson: |
        {
            "ABC.ab": "cd",
            "ABC.abc": "de",
            "dgraph.type": [
                "ABC"
            ],
            "uid":"_:ABC_2"
        }
    - setjson: |
        {
            "ABC.ab": "ef",
            "ABC.abc": "d",
            "dgraph.type": [
                "ABC"
            ],
            "uid":"_:ABC_4"
        }

-
  name: "Add mutation with multiple Xid fields shouldn't give error if typeName+xidName+xidVal is equal for two different xid fields in different types"
  gqlmutation: |
    mutation($input: [AddABCInput!]!) {
    	addABC(input: $input) {
    		aBC {
    			ab
    			abc
                AB {
                  Cab
                  Cabc
                }
    		}
    	}
    }

  gqlvariables: |
    {
        "input": [
            {
                "ab": "cd",
                "abc": "de",
                "AB": {
                  "Cab": "cde",
                  "Cabc":"d"
                }
            }
        ]
    }
  dgquery: |-
    query {
      ABC_1(func: eq(ABC.ab, "cd")) {
        uid
        dgraph.type
      }
      ABC_2(func: eq(ABC.abc, "de")) {
        uid
        dgraph.type
      }
      AB_3(func: eq(AB.Cab, "cde")) {
        uid
        dgraph.type
      }
      AB_4(func: eq(AB.Cabc, "d")) {
        uid
        dgraph.type
      }
    }
  explanation: "We should generate different variables as ABC_1 and AB_3, or ABC_2 and AB_4 if typename+xidName+xidValue is same in two different types as in above case
  i.e. ABC+ab+cd and AB+Cabc+d both equals to ABCabcd"
  dgmutations:
    - setjson: |
        {
          "ABC.AB": {
            "AB.Cab": "cde",
            "AB.Cabc": "d",
            "dgraph.type": ["AB"],
            "uid": "_:AB_4"
          },
          "ABC.ab": "cd",
          "ABC.abc": "de",
          "dgraph.type": ["ABC"],
          "uid": "_:ABC_2"
        }


-
  name: "Add type with multiple Xid fields at deep level"
  gqlmutation: |
    mutation($input: [AddauthorInput!]!) {
    	addauthor(input: $input) {
    		author {
    			name
    			book {
    				title
    				ISBN
    			}
    		}
    	}
    }

  gqlvariables: |
    {
        "input": [
            {
                "name": "Yuval Noah Harari",
                "book": {
                    "title": "Sapiens",
                    "ISBN": "2312SB"
                }
            }
        ]
    }
  dgquery: |-
    query {
      Book_1(func: eq(Book.ISBN, "2312SB")) {
        uid
        dgraph.type
      }
      Book_2(func: eq(Book.title, "Sapiens")) {
        uid
        dgraph.type
      }
    }
  dgmutations:
    - setjson: |
        {
            "author.name": "Yuval Noah Harari",
            "dgraph.type": [
                "author"
            ],
            "uid": "_:author_3",
            "author.book": [
                {
                    "Book.ISBN": "2312SB",
                    "Book.title": "Sapiens",
                    "Book.author": {
                        "uid": "_:author_3"
                    },
                    "dgraph.type": [
                        "Book"
                    ],
                    "uid": "_:Book_2"
                }
            ]
        }

-
  name: "Add mutation for type Person1 with multiple xids referencing same node as closeFriends and friends, closeFriends refer friends with xid id"
  explanation: "The mutation adds same node as friends and closeFriends. It should
    work irrespective of the order in which the node is referenced."
  gqlmutation: |
    mutation($input: [AddPerson1Input!]!) {
      addPerson1(input: $input) {
        person1 {
          id
          name
          friends {
            id
            name
          }
          closeFriends {
            id
            name
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "id": "1",
          "name": "First Person",
          "friends": [{
            "id": "2",
            "name": "Second Person"
           }],
          "closeFriends": [{
            "id": "2"
           }]
        }
      ]
    }
  dgquery: |-
    query {
      Person1_1(func: eq(Person1.id, "1")) {
        uid
        dgraph.type
      }
      Person1_2(func: eq(Person1.name, "First Person")) {
        uid
        dgraph.type
      }
      Person1_3(func: eq(Person1.id, "2")) {
        uid
        dgraph.type
      }
      Person1_4(func: eq(Person1.name, "Second Person")) {
        uid
        dgraph.type
      }
    }
  dgmutations:
    - setjson: |
        {
          "Person1.closeFriends": [
            {
              "Person1.closeFriends": [
                {
                  "uid": "_:Person1_2"
                }
              ],
              "Person1.name": "Second Person",
              "Person1.id": "2",
              "dgraph.type": [
                "Person1"
              ],
              "uid": "_:Person1_3"
            }
          ],
          "Person1.friends": [
            {
              "uid": "_:Person1_3",
              "Person1.friends": [
                {
                  "uid": "_:Person1_2"
                }
              ]
            }
          ],
          "Person1.name": "First Person",
          "Person1.id": "1",
          "dgraph.type": [
            "Person1"
          ],
          "uid": "_:Person1_2"
        }

-
  name: "Add type with multiple Xids fields at deep level when deep node already exist for all existence queries"
  gqlmutation: |
    mutation($input: [AddauthorInput!]!) {
    	addauthor(input: $input) {
    		author {
    			name
    			book {
    				title
    				ISBN
    			}
    		}
    	}
    }

  gqlvariables: |
    {
        "input": [
            {
                "name": "Yuval Noah Harari",
                "book": {
                    "title": "Sapiens",
                    "ISBN": "2312SB"
                }
            }
        ]
    }
  dgquery: |-
    query {
      Book_1(func: eq(Book.ISBN, "2312SB")) {
        uid
        dgraph.type
      }
      Book_2(func: eq(Book.title, "Sapiens")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |
    {
      "Book_1": "0x12",
      "Book_2": "0x11"
    }
  error2:
    {
      "message": "failed to rewrite mutation payload because multiple nodes found for given xid values,
       updation not possible"
    }
-
  name: "Add type with multiple Xids fields at deep level when deep node already exist for one existence query"
  gqlmutation: |
    mutation($input: [AddauthorInput!]!) {
    	addauthor(input: $input) {
    		author {
    			name
    			book {
    				title
    				ISBN
    			}
    		}
    	}
    }

  gqlvariables: |
    {
        "input": [
            {
                "name": "Yuval Noah Harari",
                "book": {
                    "title": "Sapiens",
                    "ISBN": "2312SB"
                }
            }
        ]
    }
  dgquery: |-
    query {
      Book_1(func: eq(Book.ISBN, "2312SB")) {
        uid
        dgraph.type
      }
      Book_2(func: eq(Book.title, "Sapiens")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |
    {
      "Book_2": "0x119"
    }
  dgquerysec: |-
    query {
      var(func: uid(0x119)) {
        author_4 as Book.author
      }
    }
  dgmutations:
    - setjson: |
        {
            "author.name": "Yuval Noah Harari",
            "dgraph.type": [
                "author"
            ],
            "uid": "_:author_3",
            "author.book": [
                {
                    "Book.author": {
                        "uid": "_:author_3"
                    },
                    "uid": "0x119"
                }
            ]
        }
      deletejson: |
        [
            {
                "author.book": [
                    {
                        "uid": "0x119"
                    }
                ],
                "uid": "uid(author_4)"
            }
        ]

-
  name: "Add mutation for type Person1 with multiple xids referencing same node as closeFriends and friends, friends refer closeFriends with xid name "
  explanation: "The mutation adds same node as friends and closeFriends. It should
    work irrespective of the order in which the node is referenced."
  gqlmutation: |
    mutation($input: [AddPerson1Input!]!) {
      addPerson1(input: $input) {
        person1 {
          id
          name
          friends {
            id
            name
          }
          closeFriends {
            id
            name
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "id": "1",
          "name": "First Person",
          "closeFriends": [{
            "id": "2",
            "name": "Second Person"
           }],
          "friends": [{
            "name": "Second Person"
           }]
        }
      ]
    }
  dgquery: |-
    query {
      Person1_1(func: eq(Person1.id, "1")) {
        uid
        dgraph.type
      }
      Person1_2(func: eq(Person1.name, "First Person")) {
        uid
        dgraph.type
      }
      Person1_3(func: eq(Person1.id, "2")) {
        uid
        dgraph.type
      }
      Person1_4(func: eq(Person1.name, "Second Person")) {
        uid
        dgraph.type
      }
    }
  dgmutations:
    - setjson: |
        {
            "Person1.closeFriends": [
                {
                    "Person1.closeFriends": [
                        {
                            "uid": "_:Person1_2"
                        }
                    ],
                    "Person1.id": "2",
                    "Person1.name": "Second Person",
                    "dgraph.type": [
                        "Person1"
                    ],
                    "uid": "_:Person1_4"
                }
            ],
            "Person1.friends": [
                {
                    "Person1.friends": [
                        {
                            "uid": "_:Person1_2"
                        }
                    ],
                    "uid": "_:Person1_4"
                }
            ],
            "Person1.id": "1",
            "Person1.name": "First Person",
            "dgraph.type": [
                "Person1"
            ],
            "uid": "_:Person1_2"
        }

- name: "Reference to inverse field should be ignored and not throw an error"
  gqlmutation: |
    mutation addDistrict($input: [AddDistrictInput!]!) {
      addDistrict(input: $input) {
        district {
          name
          code
          cities {
            name
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "name": "Dist1",
          "code": "D1",
          "cities": [{"name": "Bengaluru", "district": { "code": "non-existing" } }]
        },
        {
          "name": "Dist2",
          "code": "D2",
          "cities": [{"name": "Pune", "district": { "code": "D2" } }]
        }
      ]
    }
  explanation: "As district is inverse of city. There is no need to supply district to
    the city. In case it is supplied, it is simply ignored. The city is linked to D1 and
    district with code non-existing is ignored. Not even its existence query is generated."
  dgquery: |-
    query {
      District_1(func: eq(District.code, "D1")) {
        uid
        dgraph.type
      }
      District_2(func: eq(District.code, "D2")) {
        uid
        dgraph.type
      }
    }
  dgmutations:
    - setjson: |
        {
          "District.cities":
            [
              {
                "City.name":"Bengaluru",
                "dgraph.type":["City"],
                "City.district": {
                  "uid": "_:District_1"
                },
                "uid":"_:City_3"
              }
            ],
            "District.code":"D1",
            "District.name":"Dist1",
            "dgraph.type":["District"],
            "uid":"_:District_1"
        }
    - setjson: |
        {
          "District.cities":
            [
              {
                "City.name":"Pune",
                "dgraph.type":["City"],
                "City.district": {
                  "uid": "_:District_2"
                },
                "uid":"_:City_4"
              }
            ],
            "District.code":"D2",
            "District.name":"Dist2",
            "dgraph.type":["District"],
            "uid":"_:District_2"
        }

- name: "Reference to inverse field should be ignored and not throw an error 2"
  gqlmutation: |
    mutation addFoo($input: [AddFooInput!]!) {
      addFoo(input: $input) {
        foo {
          id
          bar {
            id
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "id": "123",
          "bar": {"id": "1234", "foo": { "id": "123" } }
        },
        {
          "id": "1",
          "bar": {"id": "2", "foo": { "id": "3" } }
        }
      ]
    }
  explanation: "As foo is inverse of bar. There is no need to supply bar to
    foo. In case it is supplied, it is simply ignored."
  dgquery: |-
    query {
      Foo_1(func: eq(Foo.id, "123")) {
        uid
        dgraph.type
      }
      Bar_2(func: eq(Bar.id, "1234")) {
        uid
        dgraph.type
      }
      Foo_3(func: eq(Foo.id, "1")) {
        uid
        dgraph.type
      }
      Bar_4(func: eq(Bar.id, "2")) {
        uid
        dgraph.type
      }
    }
  dgmutations:
    - setjson: |
        {
          "Foo.bar":
              {
                "Bar.id":"1234",
                "dgraph.type":["Bar"],
                "Bar.foo": {
                  "uid": "_:Foo_1"
                },
                "uid":"_:Bar_2"
              },
            "Foo.id":"123",
            "dgraph.type":["Foo"],
            "uid":"_:Foo_1"
        }
    - setjson: |
        {
          "Foo.bar":
              {
                "Bar.id":"2",
                "dgraph.type":["Bar"],
                "Bar.foo": {
                  "uid": "_:Foo_3"
                },
                "uid":"_:Bar_4"
              },
            "Foo.id":"1",
            "dgraph.type":["Foo"],
            "uid":"_:Foo_3"
        }

-
  name: "Add mutation for Friend, Friend1 should not generated same variable name for existence queries"
  gqlmutation: |
    mutation($input: [AddFriend1Input!]!) {
      addFriend1(input: $input) {
        friend1 {
          id
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "id": "Main Friend",
          "friends": [
            { "id": "Friend1" },
            { "id": "Friend2" },
            { "id": "Friend3" },
            { "id": "Friend4" },
            { "id": "Friend5" },
            { "id": "Friend6" },
            { "id": "Friend7" },
            { "id": "Friend8" },
            { "id": "Friend9" },
            { "id": "Friend10" },
            { "id": "Friend11" }
          ]
        }
      ]
    }
  dgquery: |-
    query {
      Friend1_1(func: eq(Friend1.id, "Main Friend")) {
        uid
        dgraph.type
      }
      Friend_2(func: eq(Friend.id, "Friend1")) {
        uid
        dgraph.type
      }
      Friend_3(func: eq(Friend.id, "Friend2")) {
        uid
        dgraph.type
      }
      Friend_4(func: eq(Friend.id, "Friend3")) {
        uid
        dgraph.type
      }
      Friend_5(func: eq(Friend.id, "Friend4")) {
        uid
        dgraph.type
      }
      Friend_6(func: eq(Friend.id, "Friend5")) {
        uid
        dgraph.type
      }
      Friend_7(func: eq(Friend.id, "Friend6")) {
        uid
        dgraph.type
      }
      Friend_8(func: eq(Friend.id, "Friend7")) {
        uid
        dgraph.type
      }
      Friend_9(func: eq(Friend.id, "Friend8")) {
        uid
        dgraph.type
      }
      Friend_10(func: eq(Friend.id, "Friend9")) {
        uid
        dgraph.type
      }
      Friend_11(func: eq(Friend.id, "Friend10")) {
        uid
        dgraph.type
      }
      Friend_12(func: eq(Friend.id, "Friend11")) {
        uid
        dgraph.type
      }
    }
  dgmutations:
    - setjson: |
       {
          "Friend1.friends":
            [
              {
                "Friend.id":"Friend1",
                "dgraph.type":["Friend"],
                "uid":"_:Friend_2"
              },
              {
                "Friend.id":"Friend2",
                "dgraph.type":["Friend"],
                "uid":"_:Friend_3"
              },
              {
                "Friend.id":"Friend3",
                "dgraph.type":["Friend"],
                "uid":"_:Friend_4"
              },
              {
                "Friend.id":"Friend4",
                "dgraph.type":["Friend"],
                "uid":"_:Friend_5"
              },
              {
                "Friend.id":"Friend5",
                "dgraph.type":["Friend"],
                "uid":"_:Friend_6"
              },
              {
                "Friend.id":"Friend6",
                "dgraph.type":["Friend"],
                "uid":"_:Friend_7"
              },
              {
                "Friend.id":"Friend7",
                "dgraph.type":["Friend"],
                "uid":"_:Friend_8"
              },
              {
                "Friend.id":"Friend8",
                "dgraph.type":["Friend"],
                "uid":"_:Friend_9"
              },
              {
                "Friend.id":"Friend9",
                "dgraph.type":["Friend"],
                "uid":"_:Friend_10"
              },
              {
                "Friend.id":"Friend10",
                "dgraph.type":["Friend"],
                "uid":"_:Friend_11"
              },
              {
                "Friend.id":"Friend11",
                "dgraph.type":["Friend"],
                "uid":"_:Friend_12"
              }
            ],
          "Friend1.id":"Main Friend",
          "dgraph.type":["Friend1"],
          "uid":"_:Friend1_1"
       }

-
  name: "Add mutation with language tag fields"
  gqlmutation: |
    mutation {
         addPerson(input: { name: "Alice", nameHi: "ऐलिस",nameZh: "爱丽丝"}) {
           person {
             name
             nameZh
             nameHi
           }
         }
    }
  dgmutations:
    - setjson: |
        { "Person.name":"Alice",
          "Person.name@hi":"ऐलिस",
          "Person.name@zh":"爱丽丝",
          "dgraph.type": ["Person"],
          "uid": "_:Person_1"
        }

-
  name: "2-level add mutation with nullable @id fields "
  explaination: "bookId in Book and PenName in author are @id and nullable field,
   we can skip them while doing add mutation. Nested object author doesn't exist, so we
   add it and link it to book"
  gqlmutation: |
    mutation addBook($input: [AddBookInput!]!) {
      addBook(input: $input, upsert: false) {
        book {
          title
        }
      }
    }
  gqlvariables: |
    { "input":
      [
        {
          "title": "Sapiens",
          "ISBN": "B02",
          "publisher": "penguin",
          "author": {
             "name": "Alice",
             "authorId": "A02"
          }
        }
      ]
    }
  dgquery: |-
    query {
      Book_1(func: eq(Book.ISBN, "B02")) {
        uid
        dgraph.type
      }
      Book_2(func: eq(Book.title, "Sapiens")) {
        uid
        dgraph.type
      }
      author_3(func: eq(author.authorId, "A02")) {
        uid
        dgraph.type
      }
    }
  dgmutations:
    - setjson: |
        {
            "Book.title": "Sapiens",
            "Book.ISBN": "B02",
            "Book.publisher": "penguin",
            "dgraph.type": [
                "Book"
            ],
            "Book.author": {
                "author.authorId":"A02",
                "author.book": [
                    {
                        "uid": "_:Book_2"
                    }
                ],
                "author.name": "Alice",
                "dgraph.type": [
                    "author"
                ],
                "uid": "_:author_3"
            },
            "uid": "_:Book_2"
        }

-
  name: "2- level add mutation with upsert and nullable @id fields "
  explaination: "bookId in @id,penName in author are nullable @id fields and we can skip them.
  title,ISBN in Book are @id fields,so also added in set Json, because @id fields will also be updated by upserts.
  Both book and author already exist so we just link new author to book and delete old reference from book to author,
  if there is any"
  gqlmutation: |
    mutation addBook($input: [AddBookInput!]!) {
      addBook(input: $input, upsert: true) {
        book {
          title
        }
      }
    }
  gqlvariables: |
    { "input":
      [
        {
          "title": "Sapiens",
          "ISBN": "B01",
          "publisher": "penguin",
          "author": {
             "name": "Alice",
             "authorId": "A01"
          }
        }
      ]
    }
  dgquery: |-
    query {
      Book_1(func: eq(Book.ISBN, "B01")) {
        uid
        dgraph.type
      }
      Book_2(func: eq(Book.title, "Sapiens")) {
        uid
        dgraph.type
      }
      author_3(func: eq(author.authorId, "A01")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |
    {
       "Book_2":"0x11",
       "author_3": "0x12"
    }
  dgquerysec: |-
    query {
      Book_2 as Book_2(func: uid(0x11)) @filter(type(Book)) {
        uid
      }
      var(func: uid(Book_2)) {
        author_4 as Book.author @filter(NOT (uid(0x12)))
      }
    }
  dgmutations:
    - setjson: |
        {
            "Book.ISBN": "B01",
            "Book.author": {
                "author.book": [
                    {
                        "uid": "uid(Book_2)"
                    }
                ],
                "uid": "0x12"
            },
            "Book.publisher": "penguin",
            "Book.title": "Sapiens",
            "uid": "uid(Book_2)"
        }
      deletejson: |
        [{
           "author.book": [
              {
                  "uid": "uid(Book_2)"
              }
          ],
          "uid": "uid(author_4)"
        }]
      cond: "@if(gt(len(Book_2), 0))"

-
  name: "add mutation with upsert gives error when multiple nodes are found for existence queries"
  explaination: "Two different books exist for title and Sapiens @id fields, We can't do upsert mutation "
  gqlmutation: |
    mutation addBook($input: [AddBookInput!]!) {
      addBook(input: $input, upsert: true) {
        book {
          title
        }
      }
    }
  gqlvariables: |
    { "input":
      [
        {
          "title": "Sapiens",
          "ISBN": "B01",
          "publisher": "penguin"
        }
      ]
    }
  dgquery: |-
    query {
      Book_1(func: eq(Book.ISBN, "B01")) {
        uid
        dgraph.type
      }
      Book_2(func: eq(Book.title, "Sapiens")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |
    {
       "Book_1":"0x11",
       "Book_2": "0x12"
    }
  error2:
    {
      "message": "failed to rewrite mutation payload because multiple nodes found
       for given xid values, updation not possible"
    }

-
  name: "add mutation with upsert at nested level gives error when multiple nodes are found
   for existence queries"
  explaination: "Two different author exist for penName and authorId @id fields inside author,
   We can't link author to both books "
  gqlmutation: |
    mutation addBook($input: [AddBookInput!]!) {
      addBook(input: $input, upsert: true) {
        book {
          title
        }
      }
    }
  gqlvariables: |
    { "input":
      [
        {
          "title": "Sapiens",
          "ISBN": "B01",
          "publisher": "penguin",
          "author": {
             "penName": "Alice",
             "authorId": "A01"
          }
        }
      ]
    }
  dgquery: |-
    query {
      Book_1(func: eq(Book.ISBN, "B01")) {
        uid
        dgraph.type
      }
      Book_2(func: eq(Book.title, "Sapiens")) {
        uid
        dgraph.type
      }
      author_3(func: eq(author.authorId, "A01")) {
        uid
        dgraph.type
      }
      author_4(func: eq(author.penName, "Alice")) {
        uid
        dgraph.type
      }
    }
  qnametouid: |
    {
       "author_3":"0x11",
       "author_4": "0x12"
    }
  error2:
    {
      "message": "failed to rewrite mutation payload because multiple nodes
       found for given xid values, updation not possible"
    }

-
  name: "No xid present for add mutation with upsert"
  explaination: "If none of the xid field is given in upsert mutation then there will be no existence queries,
   and it will behave as simple add mutation,i.e. create new node with all the given fields"
  gqlmutation: |
    mutation addBook($input: [AddBookInput!]!) {
      addBook(input: $input, upsert: true) {
        book {
          title
        }
      }
    }
  gqlvariables: |
    { "input":
      [
        {
          "publisher": "penguin"
        }
      ]
    }
  dgmutations:
    - setjson: |
        {
            "Book.publisher": "penguin",
            "dgraph.type": [
                    "Book"
                ],
             "uid":"_:Book_1"
        }

-
  name: "Non-nullable xid should be present in add Mutation for nested field"
  explaination: "non-nullable @id field id in comment1 type not provided. As no reference is
   provided for comment, we treat it as new node, and return error for missing xid."
  gqlmutation: |
    mutation addPost1($input: [AddPost1Input!]!) {
      addPost1(input: $input, upsert: false) {
        post1 {
          content
        }
      }
    }
  gqlvariables: |
    { "input":
      [
        {
          "id": "P01",
          "content":"Intro to GraphQL",
          "comments":[{
             "message":"Nice Intro! Love GraphQl"
          }]
        }
      ]
    }
  dgquery: |-
    query {
      Post1_1(func: eq(Post1.id, "P01")) {
        uid
        dgraph.type
      }
    }
  error2:
    {
      "message": "failed to rewrite mutation payload because field id cannot be empty"
    }

-
  name: "Add Mutation referencing same XID in different types"
  gqlmutation: |
    mutation($input: [AddT1Input!]!) {
      addT1(input: $input) {
        t1 {
          name
          name1
          name2
          link {
            name
            name1
            name3
          }
        }
      }
    }
  gqlvariables: |
    {
      "input": [
        {
          "name": "Bob",
          "name1": "Bob11",
          "name2": "Bob2",
          "link": {
            "name": "Bob"
          }
        }
      ]
    }
  explanation: "As the link and top level object contain the same XID, Bob, this should throw an error"
  error:
    {
      "message":
        "failed to rewrite mutation payload because using duplicate XID value: Bob for XID: name for two different
         implementing types of same interfaces: T1 and T2"
    }

