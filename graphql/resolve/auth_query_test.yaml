- name: "Deep RBAC rule - All level true"
  gqlquery: |
    query {
      queryContact {
        id
        nickName
        adminTasks {
          id
          name
          occurrences {
            due
            comp
          }
        }
      }
    }
  jwtvar:
    ContactRole: ADMINISTRATOR
    TaskRole: ADMINISTRATOR
    TaskOccuranceRole: ADMINISTRATOR
  dgquery: |-
    query {
      queryContact(func: uid(ContactRoot)) {
        Contact.id : uid
        Contact.nickName : Contact.nickName
        Contact.adminTasks : Contact.adminTasks @filter(uid(AdminTask1)) {
          AdminTask.id : uid
          AdminTask.name : AdminTask.name
          AdminTask.occurrences : AdminTask.occurrences @filter(uid(TaskOccurrence3)) {
            TaskOccurrence.due : TaskOccurrence.due
            TaskOccurrence.comp : TaskOccurrence.comp
            dgraph.uid : uid
          }
        }
      }
      ContactRoot as var(func: uid(Contact6))
      Contact6 as var(func: type(Contact))
      var(func: uid(ContactRoot)) {
        AdminTask2 as Contact.adminTasks
      }
      AdminTask1 as var(func: uid(AdminTask2))
      var(func: uid(AdminTask1)) {
        TaskOccurrence4 as AdminTask.occurrences
      }
      TaskOccurrence3 as var(func: uid(TaskOccurrence4)) @filter(uid(TaskOccurrenceAuth5))
      TaskOccurrenceAuth5 as var(func: uid(TaskOccurrence4)) @filter(eq(TaskOccurrence.role, "ADMINISTRATOR")) @cascade
    }

- name: "Deep RBAC rule - Level 0 false"
  gqlquery: |
    query {
      queryContact {
        id
        nickName
        adminTasks {
          id
          name
          occurrences {
            due
            comp
          }
        }
      }
    }
  jwtvar:
    ContactRole: User
    TaskRole: ADMINISTRATOR
    TaskOccuranceRole: ADMINISTRATOR
  dgquery: |-
    query {
      queryContact()
    }

- name: "Deep RBAC rule - Level 1 false"
  gqlquery: |
    query {
      queryContact {
        id
        nickName
        adminTasks {
          id
          name
          occurrences {
            due
            comp
          }
        }
      }
    }
  jwtvar:
    ContactRole: ADMINISTRATOR
    TaskRole: User
    TaskOccuranceRole: ADMINISTRATOR
  dgquery: |-
    query {
      queryContact(func: uid(ContactRoot)) {
        Contact.id : uid
        Contact.nickName : Contact.nickName
      }
      ContactRoot as var(func: uid(Contact6))
      Contact6 as var(func: type(Contact))
    }

- name: "Deep RBAC rule with cascade - Level 1 false"
  gqlquery: |
    query {
      queryContact @cascade {
        id
        nickName
        adminTasks {
          id
          name
          occurrences {
            due
            comp
          }
        }
      }
    }
  jwtvar:
    ContactRole: ADMINISTRATOR
    TaskRole: User
    TaskOccuranceRole: ADMINISTRATOR
  dgquery: |-
    query {
      queryContact(func: uid(ContactRoot)) @cascade {
        Contact.id : uid
        Contact.nickName : Contact.nickName
        Contact.adminTasks : Contact.adminTasks @filter(uid(AdminTask1)) {
          AdminTask.id : uid
          AdminTask.name : AdminTask.name
          AdminTask.occurrences : AdminTask.occurrences @filter(uid(TaskOccurrence3)) {
            TaskOccurrence.due : TaskOccurrence.due
            TaskOccurrence.comp : TaskOccurrence.comp
            dgraph.uid : uid
          }
        }
      }
      ContactRoot as var(func: uid(Contact7))
      Contact7 as var(func: type(Contact))
      var(func: uid(ContactRoot)) {
        AdminTask2 as Contact.adminTasks
      }
      AdminTask1 as var(func: uid(AdminTask2)) @filter(uid(AdminTask6))
      var(func: uid(AdminTask1)) {
        TaskOccurrence4 as AdminTask.occurrences
      }
      TaskOccurrence3 as var(func: uid(TaskOccurrence4)) @filter(uid(TaskOccurrenceAuth5))
      TaskOccurrenceAuth5 as var(func: uid(TaskOccurrence4)) @filter(eq(TaskOccurrence.role, "ADMINISTRATOR")) @cascade
      AdminTask6 as var(func: uid())
    }

- name: "Deep RBAC rule - Level 2 false"
  gqlquery: |
    query {
      queryContact {
        id
        nickName
        adminTasks {
          id
          name
          occurrences {
            due
            comp
          }
        }
      }
    }
  jwtvar:
    ContactRole: ADMINISTRATOR
    TaskRole: ADMINISTRATOR
    TaskOccuranceRole: User
  dgquery: |-
    query {
      queryContact(func: uid(ContactRoot)) {
        Contact.id : uid
        Contact.nickName : Contact.nickName
        Contact.adminTasks : Contact.adminTasks @filter(uid(AdminTask1)) {
          AdminTask.id : uid
          AdminTask.name : AdminTask.name
        }
      }
      ContactRoot as var(func: uid(Contact5))
      Contact5 as var(func: type(Contact))
      var(func: uid(ContactRoot)) {
        AdminTask2 as Contact.adminTasks
      }
      AdminTask1 as var(func: uid(AdminTask2))
    }

- name: "Deep RBAC rule - Level 1 type without auth."
  gqlquery: |
    query {
      queryContact {
        id
        nickName
        tasks {
          id
          name
          occurrences {
            due
            comp
          }
        }
      }
    }
  jwtvar:
    ContactRole: ADMINISTRATOR
    TaskRole: ADMINISTRATOR
    TaskOccuranceRole: ADMINISTRATOR
  dgquery: |-
    query {
      queryContact(func: uid(ContactRoot)) {
        Contact.id : uid
        Contact.nickName : Contact.nickName
        Contact.tasks : Contact.tasks @filter(uid(Task1)) {
          Task.id : uid
          Task.name : Task.name
          Task.occurrences : Task.occurrences @filter(uid(TaskOccurrence3)) {
            TaskOccurrence.due : TaskOccurrence.due
            TaskOccurrence.comp : TaskOccurrence.comp
            dgraph.uid : uid
          }
        }
      }
      ContactRoot as var(func: uid(Contact6))
      Contact6 as var(func: type(Contact))
      var(func: uid(ContactRoot)) {
        Task2 as Contact.tasks
      }
      Task1 as var(func: uid(Task2))
      var(func: uid(Task1)) {
        TaskOccurrence4 as Task.occurrences
      }
      TaskOccurrence3 as var(func: uid(TaskOccurrence4)) @filter(uid(TaskOccurrenceAuth5))
      TaskOccurrenceAuth5 as var(func: uid(TaskOccurrence4)) @filter(eq(TaskOccurrence.role, "ADMINISTRATOR")) @cascade
    }

- name: "Auth query with @dgraph pred."
  gqlquery: |
    query {
      queryStudent {
        email
      }
    }
  jwtvar:
    ROLE: "ADMIN"
    USER: "user1"
  dgquery: |-
    query {
      queryStudent(func: uid(StudentRoot)) {
        Student.email : IOw80vnV
        dgraph.uid : uid
      }
      StudentRoot as var(func: uid(Student1)) @filter(uid(StudentAuth2))
      Student1 as var(func: type(is7sowSm))
      StudentAuth2 as var(func: uid(Student1)) @filter(eq(IOw80vnV, "user1")) @cascade
    }

- name: "Auth query with @dgraph pred (Test RBAC)."
  gqlquery: |
    query {
      queryStudent {
        email
      }
    }
  jwtvar:
    ROLE: "USER"
    USER: "user1"
  dgquery: |-
    query {
      queryStudent()
    }

- name: "Auth with deep get query."
  gqlquery: |
    query {
      getProject(projID: "0x123") {
        projID
        columns {
          name
          colID
        }
      }
    }
  jwtvar:
    USER: "user1"
  dgquery: |-
    query {
      getProject(func: uid(ProjectRoot)) @filter(type(Project)) {
        Project.projID : uid
        Project.columns : Project.columns @filter(uid(Column1)) {
          Column.name : Column.name
          Column.colID : uid
        }
      }
      ProjectRoot as var(func: uid(Project4)) @filter(uid(ProjectAuth5))
      Project4 as var(func: uid(0x123))
      ProjectAuth5 as var(func: uid(Project4)) @cascade {
        Project.roles : Project.roles @filter(eq(Role.permission, "VIEW")) {
          Role.assignedTo : Role.assignedTo @filter(eq(User.username, "user1"))
        }
      }
      var(func: uid(ProjectRoot)) {
        Column2 as Project.columns
      }
      Column1 as var(func: uid(Column2)) @filter(uid(ColumnAuth3))
      ColumnAuth3 as var(func: uid(Column2)) @cascade {
        Column.inProject : Column.inProject {
          Project.roles : Project.roles @filter(eq(Role.permission, "VIEW")) {
            Role.assignedTo : Role.assignedTo @filter(eq(User.username, "user1"))
          }
        }
      }
    }

- name: "Auth with top level filter : query, no filter"
  gqlquery: |
    query {
      queryUserSecret {
        id
        ownedBy
      }
    }
  jwtvar:
    USER: "user1"
  dgquery: |-
    query {
      queryUserSecret(func: uid(UserSecretRoot)) {
        UserSecret.id : uid
        UserSecret.ownedBy : UserSecret.ownedBy
      }
      UserSecretRoot as var(func: uid(UserSecret1)) @filter(uid(UserSecretAuth2))
      UserSecret1 as var(func: type(UserSecret))
      UserSecretAuth2 as var(func: uid(UserSecret1)) @filter(eq(UserSecret.ownedBy, "user1")) @cascade
    }

- name: "Auth with Aggregate Root Query"
  gqlquery: |
    query {
      aggregateUserSecret {
        count
        aSecretMax
        aSecretMin
      }
    }
  jwtvar:
    USER: "user1"
  dgquery: |-
    query {
      aggregateUserSecret() {
        UserSecretAggregateResult.count : max(val(countVar))
        UserSecretAggregateResult.aSecretMax : max(val(aSecretVar))
        UserSecretAggregateResult.aSecretMin : min(val(aSecretVar))
      }
      var(func: uid(UserSecretRoot)) {
        countVar as count(uid)
        aSecretVar as UserSecret.aSecret
      }
      UserSecretRoot as var(func: uid(UserSecret1)) @filter(uid(UserSecretAuth2))
      UserSecret1 as var(func: type(UserSecret))
      UserSecretAuth2 as var(func: uid(UserSecret1)) @filter(eq(UserSecret.ownedBy, "user1")) @cascade
    }

- name: "Auth with top level filter : get"
  gqlquery: |
    query {
      getUserSecret(id: "0x123") {
        id
        ownedBy
      }
    }
  jwtvar:
    USER: "user1"
  dgquery: |-
    query {
      getUserSecret(func: uid(UserSecretRoot)) @filter(type(UserSecret)) {
        UserSecret.id : uid
        UserSecret.ownedBy : UserSecret.ownedBy
      }
      UserSecretRoot as var(func: uid(UserSecret1)) @filter(uid(UserSecretAuth2))
      UserSecret1 as var(func: uid(0x123))
      UserSecretAuth2 as var(func: uid(UserSecret1)) @filter(eq(UserSecret.ownedBy, "user1")) @cascade
    }

- name: "Auth with top level filter : query and filter"
  gqlquery: |
    query {
      queryUserSecret(filter: { ownedBy: { eq: "user2" }}) {
        id
        ownedBy
      }
    }
  jwtvar:
    USER: "user1"
  dgquery: |-
    query {
      queryUserSecret(func: uid(UserSecretRoot)) {
        UserSecret.id : uid
        UserSecret.ownedBy : UserSecret.ownedBy
      }
      UserSecretRoot as var(func: uid(UserSecret1)) @filter(uid(UserSecretAuth2))
      UserSecret1 as var(func: type(UserSecret)) @filter(eq(UserSecret.ownedBy, "user2"))
      UserSecretAuth2 as var(func: uid(UserSecret1)) @filter(eq(UserSecret.ownedBy, "user1")) @cascade
    }

- name: "Deep RBAC rules true"
  gqlquery: |
    query {
      queryUser {
        issues {
          id
        }
      }
    }
  jwtvar:
    ROLE: "ADMIN"
    USER: "user1"
  dgquery: |-
    query {
      queryUser(func: uid(UserRoot)) {
        User.issues : User.issues @filter(uid(Issue1)) {
          Issue.id : uid
        }
        dgraph.uid : uid
      }
      UserRoot as var(func: uid(User4))
      User4 as var(func: type(User))
      var(func: uid(UserRoot)) {
        Issue2 as User.issues
      }
      Issue1 as var(func: uid(Issue2)) @filter(uid(IssueAuth3))
      IssueAuth3 as var(func: uid(Issue2)) @cascade {
        Issue.owner : Issue.owner @filter(eq(User.username, "user1"))
      }
    }

- name: "Deep RBAC rules false"
  gqlquery: |
    query {
      queryUser {
        username
        issues {
          id
        }
      }
    }
  jwtvar:
    ROLE: "USER"
    USER: "user1"
  dgquery: |-
    query {
      queryUser(func: uid(UserRoot)) {
        User.username : User.username
        dgraph.uid : uid
      }
      UserRoot as var(func: uid(User3))
      User3 as var(func: type(User))
    }

- name: "Auth with top level AND rbac true"
  gqlquery: |
    query {
      queryIssue {
        msg
      }
    }
  jwtvar:
    ROLE: "ADMIN"
    USER: "user1"
  dgquery: |-
    query {
      queryIssue(func: uid(IssueRoot)) {
        Issue.msg : Issue.msg
        dgraph.uid : uid
      }
      IssueRoot as var(func: uid(Issue1)) @filter(uid(IssueAuth2))
      Issue1 as var(func: type(Issue))
      IssueAuth2 as var(func: uid(Issue1)) @cascade {
        Issue.owner : Issue.owner @filter(eq(User.username, "user1"))
      }
    }

- name: "Auth with complex rbac rules, true"
  gqlquery: |
    query {
      queryComplexLog {
        logs
      }
    }
  jwtvar:
    ROLE: "ADMIN"
    USER: "user1"
  dgquery: |-
    query {
      queryComplexLog(func: uid(ComplexLogRoot)) {
        ComplexLog.logs : ComplexLog.logs
        dgraph.uid : uid
      }
      ComplexLogRoot as var(func: uid(ComplexLog1))
      ComplexLog1 as var(func: type(ComplexLog))
    }

- name: "Auth with complex rbac rules, false"
  gqlquery: |
    query {
      queryComplexLog {
        logs
      }
    }
  jwtvar:
    ROLE: "USER"
    USER: "user1"
  dgquery: |-
    query {
      queryComplexLog()
    }

- name: "Auth with top level rbac true"
  gqlquery: |
    query {
      queryLog {
        logs
      }
    }
  jwtvar:
    ROLE: "ADMIN"
    USER: "user1"
  dgquery: |-
    query {
      queryLog(func: uid(LogRoot)) {
        Log.logs : Log.logs
        dgraph.uid : uid
      }
      LogRoot as var(func: uid(Log1))
      Log1 as var(func: type(Log))
    }

- name: "Auth with top level rbac false"
  gqlquery: |
    query {
      queryLog {
        logs
      }
    }
  jwtvar:
    ROLE: "USER"
    USER: "user1"
  dgquery: |-
    query {
      queryLog()
    }

- name: "Auth with top level AND rbac false"
  gqlquery: |
    query {
      queryIssue {
        msg
      }
    }
  jwtvar:
    ROLE: "USER"
    USER: "user1"
  dgquery: |-
    query {
      queryIssue()
    }

- name: "Aggregate Query on Auth with top level AND rbac false"
  gqlquery: |
    query {
      aggregateIssue {
        randomMin
        count
      }
    }
  jwtvar:
    ROLE: "USER"
    USER: "user1"
  dgquery: |-
    query {
      aggregateIssue()
    }

- name: "Auth with top level OR rbac true"
  gqlquery: |
    query {
      queryProject {
        name
      }
    }
  jwtvar:
    ROLE: "ADMIN"
    USER: "user1"
  dgquery: |-
    query {
      queryProject(func: uid(ProjectRoot)) {
        Project.name : Project.name
        dgraph.uid : uid
      }
      ProjectRoot as var(func: uid(Project1))
      Project1 as var(func: type(Project))
    }

- name: "Aggregate on Auth with top level OR rbac true"
  gqlquery: |
    query {
      aggregateProject {
        nameMin
        count
        randomMin
      }
    }
  jwtvar:
    ROLE: "ADMIN"
    USER: "user1"
  dgquery: |-
    query {
      aggregateProject() {
        ProjectAggregateResult.nameMin : min(val(nameVar))
        ProjectAggregateResult.count : max(val(countVar))
        ProjectAggregateResult.randomMin : min(val(randomVar))
      }
      var(func: uid(ProjectRoot)) {
        nameVar as Project.name
        countVar as count(uid)
        randomVar as Project.random
      }
      ProjectRoot as var(func: uid(Project1))
      Project1 as var(func: type(Project))
    }

- name: "Query with missing jwt variables"
  gqlquery: |
    query {
      queryGroup {
        id
      }
    }
  jwtvar:
    USER: "user1"
  dgquery: |-
    query {
      queryGroup(func: uid(GroupRoot)) {
        Group.id : uid
      }
      GroupRoot as var(func: uid(Group1)) @filter((uid(GroupAuth2) OR uid(GroupAuth3)))
      Group1 as var(func: type(Group))
      GroupAuth2 as var(func: uid(Group1)) @cascade {
        Group.users : Group.users @filter(eq(User.username, "user1"))
      }
      GroupAuth3 as var(func: uid(Group1)) @cascade {
        Group.createdBy : Group.createdBy @filter(eq(User.username, "user1"))
      }
    }

- name: "Auth with top level OR rbac false"
  gqlquery: |
    query {
      queryProject {
        name
      }
    }
  jwtvar:
    ROLE: "USER"
    USER: "user1"
  dgquery: |-
    query {
      queryProject(func: uid(ProjectRoot)) {
        Project.name : Project.name
        dgraph.uid : uid
      }
      ProjectRoot as var(func: uid(Project1)) @filter(uid(ProjectAuth2))
      Project1 as var(func: type(Project))
      ProjectAuth2 as var(func: uid(Project1)) @cascade {
        Project.roles : Project.roles @filter(eq(Role.permission, "VIEW")) {
          Role.assignedTo : Role.assignedTo @filter(eq(User.username, "user1"))
        }
      }
    }

- name: "Auth with top level filter : query, filter and order"
  gqlquery: |
    query {
      queryUserSecret(filter: { ownedBy: { eq: "user2" }}, order: {asc: aSecret}, first: 1) {
        id
        ownedBy
      }
    }
  jwtvar:
    USER: "user1"
  dgquery: |-
    query {
      queryUserSecret(func: uid(UserSecretRoot), orderasc: UserSecret.aSecret) {
        UserSecret.id : uid
        UserSecret.ownedBy : UserSecret.ownedBy
      }
      UserSecretRoot as var(func: uid(UserSecret1), orderasc: UserSecret.aSecret, first: 1) @filter(uid(UserSecretAuth2))
      UserSecret1 as var(func: type(UserSecret)) @filter(eq(UserSecret.ownedBy, "user2"))
      UserSecretAuth2 as var(func: uid(UserSecret1)) @filter(eq(UserSecret.ownedBy, "user1")) @cascade
    }

- name: "Auth with deep filter : query top-level"
  gqlquery: |
    query {
      queryTicket {
        id
        title
      }
    }
  jwtvar:
    USER: "user1"
  dgquery: |-
    query {
      queryTicket(func: uid(TicketRoot)) {
        Ticket.id : uid
        Ticket.title : Ticket.title
      }
      TicketRoot as var(func: uid(Ticket1)) @filter(uid(TicketAuth2))
      Ticket1 as var(func: type(Ticket))
      TicketAuth2 as var(func: uid(Ticket1)) @cascade {
        Ticket.onColumn : Ticket.onColumn {
          Column.inProject : Column.inProject {
            Project.roles : Project.roles @filter(eq(Role.permission, "VIEW")) {
              Role.assignedTo : Role.assignedTo @filter(eq(User.username, "user1"))
            }
          }
        }
      }
    }

- name: "Auth with deep filter : query deep requires auth"
  gqlquery: |
    query {
      queryUser {
        username
        tickets {
          id
          title
        }
      }
    }
  jwtvar:
    USER: "user1"
  dgquery: |-
    query {
      queryUser(func: uid(UserRoot)) {
        User.username : User.username
        User.tickets : User.tickets @filter(uid(Ticket1)) {
          Ticket.id : uid
          Ticket.title : Ticket.title
        }
        dgraph.uid : uid
      }
      UserRoot as var(func: uid(User4))
      User4 as var(func: type(User))
      var(func: uid(UserRoot)) {
        Ticket2 as User.tickets
      }
      Ticket1 as var(func: uid(Ticket2)) @filter(uid(TicketAuth3))
      TicketAuth3 as var(func: uid(Ticket2)) @cascade {
        Ticket.onColumn : Ticket.onColumn {
          Column.inProject : Column.inProject {
            Project.roles : Project.roles @filter(eq(Role.permission, "VIEW")) {
              Role.assignedTo : Role.assignedTo @filter(eq(User.username, "user1"))
            }
          }
        }
      }
    }

- name: "Auth with deep filter and field filter : query deep requires auth"
  gqlquery: |
    query {
      queryUser {
        username
        tickets(filter: { title: { anyofterms: "graphql" } }) {
          id
          title
        }
      }
    }
  jwtvar:
    USER: "user1"
  dgquery: |-
    query {
      queryUser(func: uid(UserRoot)) {
        User.username : User.username
        User.tickets : User.tickets @filter(uid(Ticket1)) {
          Ticket.id : uid
          Ticket.title : Ticket.title
        }
        dgraph.uid : uid
      }
      UserRoot as var(func: uid(User4))
      User4 as var(func: type(User))
      var(func: uid(UserRoot)) {
        Ticket2 as User.tickets @filter(anyofterms(Ticket.title, "graphql"))
      }
      Ticket1 as var(func: uid(Ticket2)) @filter(uid(TicketAuth3))
      TicketAuth3 as var(func: uid(Ticket2)) @cascade {
        Ticket.onColumn : Ticket.onColumn {
          Column.inProject : Column.inProject {
            Project.roles : Project.roles @filter(eq(Role.permission, "VIEW")) {
              Role.assignedTo : Role.assignedTo @filter(eq(User.username, "user1"))
            }
          }
        }
      }
    }

- name: "Auth deep query - 0 level"
  gqlquery: |
    query {
      queryMovie(filter: { content: { eq: "A. N. Author" } },  order: { asc: content }, first: 10, offset: 10)  {
        content
      }
    }
  jwtvar:
    USER: "user1"
  dgquery: |-
    query {
      queryMovie(func: uid(MovieRoot), orderasc: Movie.content) {
        Movie.content : Movie.content
        dgraph.uid : uid
      }
      MovieRoot as var(func: uid(Movie1), orderasc: Movie.content, first: 10, offset: 10) @filter((NOT (uid(MovieAuth2)) AND (uid(MovieAuth3) OR uid(MovieAuth4))))
      Movie1 as var(func: type(Movie)) @filter(eq(Movie.content, "A. N. Author"))
      MovieAuth2 as var(func: uid(Movie1)) @filter(eq(Movie.hidden, true)) @cascade
      MovieAuth3 as var(func: uid(Movie1)) @cascade {
        Movie.regionsAvailable : Movie.regionsAvailable {
          Region.users : Region.users @filter(eq(User.username, "user1"))
        }
      }
      MovieAuth4 as var(func: uid(Movie1)) @cascade {
        Movie.regionsAvailable : Movie.regionsAvailable @filter(eq(Region.global, true))
      }
    }

- name: "Auth deep query - 1 level"
  gqlquery: |
    query {
      queryMovie(filter: { content: { eq: "MovieXYZ" } },  order: { asc: content }, first: 10, offset: 10) @cascade  {
        content
        regionsAvailable(filter: { name: { eq: "Region123" } },  order: { asc: name }, first: 10, offset: 10) {
          name
          global
        }
      }
    }
  jwtvar:
    USER: "user1"
  dgquery: |-
    query {
      queryMovie(func: uid(MovieRoot), orderasc: Movie.content) @cascade {
        Movie.content : Movie.content
        Movie.regionsAvailable : Movie.regionsAvailable @filter(uid(Region1)) (orderasc: Region.name, first: 10, offset: 10) {
          Region.name : Region.name
          Region.global : Region.global
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
      MovieRoot as var(func: uid(Movie3), orderasc: Movie.content, first: 10, offset: 10) @filter((NOT (uid(MovieAuth4)) AND (uid(MovieAuth5) OR uid(MovieAuth6))))
      Movie3 as var(func: type(Movie)) @filter(eq(Movie.content, "MovieXYZ"))
      MovieAuth4 as var(func: uid(Movie3)) @filter(eq(Movie.hidden, true)) @cascade
      MovieAuth5 as var(func: uid(Movie3)) @cascade {
        Movie.regionsAvailable : Movie.regionsAvailable {
          Region.users : Region.users @filter(eq(User.username, "user1"))
        }
      }
      MovieAuth6 as var(func: uid(Movie3)) @cascade {
        Movie.regionsAvailable : Movie.regionsAvailable @filter(eq(Region.global, true))
      }
      var(func: uid(MovieRoot)) {
        Region2 as Movie.regionsAvailable @filter(eq(Region.name, "Region123"))
      }
      Region1 as var(func: uid(Region2))
    }

- name: "Auth deep query - 3 level"
  gqlquery: |
    query {
      queryMovie(filter: { content: { eq: "MovieXYZ" } },  order: { asc: content }, first: 10, offset: 10)  {
        content
        regionsAvailable(filter: { name: { eq: "Region123" } },  order: { asc: name }, first: 10, offset: 10) @cascade {
          name
          global
          users(filter: { username: { eq: "User321" } },  order: { asc: username }, first: 10, offset: 10)  {
            username
            age
            isPublic
            secrets(filter: { aSecret: { allofterms : "Secret132" } },  order: { asc: aSecret }, first: 10, offset: 10)  {
              aSecret
              ownedBy
            }
          }
        }
      }
    }
  jwtvar:
    USER: "user1"
  dgquery: |-
    query {
      queryMovie(func: uid(MovieRoot), orderasc: Movie.content) {
        Movie.content : Movie.content
        Movie.regionsAvailable : Movie.regionsAvailable @filter(uid(Region1)) (orderasc: Region.name, first: 10, offset: 10) @cascade {
          Region.name : Region.name
          Region.global : Region.global
          Region.users : Region.users @filter(uid(User3)) (orderasc: User.username, first: 10, offset: 10) {
            User.username : User.username
            User.age : User.age
            User.isPublic : User.isPublic
            User.secrets : User.secrets @filter(uid(UserSecret5)) (orderasc: UserSecret.aSecret, first: 10, offset: 10) {
              UserSecret.aSecret : UserSecret.aSecret
              UserSecret.ownedBy : UserSecret.ownedBy
              dgraph.uid : uid
            }
            dgraph.uid : uid
          }
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
      MovieRoot as var(func: uid(Movie8), orderasc: Movie.content, first: 10, offset: 10) @filter((NOT (uid(MovieAuth9)) AND (uid(MovieAuth10) OR uid(MovieAuth11))))
      Movie8 as var(func: type(Movie)) @filter(eq(Movie.content, "MovieXYZ"))
      MovieAuth9 as var(func: uid(Movie8)) @filter(eq(Movie.hidden, true)) @cascade
      MovieAuth10 as var(func: uid(Movie8)) @cascade {
        Movie.regionsAvailable : Movie.regionsAvailable {
          Region.users : Region.users @filter(eq(User.username, "user1"))
        }
      }
      MovieAuth11 as var(func: uid(Movie8)) @cascade {
        Movie.regionsAvailable : Movie.regionsAvailable @filter(eq(Region.global, true))
      }
      var(func: uid(MovieRoot)) {
        Region2 as Movie.regionsAvailable @filter(eq(Region.name, "Region123"))
      }
      Region1 as var(func: uid(Region2))
      var(func: uid(Region1)) {
        User4 as Region.users @filter(eq(User.username, "User321"))
      }
      User3 as var(func: uid(User4))
      var(func: uid(User3)) {
        UserSecret6 as User.secrets @filter(allofterms(UserSecret.aSecret, "Secret132"))
      }
      UserSecret5 as var(func: uid(UserSecret6)) @filter(uid(UserSecretAuth7))
      UserSecretAuth7 as var(func: uid(UserSecret6)) @filter(eq(UserSecret.ownedBy, "user1")) @cascade
    }

- name: "Auth with complex filter"
  gqlquery: |
    query {
      queryMovie {
        content
      }
    }
  jwtvar:
    USER: "user1"
  dgquery: |-
    query {
      queryMovie(func: uid(MovieRoot)) {
        Movie.content : Movie.content
        dgraph.uid : uid
      }
      MovieRoot as var(func: uid(Movie1)) @filter((NOT (uid(MovieAuth2)) AND (uid(MovieAuth3) OR uid(MovieAuth4))))
      Movie1 as var(func: type(Movie))
      MovieAuth2 as var(func: uid(Movie1)) @filter(eq(Movie.hidden, true)) @cascade
      MovieAuth3 as var(func: uid(Movie1)) @cascade {
        Movie.regionsAvailable : Movie.regionsAvailable {
          Region.users : Region.users @filter(eq(User.username, "user1"))
        }
      }
      MovieAuth4 as var(func: uid(Movie1)) @cascade {
        Movie.regionsAvailable : Movie.regionsAvailable @filter(eq(Region.global, true))
      }
    }

- name: "Aggregate Query with complex auth filter"
  gqlquery: |
    query {
      aggregateMovie {
        count
        contentMin
      }
    }
  jwtvar:
    USER: "user1"
  dgquery: |-
    query {
      aggregateMovie() {
        MovieAggregateResult.count : max(val(countVar))
        MovieAggregateResult.contentMin : min(val(contentVar))
      }
      var(func: uid(MovieRoot)) {
        countVar as count(uid)
        contentVar as Movie.content
      }
      MovieRoot as var(func: uid(Movie1)) @filter((NOT (uid(MovieAuth2)) AND (uid(MovieAuth3) OR uid(MovieAuth4))))
      Movie1 as var(func: type(Movie))
      MovieAuth2 as var(func: uid(Movie1)) @filter(eq(Movie.hidden, true)) @cascade
      MovieAuth3 as var(func: uid(Movie1)) @cascade {
        Movie.regionsAvailable : Movie.regionsAvailable {
          Region.users : Region.users @filter(eq(User.username, "user1"))
        }
      }
      MovieAuth4 as var(func: uid(Movie1)) @cascade {
        Movie.regionsAvailable : Movie.regionsAvailable @filter(eq(Region.global, true))
      }
    }

- name: "Query with missing variable - top level"
  gqlquery: |
    query {
      queryUserSecret {
        id
      }
    }
  dgquery: |-
    query {
      queryUserSecret()
    }

- name: "Query with null variable - top level"
  gqlquery: |
    query {
      queryUserSecret {
        id
      }
    }
  jwtVar:
    USER: null
  dgquery: |-
    query {
      queryUserSecret()
    }

- name:  "Get with top level RBAC false"
  gqlquery: |
    query {
      getLog(id: "0x123") {
        id
      }
    }
  jwtvar:
    USER: "user1"
  dgquery: |-
    query {
      getLog()
    }

- name: "Query with missing variable - deep query"
  gqlquery: |
    query {
      queryUser {
        username
        tickets {
          id
          title
        }
      }
    }
  dgquery: |-
    query {
      queryUser(func: uid(UserRoot)) {
        User.username : User.username
        dgraph.uid : uid
      }
      UserRoot as var(func: uid(User3))
      User3 as var(func: type(User))
    }

- name: "Query with null variable - deep query"
  gqlquery: |
    query {
      queryUser {
        username
        tickets {
          id
          title
        }
      }
    }
  jwtvar:
    USER: null
  dgquery: |-
    query {
      queryUser(func: uid(UserRoot)) {
        User.username : User.username
        dgraph.uid : uid
      }
      UserRoot as var(func: uid(User3))
      User3 as var(func: type(User))
    }

- name: "Query with missing variable - partial jwt token"
  gqlquery: |
    query {
      queryProject {
        name
      }
    }
  jwtvar:
    ROLE: "ADMIN"
  dgquery: |-
    query {
      queryProject(func: uid(ProjectRoot)) {
        Project.name : Project.name
        dgraph.uid : uid
      }
      ProjectRoot as var(func: uid(Project1))
      Project1 as var(func: type(Project))
    }

- name: "Query with missing jwt token - type without auth directive"
  gqlquery: |
    query {
      queryRole {
        permission
      }
    }
  dgquery: |-
    query {
      queryRole(func: type(Role)) {
        Role.permission : Role.permission
        dgraph.uid : uid
      }
    }

- name: "Query with missing jwt token - type with auth directive"
  gqlquery: |
    query {
      queryMovie {
        content
      }
    }
  dgquery: |-
    query {
      queryMovie(func: uid(MovieRoot)) {
        Movie.content : Movie.content
        dgraph.uid : uid
      }
      MovieRoot as var(func: uid(Movie1)) @filter((NOT (uid(MovieAuth2)) AND uid(MovieAuth3)))
      Movie1 as var(func: type(Movie))
      MovieAuth2 as var(func: uid(Movie1)) @filter(eq(Movie.hidden, true)) @cascade
      MovieAuth3 as var(func: uid(Movie1)) @cascade {
        Movie.regionsAvailable : Movie.regionsAvailable @filter(eq(Region.global, true))
      }
    }

- name: "Query with missing jwt token - type with empty auth directive"
  gqlquery: |
    query {
      queryReview {
        comment
      }
    }
  dgquery: |-
    query {
      queryReview(func: type(Review)) {
        Review.comment : Review.comment
        dgraph.uid : uid
      }
    }

- name: "Aggregate Fields at child with Auth deep filter and field filter"
  gqlquery: |
    query {
      queryUser {
        ticketsAggregate(filter: { title: { anyofterms: "graphql" } }) {
          count
          titleMin
          titleMax
        }
      }
    }
  jwtvar:
    USER: "user1"
  dgquery: |-
    query {
      queryUser(func: uid(UserRoot)) {
        User.ticketsAggregate : User.tickets @filter(uid(TicketAggregateResult1)) {
          User.ticketsAggregate_titleVar as Ticket.title
          dgraph.uid : uid
        }
        TicketAggregateResult.count_User.ticketsAggregate : count(User.tickets) @filter(uid(TicketAggregateResult1))
        TicketAggregateResult.titleMin_User.ticketsAggregate : min(val(User.ticketsAggregate_titleVar))
        TicketAggregateResult.titleMax_User.ticketsAggregate : max(val(User.ticketsAggregate_titleVar))
        dgraph.uid : uid
      }
      UserRoot as var(func: uid(User4))
      User4 as var(func: type(User))
      var(func: uid(UserRoot)) {
        TicketAggregateResult2 as User.tickets @filter(anyofterms(Ticket.title, "graphql"))
      }
      TicketAggregateResult1 as var(func: uid(TicketAggregateResult2)) @filter(uid(TicketAuth3))
      TicketAuth3 as var(func: uid(TicketAggregateResult2)) @cascade {
        Ticket.onColumn : Ticket.onColumn {
          Column.inProject : Column.inProject {
            Project.roles : Project.roles @filter(eq(Role.permission, "VIEW")) {
              Role.assignedTo : Role.assignedTo @filter(eq(User.username, "user1"))
            }
          }
        }
      }
    }

- name: "Multiple Aggregate queries at child level and other queries with Auth deep filter"
  gqlquery: |
    query {
      queryUser {
        ticketsAggregate(filter: { title: { anyofterms: "graphql" } }) {
          titleMin
        }
        issuesAggregate {
          count
          msgMax
        }
        tickets(filter: { title: { anyofterms: "graphql2" } }) {
          title
        }
      }
    }
  jwtvar:
    ROLE: "ADMIN"
    USER: "user1"
  dgquery: |-
    query {
      queryUser(func: uid(UserRoot)) {
        User.ticketsAggregate : User.tickets @filter(uid(TicketAggregateResult1)) {
          User.ticketsAggregate_titleVar as Ticket.title
          dgraph.uid : uid
        }
        TicketAggregateResult.titleMin_User.ticketsAggregate : min(val(User.ticketsAggregate_titleVar))
        User.issuesAggregate : User.issues @filter(uid(IssueAggregateResult4)) {
          User.issuesAggregate_msgVar as Issue.msg
          dgraph.uid : uid
        }
        IssueAggregateResult.count_User.issuesAggregate : count(User.issues) @filter(uid(IssueAggregateResult4))
        IssueAggregateResult.msgMax_User.issuesAggregate : max(val(User.issuesAggregate_msgVar))
        User.tickets : User.tickets @filter(uid(Ticket7)) {
          Ticket.title : Ticket.title
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
      UserRoot as var(func: uid(User10))
      User10 as var(func: type(User))
      var(func: uid(UserRoot)) {
        TicketAggregateResult2 as User.tickets @filter(anyofterms(Ticket.title, "graphql"))
      }
      TicketAggregateResult1 as var(func: uid(TicketAggregateResult2)) @filter(uid(TicketAuth3))
      TicketAuth3 as var(func: uid(TicketAggregateResult2)) @cascade {
        Ticket.onColumn : Ticket.onColumn {
          Column.inProject : Column.inProject {
            Project.roles : Project.roles @filter(eq(Role.permission, "VIEW")) {
              Role.assignedTo : Role.assignedTo @filter(eq(User.username, "user1"))
            }
          }
        }
      }
      var(func: uid(UserRoot)) {
        IssueAggregateResult5 as User.issues
      }
      IssueAggregateResult4 as var(func: uid(IssueAggregateResult5)) @filter(uid(IssueAuth6))
      IssueAuth6 as var(func: uid(IssueAggregateResult5)) @cascade {
        Issue.owner : Issue.owner @filter(eq(User.username, "user1"))
      }
      var(func: uid(UserRoot)) {
        Ticket8 as User.tickets @filter(anyofterms(Ticket.title, "graphql2"))
      }
      Ticket7 as var(func: uid(Ticket8)) @filter(uid(TicketAuth9))
      TicketAuth9 as var(func: uid(Ticket8)) @cascade {
        Ticket.onColumn : Ticket.onColumn {
          Column.inProject : Column.inProject {
            Project.roles : Project.roles @filter(eq(Role.permission, "VIEW")) {
              Role.assignedTo : Role.assignedTo @filter(eq(User.username, "user1"))
            }
          }
        }
      }
    }

- name: "Aggregate at child with RBAC rules true"
  gqlquery: |
    query {
      queryUser {
        issuesAggregate {
          count
          msgMin
        }
      }
    }
  jwtvar:
    ROLE: "ADMIN"
    USER: "user1"
  dgquery: |-
    query {
      queryUser(func: uid(UserRoot)) {
        User.issuesAggregate : User.issues @filter(uid(IssueAggregateResult1)) {
          User.issuesAggregate_msgVar as Issue.msg
          dgraph.uid : uid
        }
        IssueAggregateResult.count_User.issuesAggregate : count(User.issues) @filter(uid(IssueAggregateResult1))
        IssueAggregateResult.msgMin_User.issuesAggregate : min(val(User.issuesAggregate_msgVar))
        dgraph.uid : uid
      }
      UserRoot as var(func: uid(User4))
      User4 as var(func: type(User))
      var(func: uid(UserRoot)) {
        IssueAggregateResult2 as User.issues
      }
      IssueAggregateResult1 as var(func: uid(IssueAggregateResult2)) @filter(uid(IssueAuth3))
      IssueAuth3 as var(func: uid(IssueAggregateResult2)) @cascade {
        Issue.owner : Issue.owner @filter(eq(User.username, "user1"))
      }
    }

- name: "Aggregate Fields with Deep RBAC rules false"
  gqlquery: |
    query {
      queryUser {
        username
        issuesAggregate {
          count
          msgMin
        }
      }
    }
  jwtvar:
    ROLE: "USER"
    USER: "user1"
  dgquery: |-
    query {
      queryUser(func: uid(UserRoot)) {
        User.username : User.username
        dgraph.uid : uid
      }
      UserRoot as var(func: uid(User1))
      User1 as var(func: type(User))
    }

- name: "Type should apply Interface's query rules and along with its own auth rules"
  gqlquery: |
    query {
      queryQuestion {
        id
        text
      }
    }
  jwtvar:
    ANS: "true"
    USER: "Random"
  dgquery: |-
    query {
      queryQuestion(func: uid(QuestionRoot)) {
        Question.id : uid
        Question.text : Post.text
      }
      QuestionRoot as var(func: uid(Question1)) @filter((uid(QuestionAuth2) AND uid(QuestionAuth3)))
      Question1 as var(func: type(Question))
      QuestionAuth2 as var(func: uid(Question1)) @filter(eq(Question.answered, true)) @cascade {
        Question.id : uid
      }
      QuestionAuth3 as var(func: uid(Question1)) @cascade {
        dgraph.type
        Post.author : Post.author @filter(eq(Author.name, "Random")) {
          Author.name : Author.name
        }
      }
    }

- name: "Type should apply only Interface's query auth rules"
  gqlquery: |
    query {
      queryAnswer {
        id
        text
      }
    }
  jwtvar:
    USER: "Random"
  dgquery: |-
    query {
      queryAnswer(func: uid(AnswerRoot)) {
        Answer.id : uid
        Answer.text : Post.text
      }
      AnswerRoot as var(func: uid(Answer1)) @filter(uid(AnswerAuth2))
      Answer1 as var(func: type(Answer))
      AnswerAuth2 as var(func: uid(Answer1)) @cascade {
        dgraph.type
        Post.author : Post.author @filter(eq(Author.name, "Random")) {
          Author.name : Author.name
        }
      }
    }

- name: "Type should apply query auth rules from all the interfaces that it implements."
  gqlquery: |
    query {
      queryFbPost {
        id
        postCount
      }
    }
  jwtvar:
    ROLE: "ADMIN"
    USER: "Random"
  dgquery: |-
    query {
      queryFbPost(func: uid(FbPostRoot)) {
        FbPost.id : uid
        FbPost.postCount : FbPost.postCount
      }
      FbPostRoot as var(func: uid(FbPost1)) @filter(uid(FbPostAuth2))
      FbPost1 as var(func: type(FbPost))
      FbPostAuth2 as var(func: uid(FbPost1)) @cascade {
        dgraph.type
        Post.author : Post.author @filter(eq(Author.name, "Random")) {
          Author.name : Author.name
        }
      }
    }

- name: "Type which inherits auth rules from interfaces returns no results when auth rules fail"
  gqlquery: |
    query {
      queryFbPost {
        id
        postCount
      }
    }
  jwtvar:
    ROLE: "REGULAR"
    USER: "Random"
  dgquery: |-
    query {
      queryFbPost()
    }

- name: "Auth rules of All the implementing types should Apply to the interface also"
  gqlquery: |
    query {
      queryPost {
        text
      }
    }
  jwtvar:
    ROLE: "ADMIN"
    ANS:  "true"
    USER: "Random"
  dgquery: |-
    query {
      queryPost(func: uid(PostRoot)) {
        dgraph.type
        Post.text : Post.text
        dgraph.uid : uid
      }
      PostRoot as var(func: uid(Post1)) @filter(((uid(QuestionAuth2) AND uid(QuestionAuth3)) OR uid(FbPostAuth4) OR uid(AnswerAuth5)))
      Post1 as var(func: type(Post))
      Question1 as var(func: type(Question))
      QuestionAuth2 as var(func: uid(Question1)) @filter(eq(Question.answered, true)) @cascade {
        Question.id : uid
      }
      QuestionAuth3 as var(func: uid(Question1)) @cascade {
        dgraph.type
        Post.author : Post.author @filter(eq(Author.name, "Random")) {
          Author.name : Author.name
        }
      }
      FbPost1 as var(func: type(FbPost))
      FbPostAuth4 as var(func: uid(FbPost1)) @cascade {
        dgraph.type
        Post.author : Post.author @filter(eq(Author.name, "Random")) {
          Author.name : Author.name
        }
      }
      Answer1 as var(func: type(Answer))
      AnswerAuth5 as var(func: uid(Answer1)) @cascade {
        dgraph.type
        Post.author : Post.author @filter(eq(Author.name, "Random")) {
          Author.name : Author.name
        }
      }
    }

- name: "Filters on query Interface should work correctly"
  gqlquery: |
    query {
      queryPost(filter: {text: {eq: "A Post"}}, order: { desc: text}, first: 10, offset: 5 ) {
        text
      }
    }
  jwtvar:
    ROLE: "ADMIN"
    ANS:  "true"
    USER: "Random"
  dgquery: |-
    query {
      queryPost(func: uid(PostRoot), orderdesc: Post.text) {
        dgraph.type
        Post.text : Post.text
        dgraph.uid : uid
      }
      PostRoot as var(func: uid(Post1), orderdesc: Post.text, first: 10, offset: 5) @filter(((uid(QuestionAuth2) AND uid(QuestionAuth3)) OR uid(FbPostAuth4) OR uid(AnswerAuth5)))
      Post1 as var(func: type(Post)) @filter(eq(Post.text, "A Post"))
      Question1 as var(func: type(Question))
      QuestionAuth2 as var(func: uid(Question1)) @filter(eq(Question.answered, true)) @cascade {
        Question.id : uid
      }
      QuestionAuth3 as var(func: uid(Question1)) @cascade {
        dgraph.type
        Post.author : Post.author @filter(eq(Author.name, "Random")) {
          Author.name : Author.name
        }
      }
      FbPost1 as var(func: type(FbPost))
      FbPostAuth4 as var(func: uid(FbPost1)) @cascade {
        dgraph.type
        Post.author : Post.author @filter(eq(Author.name, "Random")) {
          Author.name : Author.name
        }
      }
      Answer1 as var(func: type(Answer))
      AnswerAuth5 as var(func: uid(Answer1)) @cascade {
        dgraph.type
        Post.author : Post.author @filter(eq(Author.name, "Random")) {
          Author.name : Author.name
        }
      }
    }

- name: "Query interface should return empty if the auth rule of interface is not satisfied"
  gqlquery: |
    query {
      queryPost {
        text
      }
    }
  jwtvar:
    ROLE: "ADMIN"
    ANS: "true"
  dgquery: |-
    query {
      queryPost()
    }

- name: "Query interface should return partial types if the auth rule of interface is not satisfied"
  gqlquery: |
    query {
      queryPost {
        text
      }
    }
  jwtvar:
    USER: "Random"
    ANS: "true"
  dgquery: |-
    query {
      queryPost(func: uid(PostRoot)) {
        dgraph.type
        Post.text : Post.text
        dgraph.uid : uid
      }
      PostRoot as var(func: uid(Post1)) @filter(((uid(QuestionAuth2) AND uid(QuestionAuth3)) OR uid(AnswerAuth4)))
      Post1 as var(func: type(Post))
      Question1 as var(func: type(Question))
      QuestionAuth2 as var(func: uid(Question1)) @filter(eq(Question.answered, true)) @cascade {
        Question.id : uid
      }
      QuestionAuth3 as var(func: uid(Question1)) @cascade {
        dgraph.type
        Post.author : Post.author @filter(eq(Author.name, "Random")) {
          Author.name : Author.name
        }
      }
      Answer1 as var(func: type(Answer))
      AnswerAuth4 as var(func: uid(Answer1)) @cascade {
        dgraph.type
        Post.author : Post.author @filter(eq(Author.name, "Random")) {
          Author.name : Author.name
        }
      }
    }

- name: "Get Query interface having Auth Rules apply Auth filters of types also"
  gqlquery: |
    query {
      getPost(id: "0x1") {
        text
      }
    }
  jwtvar:
    USER: "Random"
    ANS: "true"
  dgquery: |-
    query {
      getPost(func: uid(PostRoot)) @filter(type(Post)) {
        dgraph.type
        Post.text : Post.text
        dgraph.uid : uid
      }
      PostRoot as var(func: uid(Post1)) @filter(((uid(QuestionAuth2) AND uid(QuestionAuth3)) OR uid(AnswerAuth4)))
      Post1 as var(func: uid(0x1))
      Question1 as var(func: type(Question))
      QuestionAuth2 as var(func: uid(Question1)) @filter(eq(Question.answered, true)) @cascade {
        Question.id : uid
      }
      QuestionAuth3 as var(func: uid(Question1)) @cascade {
        dgraph.type
        Post.author : Post.author @filter(eq(Author.name, "Random")) {
          Author.name : Author.name
        }
      }
      Answer1 as var(func: type(Answer))
      AnswerAuth4 as var(func: uid(Answer1)) @cascade {
        dgraph.type
        Post.author : Post.author @filter(eq(Author.name, "Random")) {
          Author.name : Author.name
        }
      }
    }

- name: "Get Query interface having Auth Rules should return empty if the Auth rules are not satisfied"
  gqlquery: |
    query {
      getPost(id: "0x1") {
        text
      }
    }
  jwtvar:
  dgquery: |-
    query {
      getPost()
    }

- name: "Query interface having no Auth Rules should apply auth rules on implementing types that are satisfied"
  gqlquery: |
    query {
      queryA {
        fieldA
      }
    }
  jwtvar:
    ANS: "true"
  dgquery: |-
    query {
      queryA(func: uid(ARoot)) {
        dgraph.type
        A.fieldA : A.fieldA
        dgraph.uid : uid
      }
      ARoot as var(func: uid(A1)) @filter((uid(B1) OR uid(CAuth2)))
      A1 as var(func: type(A))
      B1 as var(func: type(B))
      C1 as var(func: type(C))
      CAuth2 as var(func: uid(C1)) @filter(eq(C.fieldC, true)) @cascade {
        C.id : uid
      }
    }

- name: "Query interface having no Auth Rules but some type have Auth rules and those are not satified are excluded (for eg: type C )"
  gqlquery: |
    query {
      queryA {
        fieldA
      }
    }
  jwtvar:
  dgquery: |-
    query {
      queryA(func: uid(ARoot)) {
        dgraph.type
        A.fieldA : A.fieldA
        dgraph.uid : uid
      }
      ARoot as var(func: uid(A1)) @filter((uid(B1)))
      A1 as var(func: type(A))
      B1 as var(func: type(B))
    }

-
  name: "Password Query with no rule applied for password"
  gqlquery: |
    query {
      checkUserPassword(username: "user", password: "Password") {
        username
      }
    }
  dgquery: |-
    query {
      checkUserPassword(func: eq(User.username, "user")) @filter((eq(val(pwd), 1) AND type(User))) {
        User.username : User.username
        dgraph.uid : uid
      }
      checkPwd(func: eq(User.username, "user")) @filter(type(User)) {
        pwd as checkpwd(User.password, "Password")
      }
    }

-
  name: "Password Query with RBAC rule true"
  gqlquery: |
    query {
      checkLogPassword(id: "0x123", pwd: "something") {
        id
        logs
        random
      }
    }
  jwtvar:
    ROLE: "Admin"
  dgquery: |-
    query {
      checkLogPassword(func: uid(LogRoot)) @filter((eq(val(pwd), 1) AND type(Log))) {
        Log.id : uid
        Log.logs : Log.logs
        Log.random : Log.random
      }
      LogRoot as var(func: uid(Log1))
      Log1 as var(func: uid(0x123))
      checkPwd(func: uid(LogRoot)) @filter(type(Log)) {
        pwd as checkpwd(Log.pwd, "something")
      }
    }

-
  name: "Password Query with RBAC rule false"
  gqlquery: |
    query {
      checkLogPassword(id: "0x123", pwd: "something") {
        logs
        random
      }
    }
  jwtvar:
    ROLE: "User"
  dgquery: |-
    query {
      checkLogPassword()
    }

-
  name: "Password Query with auth rules"
  gqlquery: |
    query {
      checkProjectPassword(projID: "0x123", pwd: "something") {
        name
        projID
        columns {
          name
          colID
        }
      }
    }
  jwtvar:
    USER: "user1"
  dgquery: |-
    query {
      checkProjectPassword(func: uid(ProjectRoot)) @filter((eq(val(pwd), 1) AND type(Project))) {
        Project.name : Project.name
        Project.projID : uid
        Project.columns : Project.columns @filter(uid(Column1)) {
          Column.name : Column.name
          Column.colID : uid
        }
      }
      ProjectRoot as var(func: uid(Project4)) @filter(uid(ProjectAuth5))
      Project4 as var(func: uid(0x123))
      ProjectAuth5 as var(func: uid(Project4)) @cascade {
        Project.roles : Project.roles @filter(eq(Role.permission, "EDIT")) {
          Role.assignedTo : Role.assignedTo @filter(eq(User.username, "user1"))
        }
      }
      var(func: uid(ProjectRoot)) {
        Column2 as Project.columns
      }
      Column1 as var(func: uid(Column2)) @filter(uid(ColumnAuth3))
      ColumnAuth3 as var(func: uid(Column2)) @cascade {
        Column.inProject : Column.inProject {
          Project.roles : Project.roles @filter(eq(Role.permission, "VIEW")) {
            Role.assignedTo : Role.assignedTo @filter(eq(User.username, "user1"))
          }
        }
      }
      checkPwd(func: uid(ProjectRoot)) @filter(type(Project)) {
        pwd as checkpwd(Project.pwd, "something")
      }
    }

- name: "Type with password query should apply Interface's password rules and along with its own auth rules"
  gqlquery: |
    query {
      checkQuestionPassword(id: "0x123", pwd: "something") {
        id
        text
      }
    }
  jwtvar:
    ROLE: "Admin"
    ANS: "true"
    USER: "ADMIN"
  dgquery: |-
    query {
      checkQuestionPassword(func: uid(QuestionRoot)) @filter((eq(val(pwd), 1) AND type(Question))) {
        Question.id : uid
        Question.text : Post.text
      }
      QuestionRoot as var(func: uid(Question1)) @filter(uid(QuestionAuth2))
      Question1 as var(func: uid(0x123))
      QuestionAuth2 as var(func: uid(Question1)) @filter(eq(Question.answered, true)) @cascade {
        Question.id : uid
        Question.text : Post.text
      }
      checkPwd(func: uid(QuestionRoot)) @filter(type(Question)) {
        pwd as checkpwd(Question.pwd, "something")
      }
    }

- name: "Type which inherits password auth rules from interfaces returns no results when auth rules fail"
  gqlquery: |
    query {
      checkQuestionPassword(id: "0x123", pwd: "something") {
        id
        text
      }
    }
  jwtvar:
    ROLE: "NotAdmin"
    ANS: "true"
    USER: "ADMIN"
  dgquery: |-
    query {
      checkQuestionPassword()
    }

- name: "Password Auth rules of All the implementing types should Apply to the interface also"
  gqlquery: |
    query {
      checkPostPassword(id: "0x123", pwd: "something") {
        text
      }
    }
  jwtvar:
    ROLE: "Admin"
    ANS: "true"
    USER: "ADMIN"
  dgquery: |-
    query {
      checkPostPassword(func: uid(PostRoot)) @filter((eq(val(pwd), 1) AND type(Post))) {
        dgraph.type
        Post.text : Post.text
        dgraph.uid : uid
      }
      PostRoot as var(func: uid(Post1)) @filter((uid(QuestionAuth2) OR uid(FbPostAuth3) OR uid(Answer1)))
      Post1 as var(func: uid(0x123))
      Question1 as var(func: type(Question))
      QuestionAuth2 as var(func: uid(Question1)) @filter(eq(Question.answered, true)) @cascade {
        Question.id : uid
        Question.text : Post.text
      }
      FbPost1 as var(func: type(FbPost))
      FbPostAuth3 as var(func: uid(FbPost1)) @cascade {
        FbPost.author : Post.author @filter(eq(Author.name, "ADMIN")) {
          Author.name : Author.name
        }
      }
      Answer1 as var(func: type(Answer))
      checkPwd(func: uid(PostRoot)) @filter(type(Post)) {
        pwd as checkpwd(Post.pwd, "something")
      }
    }

- name: "Entities query with query auth rules"
  gqlquery: |
    query {
      _entities(representations: [{__typename: "Mission", id: "0x1"}{__typename: "Mission", id: "0x2"}, {__typename: "Mission", id: "0x3"}]) {
        ... on Mission {
          id
          designation
          startDate
        }
      }
    }
  jwtvar:
    USER: "user"
  dgquery: |-
    query {
      _entities(func: uid(_EntityRoot)) {
        dgraph.type
        Mission.id : Mission.id
        Mission.designation : Mission.designation
        Mission.startDate : Mission.startDate
        dgraph.uid : uid
      }
      _EntityRoot as var(func: uid(Mission1)) @filter(uid(MissionAuth2))
      Mission1 as var(func: eq(Mission.id, "0x1", "0x2", "0x3")) @filter(type(Mission))
      MissionAuth2 as var(func: uid(Mission1)) @filter(eq(Mission.supervisorName, "user")) @cascade {
        Mission.id : Mission.id
      }
    }
- name: "Entities query with top level RBAC rule true and level 1 query auth rule"
  gqlquery: |
    query {
      _entities(representations: [{__typename: "Astronaut", id: "0x1"},{__typename: "Astronaut", id: "0x2"},{__typename: "Astronaut", id: "0x3"}]) {
        ... on Astronaut {
          missions {
            designation
          }
        }
      }
    }
  jwtvar:
    ROLE: "admin"
    USER: "user"
  dgquery: |-
    query {
      _entities(func: uid(_EntityRoot)) {
        dgraph.type
        Astronaut.missions : Astronaut.missions @filter(uid(Mission1)) {
          Mission.designation : Mission.designation
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
      _EntityRoot as var(func: uid(Astronaut4))
      Astronaut4 as var(func: eq(Astronaut.id, "0x1", "0x2", "0x3")) @filter(type(Astronaut))
      var(func: uid(_EntityRoot)) {
        Mission2 as Astronaut.missions
      }
      Mission1 as var(func: uid(Mission2)) @filter(uid(MissionAuth3))
      MissionAuth3 as var(func: uid(Mission2)) @filter(eq(Mission.supervisorName, "user")) @cascade {
        Mission.id : Mission.id
      }
    }

- name: "Entities query with RBAC rule false"
  gqlquery: |
    query {
      _entities(representations: [{__typename: "Astronaut", id: "0x1"},{__typename: "Astronaut", id: "0x2"},{__typename: "Astronaut", id: "0x3"}]) {
        ... on Astronaut {
          missions {
            designation
          }
        }
      }
    }
  jwtvar:
    ROLE: "user"
  dgquery: |-
    query {
      _entities()
    }

- name: "Entities query with top RBAC rules true and missing JWT variable for level 1 query auth rule"
  gqlquery: |
    query {
      _entities(representations: [{__typename: "Astronaut", id: "0x1"},{__typename: "Astronaut", id: "0x2"},{__typename: "Astronaut", id: "0x3"}]) {
        ... on Astronaut {
          missions {
            designation
          }
        }
      }
    }
  jwtvar:
    ROLE: "admin"
  dgquery: |-
    query {
      _entities(func: uid(_EntityRoot)) {
        dgraph.type
        dgraph.uid : uid
      }
      _EntityRoot as var(func: uid(Astronaut3))
      Astronaut3 as var(func: eq(Astronaut.id, "0x1", "0x2", "0x3")) @filter(type(Astronaut))
    }

-
  name: "Query interface should return all the nodes of a type if rbac rules of type are true"
  gqlquery: |
    query {
      queryVehicle{
        owner
      }
    }
  jwtvar:
    ROLE: "ADMIN"
    USER: "user"
  dgquery: |-
    query {
      queryVehicle(func: uid(VehicleRoot)) {
        dgraph.type
        Vehicle.owner : Vehicle.owner
        dgraph.uid : uid
      }
      VehicleRoot as var(func: uid(Vehicle1)) @filter((uid(Car1)))
      Vehicle1 as var(func: type(Vehicle))
      Car1 as var(func: type(Car))
    }
