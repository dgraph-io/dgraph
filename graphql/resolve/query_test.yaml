-
  name: "in filter on string type"
  gqlquery: |
    query {
      queryState(filter: {code: {in: ["abc", "def", "ghi"]}}) {
        code
        name
      }
    }
  dgquery: |-
    query {
      queryState(func: type(State)) @filter(eq(State.code, "abc", "def", "ghi")) {
        code : State.code
        name : State.name
        dgraph.uid : uid
      }
    }

-
  name: "in filter on enum type"
  gqlquery: |
    query{
      queryVerification(filter: {status: {in: [ACTIVE, DEACTIVATED]}}){
        name
        status
      }
    }
  dgquery: |-
    query {
      queryVerification(func: type(Verification)) @filter(eq(Verification.status, "ACTIVE", "DEACTIVATED")) {
        name : Verification.name
        status : Verification.status
        dgraph.uid : uid
      }
    }
-
  name: "Point query near filter"
  gqlquery: |
    query {
      queryHotel(filter: { location: { near: { distance: 33.33, coordinate: { latitude: 11.11, longitude: 22.22} } } }) {
        name
        location {
          latitude
          longitude
        }
      }
    }
  dgquery: |-
    query {
      queryHotel(func: type(Hotel)) @filter(near(Hotel.location, [22.22,11.11], 33.33)) {
        name : Hotel.name
        location : Hotel.location
        dgraph.uid : uid
      }
    }

-
  name: "Point query within filter"
  gqlquery: |
    query {
      queryHotel(filter: { location: { within: { polygon: { coordinates: [ { points: [{ latitude: 11.11, longitude: 22.22}, { latitude: 15.15, longitude: 16.16} , { latitude: 20.20, longitude: 21.21} ]}, { points: [{ latitude: 11.18, longitude: 22.28}, { latitude: 15.18, longitude: 16.18} , { latitude: 20.28, longitude: 21.28}]} ] } } } }) {
        name
        location {
          latitude
          longitude
        }
      }
    }
  dgquery: |-
    query {
      queryHotel(func: type(Hotel)) @filter(within(Hotel.location, [[[22.22,11.11],[16.16,15.15],[21.21,20.2]],[[22.28,11.18],[16.18,15.18],[21.28,20.28]]])) {
        name : Hotel.name
        location : Hotel.location
        dgraph.uid : uid
      }
    }

-
  name: "Polygon query near filter"
  gqlquery: |
    query {
      queryHotel(filter: { area: { near: { distance: 33.33, coordinate: { latitude: 11.11, longitude: 22.22} } } }) {
        name
        area {
          coordinates {
            points {
              latitude
              longitude
            }
          }
        }
      }
    }
  dgquery: |-
    query {
      queryHotel(func: type(Hotel)) @filter(near(Hotel.area, [22.22,11.11], 33.33)) {
        name : Hotel.name
        area : Hotel.area
        dgraph.uid : uid
      }
    }

-
  name: "Polygon query within filter"
  gqlquery: |
    query {
      queryHotel(filter: { area: { within: { polygon: { coordinates: [ { points: [{ latitude: 11.11, longitude: 22.22}, { latitude: 15.15, longitude: 16.16} , { latitude: 20.20, longitude: 21.21} ]}, { points: [{ latitude: 11.18, longitude: 22.28}, { latitude: 15.18, longitude: 16.18} , { latitude: 20.28, longitude: 21.28}]} ] } } } }) {
        name
        area {
          coordinates {
            points {
              latitude
              longitude
            }
          }
        }
      }
    }
  dgquery: |-
    query {
      queryHotel(func: type(Hotel)) @filter(within(Hotel.area, [[[22.22,11.11],[16.16,15.15],[21.21,20.2]],[[22.28,11.18],[16.18,15.18],[21.28,20.28]]])) {
        name : Hotel.name
        area : Hotel.area
        dgraph.uid : uid
      }
    }

-
  name: "Polygon query contains polygon filter"
  gqlquery: |
    query {
      queryHotel(filter: { area: { contains: { polygon: { coordinates: [ { points: [{ latitude: 11.11, longitude: 22.22}, { latitude: 15.15, longitude: 16.16} , { latitude: 20.20, longitude: 21.21} ]}, { points: [{ latitude: 11.18, longitude: 22.28}, { latitude: 15.18, longitude: 16.18} , { latitude: 20.28, longitude: 21.28}]} ] } } } }) {
        name
        area {
          coordinates {
            points {
              latitude
              longitude
            }
          }
        }
      }
    }
  dgquery: |-
    query {
      queryHotel(func: type(Hotel)) @filter(contains(Hotel.area, [[[22.22,11.11],[16.16,15.15],[21.21,20.2]],[[22.28,11.18],[16.18,15.18],[21.28,20.28]]])) {
        name : Hotel.name
        area : Hotel.area
        dgraph.uid : uid
      }
    }

-
  name: "Polygon query contains point filter"
  gqlquery: |
    query {
      queryHotel(filter: { area: { contains: { point: { latitude: 11.11, longitude: 22.22}} } }) {
        name
        area {
          coordinates {
            points {
              latitude
              longitude
            }
          }
        }
      }
    }
  dgquery: |-
    query {
      queryHotel(func: type(Hotel)) @filter(contains(Hotel.area, [22.22,11.11])) {
        name : Hotel.name
        area : Hotel.area
        dgraph.uid : uid
      }
    }

-
  name: "Polygon query intersect polygon filter"
  gqlquery: |
    query {
      queryHotel(filter: {
        area: {
          intersects: {
            polygon: {
              coordinates: [{
                points: [{
                  latitude: 11.11,
                  longitude: 22.22
                }, {
                  latitude: 15.15,
                  longitude: 16.16
                }, {
                  latitude: 20.20,
                  longitude: 21.21
                }]
              }, {
                points: [{
                  latitude: 11.18,
                  longitude: 22.28
                }, {
                  latitude: 15.18,
                  longitude: 16.18
                }, {
                  latitude: 20.28,
                  longitude: 21.28
                }]
              }]
            }
          }
        }
      }) {
        name
        area {
          coordinates {
            points {
              latitude
              longitude
            }
          }
        }
      }
    }
  dgquery: |-
    query {
      queryHotel(func: type(Hotel)) @filter(intersects(Hotel.area, [[[22.22,11.11],[16.16,15.15],[21.21,20.2]],[[22.28,11.18],[16.18,15.18],[21.28,20.28]]])) {
        name : Hotel.name
        area : Hotel.area
        dgraph.uid : uid
      }
    }

-
  name: "Polygon query intersect multi-polygon filter"
  gqlquery: |
    query {
      queryHotel(filter: {
        area: {
          intersects: {
            multiPolygon: {
              polygons: [{
                coordinates: [{
                  points: [{
                    latitude: 11.11,
                    longitude: 22.22
                  }, {
                    latitude: 15.15,
                    longitude: 16.16
                  }, {
                    latitude: 20.20,
                    longitude: 21.21
                  }]
                }, {
                  points: [{
                    latitude: 11.18,
                    longitude: 22.28
                  }, {
                    latitude: 15.18,
                    longitude: 16.18
                  }, {
                    latitude: 20.28,
                    longitude: 21.28
                  }]
                }]
              }, {
                coordinates: [{
                  points: [{
                    latitude: 91.11,
                    longitude: 92.22
                  }, {
                    latitude: 15.15,
                    longitude: 16.16
                  }, {
                    latitude: 20.20,
                    longitude: 21.21
                  }]
                }, {
                  points: [{
                    latitude: 11.18,
                    longitude: 22.28
                  }, {
                    latitude: 15.18,
                    longitude: 16.18
                  }, {
                    latitude: 20.28,
                    longitude: 21.28
                  }]
                }]
              }]
            }
          }
        }
      }) {
        name
        area {
          coordinates {
            points {
              latitude
              longitude
            }
          }
        }
      }
    }
  dgquery: |-
    query {
      queryHotel(func: type(Hotel)) @filter(intersects(Hotel.area, [[[[22.22,11.11],[16.16,15.15],[21.21,20.2]],[[22.28,11.18],[16.18,15.18],[21.28,20.28]]],[[[92.22,91.11],[16.16,15.15],[21.21,20.2]],[[22.28,11.18],[16.18,15.18],[21.28,20.28]]]])) {
        name : Hotel.name
        area : Hotel.area
        dgraph.uid : uid
      }
    }

-
  name: "MultiPolygon query near filter"
  gqlquery: |
    query {
      queryHotel(filter: { branches: { near: { distance: 33.33, coordinate: { latitude: 11.11, longitude: 22.22} } } }) {
        name
        branches {
          polygons {
            coordinates {
              points {
                latitude
                longitude
              }
            }
          }
        }
      }
    }
  dgquery: |-
    query {
      queryHotel(func: type(Hotel)) @filter(near(Hotel.branches, [22.22,11.11], 33.33)) {
        name : Hotel.name
        branches : Hotel.branches
        dgraph.uid : uid
      }
    }

-
  name: "MultiPolygon query within filter"
  gqlquery: |
    query {
      queryHotel(filter: { branches: { within: { polygon: { coordinates: [ { points: [{ latitude: 11.11, longitude: 22.22}, { latitude: 15.15, longitude: 16.16} , { latitude: 20.20, longitude: 21.21} ]}, { points: [{ latitude: 11.18, longitude: 22.28}, { latitude: 15.18, longitude: 16.18} , { latitude: 20.28, longitude: 21.28}]} ] } } } }) {
        name
        branches {
          polygons {
            coordinates {
              points {
                latitude
                longitude
              }
            }
          }
        }
      }
    }
  dgquery: |-
    query {
      queryHotel(func: type(Hotel)) @filter(within(Hotel.branches, [[[22.22,11.11],[16.16,15.15],[21.21,20.2]],[[22.28,11.18],[16.18,15.18],[21.28,20.28]]])) {
        name : Hotel.name
        branches : Hotel.branches
        dgraph.uid : uid
      }
    }

-
  name: "MultiPolygon query contains polygon filter"
  gqlquery: |
    query {
      queryHotel(filter: { branches: { contains: { polygon: { coordinates: [ { points: [{ latitude: 11.11, longitude: 22.22}, { latitude: 15.15, longitude: 16.16} , { latitude: 20.20, longitude: 21.21} ]}, { points: [{ latitude: 11.18, longitude: 22.28}, { latitude: 15.18, longitude: 16.18} , { latitude: 20.28, longitude: 21.28}]} ] } } } }) {
        name
        branches {
          polygons {
            coordinates {
              points {
                latitude
                longitude
              }
            }
          }
        }
      }
    }
  dgquery: |-
    query {
      queryHotel(func: type(Hotel)) @filter(contains(Hotel.branches, [[[22.22,11.11],[16.16,15.15],[21.21,20.2]],[[22.28,11.18],[16.18,15.18],[21.28,20.28]]])) {
        name : Hotel.name
        branches : Hotel.branches
        dgraph.uid : uid
      }
    }

-
  name: "MultiPolygon query contains point filter"
  gqlquery: |
    query {
      queryHotel(filter: { branches: { contains: { point: { latitude: 11.11, longitude: 22.22}} } }) {
        name
        branches {
          polygons {
            coordinates {
              points {
                latitude
                longitude
              }
            }
          }
        }
      }
    }
  dgquery: |-
    query {
      queryHotel(func: type(Hotel)) @filter(contains(Hotel.branches, [22.22,11.11])) {
        name : Hotel.name
        branches : Hotel.branches
        dgraph.uid : uid
      }
    }

-
  name: "MultiPolygon query intersect polygon filter"
  gqlquery: |
    query {
      queryHotel(filter: {
        branches: {
          intersects: {
            polygon: {
              coordinates: [{
                points: [{
                  latitude: 11.11,
                  longitude: 22.22
                }, {
                  latitude: 15.15,
                  longitude: 16.16
                }, {
                  latitude: 20.20,
                  longitude: 21.21
                }]
              }, {
                points: [{
                  latitude: 11.18,
                  longitude: 22.28
                }, {
                  latitude: 15.18,
                  longitude: 16.18
                }, {
                  latitude: 20.28,
                  longitude: 21.28
                }]
              }]
            }
          }
        }
      }) {
        name
        branches {
          polygons {
            coordinates {
              points {
                latitude
                longitude
              }
            }
          }
        }
      }
    }
  dgquery: |-
    query {
      queryHotel(func: type(Hotel)) @filter(intersects(Hotel.branches, [[[22.22,11.11],[16.16,15.15],[21.21,20.2]],[[22.28,11.18],[16.18,15.18],[21.28,20.28]]])) {
        name : Hotel.name
        branches : Hotel.branches
        dgraph.uid : uid
      }
    }

-
  name: "MultiPolygon query intersect multi-polygon filter"
  gqlquery: |
    query {
      queryHotel(filter: {
        branches: {
          intersects: {
            multiPolygon: {
              polygons: [{
                coordinates: [{
                  points: [{
                    latitude: 11.11,
                    longitude: 22.22
                  }, {
                    latitude: 15.15,
                    longitude: 16.16
                  }, {
                    latitude: 20.20,
                    longitude: 21.21
                  }]
                }, {
                  points: [{
                    latitude: 11.18,
                    longitude: 22.28
                  }, {
                    latitude: 15.18,
                    longitude: 16.18
                  }, {
                    latitude: 20.28,
                    longitude: 21.28
                  }]
                }]
              }, {
                coordinates: [{
                  points: [{
                    latitude: 91.11,
                    longitude: 92.22
                  }, {
                    latitude: 15.15,
                    longitude: 16.16
                  }, {
                    latitude: 20.20,
                    longitude: 21.21
                  }]
                }, {
                  points: [{
                    latitude: 11.18,
                    longitude: 22.28
                  }, {
                    latitude: 15.18,
                    longitude: 16.18
                  }, {
                    latitude: 20.28,
                    longitude: 21.28
                  }]
                }]
              }]
            }
          }
        }
      }) {
        name
        branches {
          polygons {
            coordinates {
              points {
                latitude
                longitude
              }
            }
          }
        }
      }
    }
  dgquery: |-
    query {
      queryHotel(func: type(Hotel)) @filter(intersects(Hotel.branches, [[[[22.22,11.11],[16.16,15.15],[21.21,20.2]],[[22.28,11.18],[16.18,15.18],[21.28,20.28]]],[[[92.22,91.11],[16.16,15.15],[21.21,20.2]],[[22.28,11.18],[16.18,15.18],[21.28,20.28]]]])) {
        name : Hotel.name
        branches : Hotel.branches
        dgraph.uid : uid
      }
    }

-
  name: "ID query"
  gqlquery: |
    query {
      getAuthor(id: "0x1") {
        name
      }
    }
  dgquery: |-
    query {
      getAuthor(func: uid(0x1)) @filter(type(Author)) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Alias is ignored in query rewriting - get"
  gqlquery: |
    query {
      author : getAuthor(id: "0x1") {
        anAlias : name
        postAlias : posts {
          titleAlias : title
        }
      }
    }
  dgquery: |-
    query {
      getAuthor(func: uid(0x1)) @filter(type(Author)) {
        name : Author.name
        posts : Author.posts {
          title : Post.title
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

-
  name: "Alias is ignored in query rewriting - query"
  gqlquery: |
    query {
      author : queryAuthor {
        anAlias : name
        postAlias : posts {
          titleAlias : title
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : Author.name
        posts : Author.posts {
          title : Post.title
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

-
  name: "ID field gets transformed to uid"
  gqlquery: |
    query {
      getAuthor(id: "0x1") {
        id
        name
      }
    }
  dgquery: |-
    query {
      getAuthor(func: uid(0x1)) @filter(type(Author)) {
        id : uid
        name : Author.name
      }
    }

-
  name: "ID query with depth"
  gqlquery: |
    query {
      getAuthor(id: "0x1") {
        name
        posts {
          title
          text
        }
      }
    }
  dgquery: |-
    query {
      getAuthor(func: uid(0x1)) @filter(type(Author)) {
        name : Author.name
        posts : Author.posts {
          title : Post.title
          text : Post.text
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

-
  name: "ID query deep"
  gqlquery: |
    query {
      getAuthor(id: "0x1") {
        name
        posts {
          title
          text
          author {
            id
            name
          }
        }
      }
    }
  dgquery: |-
    query {
      getAuthor(func: uid(0x1)) @filter(type(Author)) {
        name : Author.name
        posts : Author.posts {
          title : Post.title
          text : Post.text
          author : Post.author {
            id : uid
            name : Author.name
          }
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

-
  name: "Query with no args is query for everything of that type"
  gqlquery: |
    query {
      queryAuthor {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Filter gets rewritten as @filter"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } }) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter(eq(Author.name, "A. N. Author")) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Filter connectives with null values gets skipped "
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" },not:null }) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter(eq(Author.name, "A. N. Author")) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Query with has Filter"
  gqlquery: |
    query {
      queryTeacher(filter: {has: subject}) {
        name
      }
    }
  dgquery: |-
    query {
      queryTeacher(func: type(Teacher)) @filter(has(Teacher.subject)) {
        name : People.name
        dgraph.uid : uid
      }
    }

-
  name: "has Filter with not"
  gqlquery: |
    query {
      queryTeacher(filter: { not : {has: subject } }) {
        name
      }
    }
  dgquery: |-
    query {
      queryTeacher(func: type(Teacher)) @filter(NOT (has(Teacher.subject))) {
        name : People.name
        dgraph.uid : uid
      }
    }

-
  name: "has Filter with and"
  gqlquery: |
    query {
      queryTeacher(filter: {has: subject, and: {has: teaches } }  ) {
        name
      }
    }
  dgquery: |-
    query {
      queryTeacher(func: type(Teacher)) @filter((has(Teacher.teaches) AND has(Teacher.subject))) {
        name : People.name
        dgraph.uid : uid
      }
    }

-
  name: "Filters in same input object implies AND"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" }, dob: { le: "2001-01-01" }, reputation: { gt: 2.5 } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter((le(Author.dob, "2001-01-01") AND eq(Author.name, "A. N. Author") AND gt(Author.reputation, 2.5))) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Filter with nested 'and'"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" }, and: { dob: { le: "2001-01-01" }, and: { reputation: { gt: 2.5 } } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter(((gt(Author.reputation, 2.5) AND le(Author.dob, "2001-01-01")) AND eq(Author.name, "A. N. Author"))) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "has Filter with nested 'and'"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" }, and: { dob: { le: "2001-01-01" }, and: { has: country } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter(((has(Author.country) AND le(Author.dob, "2001-01-01")) AND eq(Author.name, "A. N. Author"))) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Filter with 'or'"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" }, or: { dob: { le: "2001-01-01" } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter((eq(Author.name, "A. N. Author") OR le(Author.dob, "2001-01-01"))) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Filter with 'or' array"
  gqlquery: |
    query {
      queryAuthor(filter: { or: [ { name: { eq: "A. N. Author" } }, { dob: { le: "2001-01-01" } }] } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter((eq(Author.name, "A. N. Author") OR le(Author.dob, "2001-01-01"))) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Filter with 'or' object"
  gqlquery: |
    query {
      queryAuthor(filter: { or: { name: { eq: "A. N. Author" } }} ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter(eq(Author.name, "A. N. Author")) {
        name : Author.name
        dgraph.uid : uid
      }
    }


-
  name: "Filter with implied and as well as 'or'"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" }, reputation: { gt: 2.5 }, or: { dob: { le: "2001-01-01" } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter(((eq(Author.name, "A. N. Author") AND gt(Author.reputation, 2.5)) OR le(Author.dob, "2001-01-01"))) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Filter with implied and nested in 'or'"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" }, or: { reputation: { gt: 2.5 }, dob: { le: "2001-01-01" } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter((eq(Author.name, "A. N. Author") OR (le(Author.dob, "2001-01-01") AND gt(Author.reputation, 2.5)))) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Filter nested 'or'"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" }, or: { reputation: { gt: 2.5 }, or: { dob: { le: "2001-01-01" } } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter((eq(Author.name, "A. N. Author") OR (gt(Author.reputation, 2.5) OR le(Author.dob, "2001-01-01")))) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Filter with 'not"
  gqlquery: |
    query {
      queryAuthor(filter: { not: { reputation: { gt: 2.5 } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter(NOT (gt(Author.reputation, 2.5))) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Filter with first"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } }, first: 10) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author), first: 10) @filter(eq(Author.name, "A. N. Author")) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Filter with first and offset"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } }, first: 10, offset: 10) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author), first: 10, offset: 10) @filter(eq(Author.name, "A. N. Author")) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Filter with order asc"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } }, order: { asc: reputation }) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author), orderasc: Author.reputation) @filter(eq(Author.name, "A. N. Author")) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Filter with order desc"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } }, order: { desc: reputation }) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author), orderdesc: Author.reputation) @filter(eq(Author.name, "A. N. Author")) {
        name : Author.name
        dgraph.uid : uid
      }
    }


-
  name: "Filter with nested order"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } }, order: { desc: reputation, then: { asc: dob } }) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author), orderdesc: Author.reputation, orderasc: Author.dob) @filter(eq(Author.name, "A. N. Author")) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Filter with order, first and offset"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } }, order: { desc: reputation }, first: 10, offset: 10) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author), orderdesc: Author.reputation, first: 10, offset: 10) @filter(eq(Author.name, "A. N. Author")) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Deep filter"
  gqlquery: |
    query {
      queryAuthor {
        name
        posts(filter: { title: { anyofterms: "GraphQL" } }) {
          title
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : Author.name
        posts : Author.posts @filter(anyofterms(Post.title, "GraphQL")) {
          title : Post.title
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }


-
  name: "Deep filter with has filter"
  gqlquery: |
    query {
      queryAuthor {
        name
        posts(filter: { has : tags }) {
          title
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : Author.name
        posts : Author.posts @filter(has(Post.tags)) {
          title : Post.title
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

-
  name: "Deep filter with has and other filters"
  gqlquery: |
    query {
      queryAuthor {
        name
        posts(filter:{ title : {anyofterms: "GRAPHQL"} , and : { has : tags } } ) {
          title
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : Author.name
        posts : Author.posts @filter((has(Post.tags) AND anyofterms(Post.title, "GRAPHQL"))) {
          title : Post.title
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }
-
  name: "Deep filter with first"
  gqlquery: |
    query {
      queryAuthor {
        name
        posts(filter: { title: { anyofterms: "GraphQL" } }, first: 10) {
          title
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : Author.name
        posts : Author.posts @filter(anyofterms(Post.title, "GraphQL")) (first: 10) {
          title : Post.title
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

-
  name: "Deep filter with order, first and offset"
  gqlquery: |
    query {
      queryAuthor {
        name
        posts(filter: { title: { anyofterms: "GraphQL" } }, order: { asc: numLikes }, first: 10, offset: 10) {
          title
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : Author.name
        posts : Author.posts @filter(anyofterms(Post.title, "GraphQL")) (orderasc: Post.numLikes, first: 10, offset: 10) {
          title : Post.title
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }


-
  name: "All Float filters work"
  gqlquery: |
    query {
      queryAuthor(filter: { reputation: { gt: 1.1 }, or: { reputation: { ge: 1.1 }, or: { reputation: { lt: 1.1 }, or: { reputation: { le: 1.1 }, or: { reputation: { eq: 1.1 } } } } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter((gt(Author.reputation, 1.1) OR (ge(Author.reputation, 1.1) OR (lt(Author.reputation, 1.1) OR (le(Author.reputation, 1.1) OR eq(Author.reputation, 1.1)))))) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "All DateTime filters work"
  gqlquery: |
    query {
      queryAuthor(filter: { dob: { gt: "2000-01-01" }, or: { dob: { ge: "2000-01-01" }, or: { dob: { lt: "2000-01-01" }, or: { dob: { le: "2000-01-01" }, or: { dob: { eq: "2000-01-01" } } } } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter((gt(Author.dob, "2000-01-01") OR (ge(Author.dob, "2000-01-01") OR (lt(Author.dob, "2000-01-01") OR (le(Author.dob, "2000-01-01") OR eq(Author.dob, "2000-01-01")))))) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "All Int filters work"
  gqlquery: |
    query {
      queryPost(filter: { numLikes: { gt: 10 }, or: { numLikes: { ge: 10 }, or: { numLikes: { lt: 10 }, or: { numLikes: { le: 10 }, or: { numLikes: { eq: 10 } } } } } } ) {
        title
      }
    }
  dgquery: |-
    query {
      queryPost(func: type(Post)) @filter((gt(Post.numLikes, 10) OR (ge(Post.numLikes, 10) OR (lt(Post.numLikes, 10) OR (le(Post.numLikes, 10) OR eq(Post.numLikes, 10)))))) {
        title : Post.title
        dgraph.uid : uid
      }
    }

-
  name: "All String hash filters work"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter(eq(Author.name, "A. N. Author")) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "All String exact filters work"
  gqlquery: |
    query {
      queryCountry(filter: { name: { gt: "AAA" }, or: { name: { ge: "AAA" }, or: { name: { lt: "AAA" }, or: { name: { le: "AAA" }, or: { name: { eq: "AAA" } } } } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryCountry(func: type(Country)) @filter((gt(Country.name, "AAA") OR (ge(Country.name, "AAA") OR (lt(Country.name, "AAA") OR (le(Country.name, "AAA") OR eq(Country.name, "AAA")))))) {
        name : Country.name
        dgraph.uid : uid
      }
    }

-
  name: "All String exact filters work with an array for OR"
  gqlquery: |
    query {
      queryCountry(filter: { name: { gt: "AAA" }, or: [{ name: { ge: "AAA" }}, { name: { lt: "AAA" }}, { name: { le: "AAA" }}, { name: { eq: "AAA" } }] }) {
        name
      }
    }
  dgquery: |-
    query {
      queryCountry(func: type(Country)) @filter((gt(Country.name, "AAA") OR (ge(Country.name, "AAA") OR lt(Country.name, "AAA") OR le(Country.name, "AAA") OR eq(Country.name, "AAA")))) {
        name : Country.name
        dgraph.uid : uid
      }
    }

-
  name: "All String exact filters work with an array for AND"
  gqlquery: |
    query {
      queryCountry(filter: { name: { gt: "AAA" }, and: [{ name: { ge: "AAA" }}, { name: { lt: "AAA" }}, { name: { le: "AAA" }}, { name: { eq: "AAA" } }] }) {
        name
      }
    }
  dgquery: |-
    query {
      queryCountry(func: type(Country)) @filter((ge(Country.name, "AAA") AND lt(Country.name, "AAA") AND le(Country.name, "AAA") AND eq(Country.name, "AAA") AND gt(Country.name, "AAA"))) {
        name : Country.name
        dgraph.uid : uid
      }
    }


-
  name: "Represent (A OR B) AND (C OR D)"
  gqlquery: |
    query {
      queryCountry(filter: { and: [{ name: { gt: "AAA" }, or: { name: { lt: "XXX" }}}, { name: { gt : "CCC" }, or: { name: { lt: "MMM" }}}] }) {
        name
      }
    }
  dgquery: |-
    query {
      queryCountry(func: type(Country)) @filter(((gt(Country.name, "AAA") OR lt(Country.name, "XXX")) AND (gt(Country.name, "CCC") OR lt(Country.name, "MMM")))) {
        name : Country.name
        dgraph.uid : uid
      }
    }

-
  name: "All String term filters work"
  gqlquery: |
    query {
      queryPost(filter: { title: { anyofterms: "GraphQL"}, or: { title: { allofterms: "GraphQL" } } } ) {
        title
      }
    }
  dgquery: |-
    query {
      queryPost(func: type(Post)) @filter((anyofterms(Post.title, "GraphQL") OR allofterms(Post.title, "GraphQL"))) {
        title : Post.title
        dgraph.uid : uid
      }
    }


-
  name: "All String fulltext filters work"
  gqlquery: |
    query {
      queryPost(filter: { text: { anyoftext: "GraphQL"}, or: { text: { alloftext: "GraphQL" } } } ) {
        title
      }
    }
  dgquery: |-
    query {
      queryPost(func: type(Post)) @filter((anyoftext(Post.text, "GraphQL") OR alloftext(Post.text, "GraphQL"))) {
        title : Post.title
        dgraph.uid : uid
      }
    }

-
  name: "All String regexp filters work"
  gqlquery: |
    query {
      queryCountry(filter: { name: { regexp: "/.*ust.*/" }}) {
        name
      }
    }
  dgquery: |-
    query {
      queryCountry(func: type(Country)) @filter(regexp(Country.name, /.*ust.*/)) {
        name : Country.name
        dgraph.uid : uid
      }
    }

-
  name: "Count Query"
  gqlquery: |
    query {
      aggregateCountry(filter: { name: { regexp: "/.*ust.*/" }}) {
        count
      }
    }
  dgquery: |-
    query {
      aggregateCountry(func: type(Country)) @filter(regexp(Country.name, /.*ust.*/)) {
        count : count(uid)
      }
    }

-
  name: "Skip directive"
  variables:
    skipTrue: true
    skipFalse: false
  gqlquery: |
    query ($skipTrue: Boolean!, $skipFalse: Boolean!) {
      getAuthor(id: "0x1") {
        name @skip(if: $skipFalse)
        posts @skip(if: $skipTrue) {
          title
          text
        }
      }
    }
  dgquery: |-
    query {
      getAuthor(func: uid(0x1)) @filter(type(Author)) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Include directive"
  variables:
    includeTrue: true
    includeFalse: false
  gqlquery: |
    query ($includeTrue: Boolean!, $includeFalse: Boolean!) {
      queryAuthor {
        name @include(if: $includeTrue)
        posts(filter: { title: { anyofterms: "GraphQL" } }) @include(if: $includeFalse) {
          title
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Include only fields for which skip is !false or include is true"
  variables:
    includeFalse: false
    includeTrue: true
    skipFalse: false
    skipTrue: true
  gqlquery: |
    query ($includeFalse: Boolean!, $skipTrue: Boolean!, $includeTrue: Boolean!,
      $skipFalse: Boolean!) {
      queryAuthor {
        dob @include(if: $includeFalse) @skip(if: $skipFalse)
        reputation @include(if: $includeFalse) @skip(if: $skipTrue)
        name @include(if: $includeTrue) @skip(if: $skipFalse)
        posts(filter: { title: { anyofterms: "GraphQL" } }, first: 10) @include(if: $includeTrue)
          @skip(if: $skipTrue) {
          title
          tags
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Cascade directive on get query"
  gqlquery: |
    query {
      getAuthor(id: "0x1") @cascade {
        dob
        posts {
          text
        }
      }
    }
  dgquery: |-
    query {
      getAuthor(func: uid(0x1)) @filter(type(Author)) @cascade {
        dob : Author.dob
        posts : Author.posts {
          text : Post.text
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

-
  name: "Cascade directive on filter query"
  gqlquery: |
    query {
      queryAuthor @cascade {
        dob
        posts {
          text
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @cascade {
        dob : Author.dob
        posts : Author.posts {
          text : Post.text
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

-
  name: "Cascade directive on query field"
  gqlquery: |
    query {
      queryAuthor {
        dob
        posts @cascade {
          text
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        dob : Author.dob
        posts : Author.posts @cascade {
          text : Post.text
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

-
  name: "Cascade directive on root query and query field"
  gqlquery: |
    query {
      queryAuthor @cascade {
        dob
        posts @cascade {
          text
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @cascade {
        dob : Author.dob
        posts : Author.posts @cascade {
          text : Post.text
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

-
  name: "Parameterized Cascade directive on filter query"
  gqlquery: |
    query {
      queryAuthor @cascade(fields:["dob"]) {
        dob
        name
        posts {
          text
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @cascade(Author.dob) {
        dob : Author.dob
        name : Author.name
        posts : Author.posts {
          text : Post.text
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

-
  name: "Parameterized Cascade directive on get query"
  gqlquery: |
    query {
      getAuthor(id: "0x1") @cascade(fields:["dob"]) {
        dob
        name
        posts {
          text
        }
      }
    }
  dgquery: |-
    query {
      getAuthor(func: uid(0x1)) @filter(type(Author)) @cascade(Author.dob) {
        dob : Author.dob
        name : Author.name
        posts : Author.posts {
          text : Post.text
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

-
  name: "Parameterized Cascade directive on query field"
  gqlquery: |
    query {
      queryAuthor {
        dob
        posts @cascade(fields:["text"]) {
          text
          title
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        dob : Author.dob
        posts : Author.posts @cascade(Post.text) {
          text : Post.text
          title : Post.title
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

-
  name: "Parameterized Cascade directive on root and query field"
  gqlquery: |
    query {
      queryAuthor @cascade(fields:["dob"]) {
        dob
        reputation
        posts @cascade(fields:["text","title","postID"]) {
          text
          title
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @cascade(Author.dob) {
        dob : Author.dob
        reputation : Author.reputation
        posts : Author.posts @cascade(Post.text, Post.title, uid) {
          text : Post.text
          title : Post.title
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

-
  name: "Parameterized Cascade directive with multiple parameters on root and query field"
  gqlquery: |
    query {
      queryAuthor @cascade(fields:["dob","reputation","id"]) {
        dob
        reputation
        posts @cascade(fields:["text","title"]) {
          text
          title
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @cascade(Author.dob, Author.reputation, uid) {
        dob : Author.dob
        reputation : Author.reputation
        posts : Author.posts @cascade(Post.text, Post.title) {
          text : Post.text
          title : Post.title
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

-
  name: "Parameterized Cascade directive with argument at outer level which is not present in inner level "
  gqlquery: |
    query {
      queryAuthor @cascade(fields:["dob"]) {
        dob
        reputation
        posts  {
          text
          title
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @cascade(Author.dob) {
        dob : Author.dob
        reputation : Author.reputation
        posts : Author.posts {
          text : Post.text
          title : Post.title
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

-
  name: "parameterized cascade with interface implementation Human"
  gqlquery: |
    query {
      queryHuman @cascade(fields:["id","name","ename","dob"]) {
        id
        name
        ename
        dob
        female
      }
    }
  dgquery: |-
    query {
      queryHuman(func: type(Human)) @cascade(uid, Character.name, Employee.ename, Human.dob) {
        id : uid
        name : Character.name
        ename : Employee.ename
        dob : Human.dob
        female : Human.female
      }
    }

-
  name: "parameterized cascade with interface Character"
  gqlquery: |
    query {
      queryCharacter @cascade(fields:["id","name"]) {
        id
        name
      }
    }
  dgquery: |-
    query {
      queryCharacter(func: type(Character)) @cascade(uid, Character.name) {
        dgraph.type
        id : uid
        name : Character.name
      }
    }

-
  name: "getHuman which implements an interface"
  gqlquery: |
    query {
      getHuman(id: "0x1") {
        id
        name
        ename
        dob
        female
      }
    }
  dgquery: |-
    query {
      getHuman(func: uid(0x1)) @filter(type(Human)) {
        id : uid
        name : Character.name
        ename : Employee.ename
        dob : Human.dob
        female : Human.female
      }
    }

-
  name: "queryHuman which implements an interface"
  gqlquery: |
    query {
      queryHuman {
        id
        name
        ename
        dob
        female
      }
    }
  dgquery: |-
    query {
      queryHuman(func: type(Human)) {
        id : uid
        name : Character.name
        ename : Employee.ename
        dob : Human.dob
        female : Human.female
      }
    }

-
  name: "Get Query on interface whose implementation contains Auth rules."
  gqlquery: |
    query {
      getX(id: "0x1") {
        username
        age
      }
    }
  dgquery: |-
    query {
      getX()
    }

-
  name: "Query on interface whose implementation contains Auth rules."
  gqlquery: |
    query {
      queryX {
        username
        age
      }
    }
  dgquery: |-
    query {
      queryX()
    }

-
  name: "filter with order for type which implements an interface"
  gqlquery: |
    query {
      queryHuman (filter: { name: { anyofterms: "GraphQL" } }, order: { asc: ename }) {
        id
        name
        ename
        dob
      }
    }
  dgquery: |-
    query {
      queryHuman(func: type(Human), orderasc: Employee.ename) @filter(anyofterms(Character.name, "GraphQL")) {
        id : uid
        name : Character.name
        ename : Employee.ename
        dob : Human.dob
      }
    }

-
  name: "queryCharacter with fragment for human"
  gqlquery: |
    query {
      queryCharacter {
        id
        name
        ... on Human {
          female
          ename
        }
      }
    }
  dgquery: |-
    query {
      queryCharacter(func: type(Character)) {
        dgraph.type
        id : uid
        name : Character.name
        female : Human.female
        ename : Employee.ename
      }
    }

-
  name: "queryCharacter with fragment on multiple types"
  gqlquery: |
    query {
      queryCharacter {
        id
        name
        ... on Human {
          female
          ename
        }
        ... on Director {
          movies
        }
      }
    }
  dgquery: |-
    query {
      queryCharacter(func: type(Character)) {
        dgraph.type
        id : uid
        name : Character.name
        female : Human.female
        ename : Employee.ename
        movies : Director.movies
      }
    }

-
  name: "Filter with id uses uid func at root."
  gqlquery: |
    query {
      queryAuthor(filter: { id: ["0x1", "0x2"], and: { name: { eq: "A. N. Author" } }}) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: uid(0x1, 0x2)) @filter((eq(Author.name, "A. N. Author") AND type(Author))) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Between filter"
  gqlquery: |
    query {
      queryPost(filter: { numLikes: { between : { min :10, max: 20 }}}) {
        title
        text
      }
    }
  dgquery: |-
    query {
      queryPost(func: type(Post)) @filter(between(Post.numLikes, 10, 20)) {
        title : Post.title
        text : Post.text
        dgraph.uid : uid
      }
    }

-
  name: "deep Between filter"
  gqlquery: |
    query{
      queryAuthor(filter: {reputation: {between: {min:6.0, max: 7.2}}}){
        name
        reputation
        posts(filter: {numLikes: {between: {min: 10, max: 100}}}){
          title
          numLikes
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter(between(Author.reputation, 6, 7.2)) {
        name : Author.name
        reputation : Author.reputation
        posts : Author.posts @filter(between(Post.numLikes, 10, 100)) {
          title : Post.title
          numLikes : Post.numLikes
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

-
  name: "Filter with id inside and argument doesn't use uid func at root."
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" }, and: { id: ["0x1", "0x2"] }}) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter((uid(0x1, 0x2) AND eq(Author.name, "A. N. Author"))) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Filter with id and not translates correctly.."
  gqlquery: |
    query {
      queryAuthor(filter: { not: { id: ["0x1", "0x2"] }}) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter(NOT (uid(0x1, 0x2))) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Deep filter with id"
  gqlquery: |
    query {
      queryAuthor {
        name
        posts(filter: { postID: ["0x1", "0x2"], and: { title: { anyofterms: "GraphQL" } }}) {
          title
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : Author.name
        posts : Author.posts @filter((anyofterms(Post.title, "GraphQL") AND uid(0x1, 0x2))) {
          title : Post.title
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

-
  name: "Deep filter with id in not key"
  gqlquery: |
    query {
      queryAuthor {
        name
        posts(filter: { title: { anyofterms: "GraphQL" }, not: { postID: ["0x1", "0x2"] } }) {
          title
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : Author.name
        posts : Author.posts @filter((NOT (uid(0x1, 0x2)) AND anyofterms(Post.title, "GraphQL"))) {
          title : Post.title
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

-
  name: "Pagination and Order at root node with UID."
  gqlquery: |
    query {
      queryAuthor(filter: { id: ["0x1", "0x2"] }, order: {asc: name}, first: 0, offset: 1 ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: uid(0x1, 0x2), orderasc: Author.name, first: 0, offset: 1) @filter(type(Author)) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Order at root node with UID."
  gqlquery: |
    query {
      queryAuthor(filter: { id: ["0x1", "0x2"] }, order: {asc: name}) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: uid(0x1, 0x2), orderasc: Author.name) @filter(type(Author)) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Order at root node without UID."
  gqlquery: |
    query {
      queryAuthor(order: {asc: name}) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author), orderasc: Author.name) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Order and Pagination at root node without UID."
  gqlquery: |
    query {
      queryAuthor(order: {asc: name}, first: 2, offset: 3) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author), orderasc: Author.name, first: 2, offset: 3) {
        name : Author.name
        dgraph.uid : uid
      }
    }


-
  name: "Filter with no valid id construct the right query with type func at root."
  gqlquery: |
    query {
      queryAuthor(filter: { id: ["alice", "bob"], and: { name: { eq: "A. N. Author" } }}) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: uid()) @filter((eq(Author.name, "A. N. Author") AND type(Author))) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Filter with id only includes valid id in dgquery."
  gqlquery: |
    query {
      queryAuthor(filter: { id: ["0x1", "bob"], and: { name: { eq: "A. N. Author" } }}) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: uid(0x1)) @filter((eq(Author.name, "A. N. Author") AND type(Author))) {
        name : Author.name
        dgraph.uid : uid
      }
    }

-
  name: "Get editor without supplying anything"
  gqlquery: |
    query {
      getEditor {
        name
      }
    }
  dgquery: |-
    query {
      getEditor(func: uid(0x0)) @filter(type(Editor)) {
        name : Editor.name
        dgraph.uid : uid
      }
    }

-
  name: "Get editor using code"
  gqlquery: |
    query {
      getEditor(code: "tolstoy") {
        name
      }
    }
  dgquery: |-
    query {
      getEditor(func: eq(Editor.code, "tolstoy")) @filter(type(Editor)) {
        name : Editor.name
        dgraph.uid : uid
      }
    }

-
  name: "Get editor using both code and id"
  gqlquery: |
    query {
      getEditor(code: "tolstoy", id: "0x1") {
        name
      }
    }
  dgquery: |-
    query {
      getEditor(func: uid(0x1)) @filter((eq(Editor.code, "tolstoy") AND type(Editor))) {
        name : Editor.name
        dgraph.uid : uid
      }
    }

-
  name: "Get with XID where no ID in type"
  gqlquery: |
    query {
      getState(code: "NSW") {
        name
      }
    }
  dgquery: |-
    query {
      getState(func: eq(State.code, "NSW")) @filter(type(State)) {
        name : State.name
        dgraph.uid : uid
      }
    }

-
  name: "Query editor using code"
  gqlquery: |
    query {
      queryEditor(filter: { code: { eq: "editor" }, and: { name: { eq: "A. N. Editor" }}}) {
        name
      }
    }
  dgquery: |-
    query {
      queryEditor(func: type(Editor)) @filter((eq(Editor.name, "A. N. Editor") AND eq(Editor.code, "editor"))) {
        name : Editor.name
        dgraph.uid : uid
      }
    }

-
  name: "Query editor using code and uid"
  gqlquery: |
    query {
      queryEditor(filter: { id: ["0x1"], and: { code: { eq: "editor"}}}) {
        name
      }
    }
  dgquery: |-
    query {
      queryEditor(func: uid(0x1)) @filter((eq(Editor.code, "editor") AND type(Editor))) {
        name : Editor.name
        dgraph.uid : uid
      }
    }

-
  name: "Query along reverse edge is converted appropriately"
  gqlquery: |
    query {
      queryMovie {
        name
        director {
          name
        }
      }
    }
  dgquery: |-
    query {
      queryMovie(func: type(Movie)) {
        name : Movie.name
        director : ~directed.movies {
          name : MovieDirector.name
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

-
  name: "deprecated fields can be queried"
  gqlquery: |
    query {
      queryCategory {
        iAmDeprecated
      }
    }

  dgquery: |-
    query {
      queryCategory(func: type(Category)) {
        iAmDeprecated : Category.iAmDeprecated
        dgraph.uid : uid
      }
    }

-
  name: "Password query"
  gqlquery: |
    query {
      checkUserPassword(name: "user1", pwd: "Password") {
        name
      }
    }
  dgquery: |-
    query {
      checkUserPassword(func: eq(User.name, "user1")) @filter((eq(val(pwd), 1) AND type(User))) {
        name : User.name
        dgraph.uid : uid
      }
      checkPwd(func: eq(User.name, "user1")) @filter(type(User)) {
        pwd as checkpwd(User.pwd, "Password")
      }
    }


- name: "Rewrite without custom fields"
  gqlquery: |
    query {
      getComment(id: "0x1") {
        id
        author
        title
        content
        ups
        relatedUsers {
          name
        }
      }
    }
  dgquery: |-
    query {
      getComment(func: uid(0x1)) @filter(type(Comment)) {
        id : uid
        author : Comment.author
        title : Comment.title
        ups : Comment.ups
        url : Comment.url
      }
    }
- name: "Include fields needed by custom directive"
  gqlquery: |
    query {
      getComment(id: "0x1") {
        content
        relatedUsers {
          name
        }
      }
    }
  dgquery: |-
    query {
      getComment(func: uid(0x1)) @filter(type(Comment)) {
        author : Comment.author
        id : uid
        url : Comment.url
      }
    }
- name: "Rewrite without custom fields deep"
  gqlquery: |-
    query {
      getPost(postID: "0x1") {
        postID
        comments {
          id
          author
          title
          content
          ups
          url
          relatedUsers {
            name
          }
        }
      }
    }
  dgquery: |-
    query {
      getPost(func: uid(0x1)) @filter(type(Post)) {
        postID : uid
        comments : Post.comments {
          id : uid
          author : Comment.author
          title : Comment.title
          ups : Comment.ups
          url : Comment.url
        }
      }
    }
- name: "Include fields needed by custom directive deep"
  gqlquery: |-
    query {
      getPost(postID: "0x1") {
        postID
        comments {
          author
          title
          content
          ups
          relatedUsers {
            name
          }
        }
      }
    }
  dgquery: |-
    query {
      getPost(func: uid(0x1)) @filter(type(Post)) {
        postID : uid
        comments : Post.comments {
          author : Comment.author
          title : Comment.title
          ups : Comment.ups
          id : uid
          url : Comment.url
        }
      }
    }
- name: "getType by id should work"
  gqlquery: |-
    query {
      getTweets(id: "1286891968727982081") {
        score
        id
      }
    }
  dgquery: |-
    query {
      getTweets(func: eq(Tweets.id, "1286891968727982081")) @filter(type(Tweets)) {
        score : Tweets.score
        id : Tweets.id
        dgraph.uid : uid
      }
    }

- name: "querying a field multiple times with different aliases adds it only once in rewriting"
  gqlquery: |-
    query {
      queryThingOne {
        i1: id
        i2: id
        name
        n: name
        n1: name
      }
    }
  dgquery: |-
    query {
      queryThingOne(func: type(ThingOne)) {
        id : uid
        name : Thing.name
      }
    }

- name: "query with fragments inside interface"
  gqlquery: |-
    query {
      queryThing {
        __typename
        ... on ThingOne {
          id
          name
          color
          prop
          usedBy
        }
        ... thingTwoFrag
      }
    }
    fragment thingTwoFrag on ThingTwo {
      id
      name
      color
      prop
      owner
    }
  dgquery: |-
    query {
      queryThing(func: type(Thing)) {
        dgraph.type
        id : uid
        name : Thing.name
        ThingOne.color : ThingOne.color
        prop : prop
        usedBy : ThingOne.usedBy
        ThingTwo.color : ThingTwo.color
        owner : ThingTwo.owner
      }
    }

- name: "query only __typename in fragments inside interface"
  gqlquery: |-
    query {
      queryThing {
        ... on ThingOne {
          __typename
        }
        ... on ThingTwo {
          __typename
        }
      }
    }
  dgquery: |-
    query {
      queryThing(func: type(Thing)) {
        dgraph.type
        dgraph.uid : uid
      }
    }

- name: "query only __typename in fragment inside object"
  gqlquery: |-
    query {
      queryThingOne {
        ... on ThingOne {
          __typename
        }
      }
    }
  dgquery: |-
    query {
      queryThingOne(func: type(ThingOne)) {
        dgraph.uid : uid
      }
    }

- name: "query union field - with fragment on interface implemented by member-types"
  gqlquery: |-
    query {
      queryHome {
        address
        members {
          ... on Animal {
            category
          }
          ... on Dog {
            breed
          }
          ... on Parrot {
            repeatsWords
          }
          ... on Human {
            name
            dob
          }
        }
      }
    }
  dgquery: |-
    query {
      queryHome(func: type(Home)) {
        address : Home.address
        members : Home.members {
          dgraph.type
          category : Animal.category
          Dog.breed : Dog.breed
          repeatsWords : Parrot.repeatsWords
          name : Character.name
          dob : Human.dob
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

- name: "query union field - with repeated field in member-types"
  gqlquery: |-
    query {
      queryHome {
        members {
          ... on Dog {
            category
            breed
          }
          ... on Plant {
            breed
          }
        }
      }
    }
  dgquery: |-
    query {
      queryHome(func: type(Home)) {
        members : Home.members {
          dgraph.type
          category : Animal.category
          Dog.breed : Dog.breed
          Plant.breed : Plant.breed
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

- name: "query union field - with arguments on union field"
  gqlquery: |-
    query {
      queryHome {
        members(filter: {
            memberTypes: [Dog, Parrot]
            dogFilter:  {
              breed: { allofterms: "German Shepherd"}
            }
          }
          first: 5
          offset: 10
        ) {
          ... on Dog {
            id
          }
          ... on Parrot {
            repeatsWords
          }
        }
      }
    }
  dgquery: |-
    query {
      queryHome(func: type(Home)) {
        members : Home.members @filter(((type(Dog) AND allofterms(Dog.breed, "German Shepherd")) OR type(Parrot))) (first: 5, offset: 10) {
          dgraph.type
          id : uid
          repeatsWords : Parrot.repeatsWords
        }
        dgraph.uid : uid
      }
    }

- name: "query union field - memberTypes is empty list"
  gqlquery: |-
    query {
      queryHome {
        members(filter: {
          memberTypes: []
          dogFilter:  {
            breed: { allofterms: "German Shepherd"}
          }
        }) {
          ... on Dog {
            id
          }
          ... on Parrot {
            repeatsWords
          }
        }
      }
    }
  dgquery: |-
    query {
      queryHome(func: type(Home))
    }

- name: "query union field - memberTypes isn't specified"
  gqlquery: |-
    query {
      queryHome {
        members(filter: {
          dogFilter:  {
            breed: { allofterms: "German Shepherd"}
          }
        }) {
          ... on Dog {
            id
          }
        }
      }
    }
  dgquery: |-
    query {
      queryHome(func: type(Home)) {
        members : Home.members @filter(((type(Dog) AND allofterms(Dog.breed, "German Shepherd")) OR type(Parrot) OR type(Human) OR type(Plant))) {
          dgraph.type
          id : uid
        }
        dgraph.uid : uid
      }
    }

- name: "query union field - memberTypes contains all the types"
  gqlquery: |-
    query {
      queryHome {
        members(filter: {
          memberTypes: [Dog, Human, Parrot, Plant]
          dogFilter:  {
            breed: { allofterms: "German Shepherd"}
          }
        }) {
          ... on Dog {
            id
          }
        }
      }
    }
  dgquery: |-
    query {
      queryHome(func: type(Home)) {
        members : Home.members @filter(((type(Dog) AND allofterms(Dog.breed, "German Shepherd")) OR type(Human) OR type(Parrot) OR type(Plant))) {
          dgraph.type
          id : uid
        }
        dgraph.uid : uid
      }
    }

-
  name: "Count query at child level"
  gqlquery: |
    query {
      queryCountry {
        nm : name
        ag : statesAggregate {
          cnt : count
        }
      }
    }
  dgquery: |-
    query {
      queryCountry(func: type(Country)) {
        name : Country.name
        count_statesAggregate : count(Country.states)
        dgraph.uid : uid
      }
    }

-
  name: "Count query at child level with filter"
  gqlquery: |
    query {
      queryCountry {
        nm : name
        ag : statesAggregate(filter: { code: { eq: "state code" } }) {
          cnt : count
        }
        st : states {
          capital
        }
      }
    }
  dgquery: |-
    query {
      queryCountry(func: type(Country)) {
        name : Country.name
        count_statesAggregate : count(Country.states) @filter(eq(State.code, "state code"))
        states : Country.states {
          capital : State.capital
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }

-
  name: "Deep child level get query with count"
  gqlquery: |
    query {
      getAuthor(id: "0x1") {
        nm : name
        country {
          ag : statesAggregate(filter: { code: { eq: "state code" } }) {
            count
          }
        }
      }
    }
  dgquery: |-
    query {
      getAuthor(func: uid(0x1)) @filter(type(Author)) {
        name : Author.name
        country : Author.country {
          count_statesAggregate : count(Country.states) @filter(eq(State.code, "state code"))
          dgraph.uid : uid
        }
        dgraph.uid : uid
      }
    }
