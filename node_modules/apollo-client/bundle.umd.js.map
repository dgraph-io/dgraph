{"version":3,"sources":["../src/core/networkStatus.ts","../src/util/Observable.ts","../src/util/arrays.ts","../src/errors/ApolloError.ts","../src/core/types.ts","../src/core/ObservableQuery.ts","../src/data/mutations.ts","../src/data/queries.ts","../src/util/capitalizeFirstLetter.ts","../src/core/LocalState.ts","../src/util/observables.ts","../src/core/QueryManager.ts","../src/data/store.ts","../src/version.ts","../src/ApolloClient.ts"],"names":["LinkObservable"],"mappings":"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","sourcesContent":["/**\n * The current status of a querys execution in our system.\n */\nexport enum NetworkStatus {\n  /**\n   * The query has never been run before and the query is now currently running. A query will still\n   * have this network status even if a partial data result was returned from the cache, but a\n   * query was dispatched anyway.\n   */\n  loading = 1,\n\n  /**\n   * If `setVariables` was called and a query was fired because of that then the network status\n   * will be `setVariables` until the result of that query comes back.\n   */\n  setVariables = 2,\n\n  /**\n   * Indicates that `fetchMore` was called on this query and that the query created is currently in\n   * flight.\n   */\n  fetchMore = 3,\n\n  /**\n   * Similar to the `setVariables` network status. It means that `refetch` was called on a query\n   * and the refetch request is currently in flight.\n   */\n  refetch = 4,\n\n  /**\n   * Indicates that a polling query is currently in flight. So for example if you are polling a\n   * query every 10 seconds then the network status will switch to `poll` every 10 seconds whenever\n   * a poll request has been sent but not resolved.\n   */\n  poll = 6,\n\n  /**\n   * No request is in flight for this query, and no errors happened. Everything is OK.\n   */\n  ready = 7,\n\n  /**\n   * No request is in flight for this query, but one or more errors were detected.\n   */\n  error = 8,\n}\n\n/**\n * Returns true if there is currently a network request in flight according to a given network\n * status.\n */\nexport function isNetworkRequestInFlight(\n  networkStatus: NetworkStatus,\n): boolean {\n  return networkStatus < 7;\n}\n","// This simplified polyfill attempts to follow the ECMAScript Observable proposal.\n// See https://github.com/zenparsing/es-observable\nimport { Observable as LinkObservable } from 'apollo-link';\n\nexport type Subscription = ZenObservable.Subscription;\nexport type Observer<T> = ZenObservable.Observer<T>;\n\nimport $$observable from 'symbol-observable';\n\n// rxjs interopt\nexport class Observable<T> extends LinkObservable<T> {\n  public [$$observable]() {\n    return this;\n  }\n\n  public ['@@observable' as any]() {\n    return this;\n  }\n}\n","export function isNonEmptyArray<T>(value?: ArrayLike<T>): value is Array<T> {\n  return Array.isArray(value) && value.length > 0;\n}\n","import { GraphQLError } from 'graphql';\nimport { isNonEmptyArray } from '../util/arrays';\n\nexport function isApolloError(err: Error): err is ApolloError {\n  return err.hasOwnProperty('graphQLErrors');\n}\n\n// Sets the error message on this error according to the\n// the GraphQL and network errors that are present.\n// If the error message has already been set through the\n// constructor or otherwise, this function is a nop.\nconst generateErrorMessage = (err: ApolloError) => {\n  let message = '';\n  // If we have GraphQL errors present, add that to the error message.\n  if (isNonEmptyArray(err.graphQLErrors)) {\n    err.graphQLErrors.forEach((graphQLError: GraphQLError) => {\n      const errorMessage = graphQLError\n        ? graphQLError.message\n        : 'Error message not found.';\n      message += `GraphQL error: ${errorMessage}\\n`;\n    });\n  }\n\n  if (err.networkError) {\n    message += 'Network error: ' + err.networkError.message + '\\n';\n  }\n\n  // strip newline from the end of the message\n  message = message.replace(/\\n$/, '');\n  return message;\n};\n\nexport class ApolloError extends Error {\n  public message: string;\n  public graphQLErrors: ReadonlyArray<GraphQLError>;\n  public networkError: Error | null;\n\n  // An object that can be used to provide some additional information\n  // about an error, e.g. specifying the type of error this is. Used\n  // internally within Apollo Client.\n  public extraInfo: any;\n\n  // Constructs an instance of ApolloError given a GraphQLError\n  // or a network error. Note that one of these has to be a valid\n  // value or the constructed error will be meaningless.\n  constructor({\n    graphQLErrors,\n    networkError,\n    errorMessage,\n    extraInfo,\n  }: {\n    graphQLErrors?: ReadonlyArray<GraphQLError>;\n    networkError?: Error | null;\n    errorMessage?: string;\n    extraInfo?: any;\n  }) {\n    super(errorMessage);\n    this.graphQLErrors = graphQLErrors || [];\n    this.networkError = networkError || null;\n\n    if (!errorMessage) {\n      this.message = generateErrorMessage(this);\n    } else {\n      this.message = errorMessage;\n    }\n\n    this.extraInfo = extraInfo;\n\n    // We're not using `Object.setPrototypeOf` here as it isn't fully\n    // supported on Android (see issue #3236).\n    (this as any).__proto__ = ApolloError.prototype;\n  }\n}\n","import { FetchResult } from 'apollo-link';\nimport { DocumentNode, GraphQLError } from 'graphql';\n\nimport { QueryStoreValue } from '../data/queries';\nimport { NetworkStatus } from './networkStatus';\nimport { Resolver } from './LocalState';\n\nexport type QueryListener = (\n  queryStoreValue: QueryStoreValue,\n  newData?: any,\n  forceResolvers?: boolean,\n) => void;\n\nexport type OperationVariables = { [key: string]: any };\n\nexport type PureQueryOptions = {\n  query: DocumentNode;\n  variables?: { [key: string]: any };\n  context?: any;\n};\n\nexport type ApolloQueryResult<T> = {\n  data: T;\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  stale: boolean;\n};\n\nexport enum FetchType {\n  normal = 1,\n  refetch = 2,\n  poll = 3,\n}\n\n// This is part of the public API, people write these functions in `updateQueries`.\nexport type MutationQueryReducer<T> = (\n  previousResult: Record<string, any>,\n  options: {\n    mutationResult: FetchResult<T>;\n    queryName: string | undefined;\n    queryVariables: Record<string, any>;\n  },\n) => Record<string, any>;\n\nexport type MutationQueryReducersMap<T = { [key: string]: any }> = {\n  [queryName: string]: MutationQueryReducer<T>;\n};\n\nexport interface Resolvers {\n  [key: string]: {\n    [ field: string ]: Resolver;\n  };\n}\n","import {\n  isEqual,\n  tryFunctionOrLogError,\n  cloneDeep,\n  getOperationDefinition,\n} from 'apollo-utilities';\nimport { GraphQLError } from 'graphql';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport { Observable, Observer, Subscription } from '../util/Observable';\nimport { ApolloError } from '../errors/ApolloError';\nimport { QueryManager } from './QueryManager';\nimport { ApolloQueryResult, FetchType, OperationVariables } from './types';\nimport {\n  WatchQueryOptions,\n  FetchMoreQueryOptions,\n  SubscribeToMoreOptions,\n  ErrorPolicy,\n} from './watchQueryOptions';\n\nimport { QueryStoreValue } from '../data/queries';\n\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { isNonEmptyArray } from '../util/arrays';\n\n// XXX remove in the next breaking semver change (3.0)\n// Deprecated, use ApolloCurrentQueryResult\nexport type ApolloCurrentResult<T> = {\n  data: T | {};\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  error?: ApolloError;\n  partial?: boolean;\n};\n\nexport type ApolloCurrentQueryResult<T> = {\n  data: T | undefined;\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  error?: ApolloError;\n  partial?: boolean;\n  stale?: boolean;\n};\n\nexport interface FetchMoreOptions<\n  TData = any,\n  TVariables = OperationVariables\n> {\n  updateQuery: (\n    previousQueryResult: TData,\n    options: {\n      fetchMoreResult?: TData;\n      variables?: TVariables;\n    },\n  ) => TData;\n}\n\nexport interface UpdateQueryOptions<TVariables> {\n  variables?: TVariables;\n}\n\nexport const hasError = (\n  storeValue: QueryStoreValue,\n  policy: ErrorPolicy = 'none',\n) => storeValue && (\n  storeValue.networkError ||\n  (policy === 'none' && isNonEmptyArray(storeValue.graphQLErrors))\n);\n\nexport class ObservableQuery<\n  TData = any,\n  TVariables = OperationVariables\n> extends Observable<ApolloQueryResult<TData>> {\n  public options: WatchQueryOptions<TVariables>;\n  public readonly queryId: string;\n  public readonly queryName?: string;\n  /**\n   *\n   * The current value of the variables for this query. Can change.\n   */\n  public variables: TVariables;\n\n  private shouldSubscribe: boolean;\n  private isTornDown: boolean;\n  private queryManager: QueryManager<any>;\n  private observers = new Set<Observer<ApolloQueryResult<TData>>>();\n  private subscriptions = new Set<Subscription>();\n\n  private lastResult: ApolloQueryResult<TData>;\n  private lastResultSnapshot: ApolloQueryResult<TData>;\n  private lastError: ApolloError;\n\n  constructor({\n    queryManager,\n    options,\n    shouldSubscribe = true,\n  }: {\n    queryManager: QueryManager<any>;\n    options: WatchQueryOptions<TVariables>;\n    shouldSubscribe?: boolean;\n  }) {\n    super((observer: Observer<ApolloQueryResult<TData>>) =>\n      this.onSubscribe(observer),\n    );\n\n    // active state\n    this.isTornDown = false;\n\n    // query information\n    this.options = options;\n    this.variables = options.variables || ({} as TVariables);\n    this.queryId = queryManager.generateQueryId();\n    this.shouldSubscribe = shouldSubscribe;\n\n    const opDef = getOperationDefinition(options.query);\n    this.queryName = opDef && opDef.name && opDef.name.value;\n\n    // related classes\n    this.queryManager = queryManager;\n  }\n\n  public result(): Promise<ApolloQueryResult<TData>> {\n    return new Promise((resolve, reject) => {\n      const observer: Observer<ApolloQueryResult<TData>> = {\n        next: (result: ApolloQueryResult<TData>) => {\n          resolve(result);\n\n          // Stop the query within the QueryManager if we can before\n          // this function returns.\n          //\n          // We do this in order to prevent observers piling up within\n          // the QueryManager. Notice that we only fully unsubscribe\n          // from the subscription in a setTimeout(..., 0)  call. This call can\n          // actually be handled by the browser at a much later time. If queries\n          // are fired in the meantime, observers that should have been removed\n          // from the QueryManager will continue to fire, causing an unnecessary\n          // performance hit.\n          this.observers.delete(observer);\n          if (!this.observers.size) {\n            this.queryManager.removeQuery(this.queryId);\n          }\n\n          setTimeout(() => {\n            subscription.unsubscribe();\n          }, 0);\n        },\n        error: reject,\n      };\n      const subscription = this.subscribe(observer);\n    });\n  }\n\n  // XXX remove in the next breaking semver change (3.0)\n  // Deprecated, use getCurrentResult()\n  public currentResult(): ApolloCurrentResult<TData> {\n    const result = this.getCurrentResult() as ApolloCurrentResult<TData>;\n    if (result.data === undefined) {\n      result.data = {};\n    }\n    return result;\n  }\n\n  /**\n   * Return the result of the query from the local cache as well as some fetching status\n   * `loading` and `networkStatus` allow to know if a request is in flight\n   * `partial` lets you know if the result from the local cache is complete or partial\n   * @return {data: Object, error: ApolloError, loading: boolean, networkStatus: number, partial: boolean}\n   */\n  public getCurrentResult(): ApolloCurrentQueryResult<TData> {\n    if (this.isTornDown) {\n      const { lastResult } = this;\n      return {\n        data: !this.lastError && lastResult && lastResult.data || void 0,\n        error: this.lastError,\n        loading: false,\n        networkStatus: NetworkStatus.error,\n      };\n    }\n\n    const { data, partial } = this.queryManager.getCurrentQueryResult(this);\n    const queryStoreValue = this.queryManager.queryStore.get(this.queryId);\n    let result: ApolloQueryResult<TData>;\n\n    const { fetchPolicy } = this.options;\n\n    const isNetworkFetchPolicy =\n      fetchPolicy === 'network-only' ||\n      fetchPolicy === 'no-cache';\n\n    if (queryStoreValue) {\n      const { networkStatus } = queryStoreValue;\n\n      if (hasError(queryStoreValue, this.options.errorPolicy)) {\n        return {\n          data: void 0,\n          loading: false,\n          networkStatus,\n          error: new ApolloError({\n            graphQLErrors: queryStoreValue.graphQLErrors,\n            networkError: queryStoreValue.networkError,\n          }),\n        };\n      }\n\n      // Variables might have been added dynamically at query time, when\n      // using `@client @export(as: \"varname\")` for example. When this happens,\n      // the variables have been updated in the query store, but not updated on\n      // the original `ObservableQuery`. We'll update the observable query\n      // variables here to match, so retrieving from the cache doesn't fail.\n      if (queryStoreValue.variables) {\n        this.options.variables = {\n          ...this.options.variables,\n          ...(queryStoreValue.variables as TVariables),\n        };\n        this.variables = this.options.variables;\n      }\n\n      result = {\n        data,\n        loading: isNetworkRequestInFlight(networkStatus),\n        networkStatus,\n      } as ApolloQueryResult<TData>;\n\n      if (queryStoreValue.graphQLErrors && this.options.errorPolicy === 'all') {\n        result.errors = queryStoreValue.graphQLErrors;\n      }\n\n    } else {\n      // We need to be careful about the loading state we show to the user, to try\n      // and be vaguely in line with what the user would have seen from .subscribe()\n      // but to still provide useful information synchronously when the query\n      // will not end up hitting the server.\n      // See more: https://github.com/apollostack/apollo-client/issues/707\n      // Basically: is there a query in flight right now (modolo the next tick)?\n      const loading = isNetworkFetchPolicy ||\n        (partial && fetchPolicy !== 'cache-only');\n\n      result = {\n        data,\n        loading,\n        networkStatus: loading ? NetworkStatus.loading : NetworkStatus.ready,\n      } as ApolloQueryResult<TData>;\n    }\n\n    if (!partial) {\n      this.updateLastResult({ ...result, stale: false });\n    }\n\n    return { ...result, partial };\n  }\n\n  // Compares newResult to the snapshot we took of this.lastResult when it was\n  // first received.\n  public isDifferentFromLastResult(newResult: ApolloQueryResult<TData>) {\n    const { lastResultSnapshot: snapshot } = this;\n    return !(\n      snapshot &&\n      newResult &&\n      snapshot.networkStatus === newResult.networkStatus &&\n      snapshot.stale === newResult.stale &&\n      isEqual(snapshot.data, newResult.data)\n    );\n  }\n\n  // Returns the last result that observer.next was called with. This is not the same as\n  // getCurrentResult! If you're not sure which you need, then you probably need getCurrentResult.\n  public getLastResult(): ApolloQueryResult<TData> {\n    return this.lastResult;\n  }\n\n  public getLastError(): ApolloError {\n    return this.lastError;\n  }\n\n  public resetLastResults(): void {\n    delete this.lastResult;\n    delete this.lastResultSnapshot;\n    delete this.lastError;\n    this.isTornDown = false;\n  }\n\n  public resetQueryStoreErrors() {\n    const queryStore = this.queryManager.queryStore.get(this.queryId);\n    if (queryStore) {\n      queryStore.networkError = null;\n      queryStore.graphQLErrors = [];\n    }\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results.\n   * This method should be preferred over `setVariables` in most use cases.\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public refetch(variables?: TVariables): Promise<ApolloQueryResult<TData>> {\n    let { fetchPolicy } = this.options;\n    // early return if trying to read from cache during refetch\n    if (fetchPolicy === 'cache-only') {\n      return Promise.reject(new InvariantError(\n        'cache-only fetchPolicy option should not be used together with query refetch.',\n      ));\n    }\n\n    // Unless the provided fetchPolicy always consults the network\n    // (no-cache, network-only, or cache-and-network), override it with\n    // network-only to force the refetch for this fetchQuery call.\n    if (fetchPolicy !== 'no-cache' &&\n        fetchPolicy !== 'cache-and-network') {\n      fetchPolicy = 'network-only';\n    }\n\n    if (!isEqual(this.variables, variables)) {\n      // update observable variables\n      this.variables = {\n        ...this.variables,\n        ...variables,\n      };\n    }\n\n    if (!isEqual(this.options.variables, this.variables)) {\n      // Update the existing options with new variables\n      this.options.variables = {\n        ...this.options.variables,\n        ...this.variables,\n      };\n    }\n\n    return this.queryManager.fetchQuery(\n      this.queryId,\n      { ...this.options, fetchPolicy },\n      FetchType.refetch,\n    ) as Promise<ApolloQueryResult<TData>>;\n  }\n\n  public fetchMore<K extends keyof TVariables>(\n    fetchMoreOptions: FetchMoreQueryOptions<TVariables, K> &\n      FetchMoreOptions<TData, TVariables>,\n  ): Promise<ApolloQueryResult<TData>> {\n    // early return if no update Query\n    invariant(\n      fetchMoreOptions.updateQuery,\n      'updateQuery option is required. This function defines how to update the query data with the new results.',\n    );\n\n    const combinedOptions = {\n      ...(fetchMoreOptions.query ? fetchMoreOptions : {\n        ...this.options,\n        ...fetchMoreOptions,\n        variables: {\n          ...this.variables,\n          ...fetchMoreOptions.variables,\n        },\n      }),\n      fetchPolicy: 'network-only',\n    } as WatchQueryOptions;\n\n    const qid = this.queryManager.generateQueryId();\n\n    return this.queryManager\n      .fetchQuery(\n        qid,\n        combinedOptions,\n        FetchType.normal,\n        this.queryId,\n      )\n      .then(\n        fetchMoreResult => {\n          this.updateQuery((previousResult: any) =>\n            fetchMoreOptions.updateQuery(previousResult, {\n              fetchMoreResult: fetchMoreResult.data as TData,\n              variables: combinedOptions.variables as TVariables,\n            }),\n          );\n          this.queryManager.stopQuery(qid);\n          return fetchMoreResult as ApolloQueryResult<TData>;\n        },\n        error => {\n          this.queryManager.stopQuery(qid);\n          throw error;\n        },\n      );\n  }\n\n  // XXX the subscription variables are separate from the query variables.\n  // if you want to update subscription variables, right now you have to do that separately,\n  // and you can only do it by stopping the subscription and then subscribing again with new variables.\n  public subscribeToMore<\n    TSubscriptionData = TData,\n    TSubscriptionVariables = TVariables\n  >(\n    options: SubscribeToMoreOptions<\n      TData,\n      TSubscriptionVariables,\n      TSubscriptionData\n    >,\n  ) {\n    const subscription = this.queryManager\n      .startGraphQLSubscription({\n        query: options.document,\n        variables: options.variables,\n      })\n      .subscribe({\n        next: (subscriptionData: { data: TSubscriptionData }) => {\n          const { updateQuery } = options;\n          if (updateQuery) {\n            this.updateQuery<TSubscriptionVariables>(\n              (previous, { variables }) =>\n                updateQuery(previous, {\n                  subscriptionData,\n                  variables,\n                }),\n            );\n          }\n        },\n        error: (err: any) => {\n          if (options.onError) {\n            options.onError(err);\n            return;\n          }\n          invariant.error('Unhandled GraphQL subscription error', err);\n        },\n      });\n\n    this.subscriptions.add(subscription);\n\n    return () => {\n      if (this.subscriptions.delete(subscription)) {\n        subscription.unsubscribe();\n      }\n    };\n  }\n\n  // Note: if the query is not active (there are no subscribers), the promise\n  // will return null immediately.\n  public setOptions(\n    opts: WatchQueryOptions,\n  ): Promise<ApolloQueryResult<TData> | void> {\n    const { fetchPolicy: oldFetchPolicy } = this.options;\n    this.options = {\n      ...this.options,\n      ...opts,\n    } as WatchQueryOptions<TVariables>;\n\n    if (opts.pollInterval) {\n      this.startPolling(opts.pollInterval);\n    } else if (opts.pollInterval === 0) {\n      this.stopPolling();\n    }\n\n    const { fetchPolicy } = opts;\n\n    return this.setVariables(\n      this.options.variables as TVariables,\n      // Try to fetch the query if fetchPolicy changed from either cache-only\n      // or standby to something else, or changed to network-only.\n      oldFetchPolicy !== fetchPolicy && (\n        oldFetchPolicy === 'cache-only' ||\n        oldFetchPolicy === 'standby' ||\n        fetchPolicy === 'network-only'\n      ),\n      opts.fetchResults,\n    );\n  }\n\n  /**\n   * This is for *internal* use only. Most users should instead use `refetch`\n   * in order to be properly notified of results even when they come from cache.\n   *\n   * Update the variables of this observable query, and fetch the new results\n   * if they've changed. If you want to force new results, use `refetch`.\n   *\n   * Note: the `next` callback will *not* fire if the variables have not changed\n   * or if the result is coming from cache.\n   *\n   * Note: the promise will return the old results immediately if the variables\n   * have not changed.\n   *\n   * Note: the promise will return null immediately if the query is not active\n   * (there are no subscribers).\n   *\n   * @private\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   *\n   * @param tryFetch: Try and fetch new results even if the variables haven't\n   * changed (we may still just hit the store, but if there's nothing in there\n   * this will refetch)\n   *\n   * @param fetchResults: Option to ignore fetching results when updating variables\n   */\n  public setVariables(\n    variables: TVariables,\n    tryFetch: boolean = false,\n    fetchResults = true,\n  ): Promise<ApolloQueryResult<TData> | void> {\n    // since setVariables restarts the subscription, we reset the tornDown status\n    this.isTornDown = false;\n\n    variables = variables || this.variables;\n\n    if (!tryFetch && isEqual(variables, this.variables)) {\n      // If we have no observers, then we don't actually want to make a network\n      // request. As soon as someone observes the query, the request will kick\n      // off. For now, we just store any changes. (See #1077)\n      return this.observers.size && fetchResults\n        ? this.result()\n        : Promise.resolve();\n    }\n\n    this.variables = this.options.variables = variables;\n\n    // See comment above\n    if (!this.observers.size) {\n      return Promise.resolve();\n    }\n\n    // Use the same options as before, but with new variables\n    return this.queryManager.fetchQuery(\n      this.queryId,\n      this.options,\n    ) as Promise<ApolloQueryResult<TData>>;\n  }\n\n  public updateQuery<TVars = TVariables>(\n    mapFn: (\n      previousQueryResult: TData,\n      options: UpdateQueryOptions<TVars>,\n    ) => TData,\n  ): void {\n    const { queryManager } = this;\n    const {\n      previousResult,\n      variables,\n      document,\n    } = queryManager.getQueryWithPreviousResult<TData, TVars>(\n      this.queryId,\n    );\n\n    const newResult = tryFunctionOrLogError(() =>\n      mapFn(previousResult, { variables }),\n    );\n\n    if (newResult) {\n      queryManager.dataStore.markUpdateQueryResult(\n        document,\n        variables,\n        newResult,\n      );\n      queryManager.broadcastQueries();\n    }\n  }\n\n  public stopPolling() {\n    this.queryManager.stopPollingQuery(this.queryId);\n    this.options.pollInterval = undefined;\n  }\n\n  public startPolling(pollInterval: number) {\n    assertNotCacheFirstOrOnly(this);\n    this.options.pollInterval = pollInterval;\n    this.queryManager.startPollingQuery(this.options, this.queryId);\n  }\n\n  private updateLastResult(newResult: ApolloQueryResult<TData>) {\n    const previousResult = this.lastResult;\n    this.lastResult = newResult;\n    this.lastResultSnapshot = this.queryManager.assumeImmutableResults\n      ? newResult\n      : cloneDeep(newResult);\n    return previousResult;\n  }\n\n  private onSubscribe(observer: Observer<ApolloQueryResult<TData>>) {\n    // Zen Observable has its own error function, so in order to log correctly\n    // we need to provide a custom error callback.\n    try {\n      var subObserver = (observer as any)._subscription._observer;\n      if (subObserver && !subObserver.error) {\n        subObserver.error = defaultSubscriptionObserverErrorCallback;\n      }\n    } catch {}\n\n    const first = !this.observers.size;\n    this.observers.add(observer);\n\n    // Deliver initial result\n    if (observer.next && this.lastResult) observer.next(this.lastResult);\n    if (observer.error && this.lastError) observer.error(this.lastError);\n\n    // setup the query if it hasn't been done before\n    if (first) {\n      this.setUpQuery();\n    }\n\n    return () => {\n      if (this.observers.delete(observer) && !this.observers.size) {\n        this.tearDownQuery();\n      }\n    };\n  }\n\n  private setUpQuery() {\n    const { queryManager, queryId } = this;\n\n    if (this.shouldSubscribe) {\n      queryManager.addObservableQuery<TData>(queryId, this);\n    }\n\n    if (this.options.pollInterval) {\n      assertNotCacheFirstOrOnly(this);\n      queryManager.startPollingQuery(this.options, queryId);\n    }\n\n    const onError = (error: ApolloError) => {\n      // Since we don't get the current result on errors, only the error, we\n      // must mirror the updates that occur in QueryStore.markQueryError here\n      this.updateLastResult({\n        ...this.lastResult,\n        errors: error.graphQLErrors,\n        networkStatus: NetworkStatus.error,\n        loading: false,\n      });\n      iterateObserversSafely(this.observers, 'error', this.lastError = error);\n    };\n\n    queryManager.observeQuery<TData>(queryId, this.options, {\n      next: (result: ApolloQueryResult<TData>) => {\n        if (this.lastError || this.isDifferentFromLastResult(result)) {\n          const previousResult = this.updateLastResult(result);\n          const { query, variables, fetchPolicy } = this.options;\n\n          // Before calling `next` on each observer, we need to first see if\n          // the query is using `@client @export` directives, and update\n          // any variables that might have changed. If `@export` variables have\n          // changed, and the query is calling against both local and remote\n          // data, a refetch is needed to pull in new data, using the\n          // updated `@export` variables.\n          if (queryManager.transform(query).hasClientExports) {\n            queryManager.getLocalState().addExportedVariables(\n              query,\n              variables,\n            ).then((variables: TVariables) => {\n              const previousVariables = this.variables;\n              this.variables = this.options.variables = variables;\n              if (\n                !result.loading &&\n                previousResult &&\n                fetchPolicy !== 'cache-only' &&\n                queryManager.transform(query).serverQuery &&\n                !isEqual(previousVariables, variables)\n              ) {\n                this.refetch();\n              } else {\n                iterateObserversSafely(this.observers, 'next', result);\n              }\n            });\n          } else {\n            iterateObserversSafely(this.observers, 'next', result);\n          }\n        }\n      },\n      error: onError,\n    }).catch(onError);\n  }\n\n  private tearDownQuery() {\n    const { queryManager } = this;\n\n    this.isTornDown = true;\n    queryManager.stopPollingQuery(this.queryId);\n\n    // stop all active GraphQL subscriptions\n    this.subscriptions.forEach(sub => sub.unsubscribe());\n    this.subscriptions.clear();\n\n    queryManager.removeObservableQuery(this.queryId);\n    queryManager.stopQuery(this.queryId);\n\n    this.observers.clear();\n  }\n}\n\nfunction defaultSubscriptionObserverErrorCallback(error: ApolloError) {\n  invariant.error('Unhandled error', error.message, error.stack);\n}\n\nfunction iterateObserversSafely<E, A>(\n  observers: Set<Observer<E>>,\n  method: keyof Observer<E>,\n  argument?: A,\n) {\n  // In case observers is modified during iteration, we need to commit to the\n  // original elements, which also provides an opportunity to filter them down\n  // to just the observers with the given method.\n  const observersWithMethod: Observer<E>[] = [];\n  observers.forEach(obs => obs[method] && observersWithMethod.push(obs));\n  observersWithMethod.forEach(obs => (obs as any)[method](argument));\n}\n\nfunction assertNotCacheFirstOrOnly<TData, TVariables>(\n  obsQuery: ObservableQuery<TData, TVariables>,\n) {\n  const { fetchPolicy } = obsQuery.options;\n  invariant(\n    fetchPolicy !== 'cache-first' && fetchPolicy !== 'cache-only',\n    'Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.',\n  );\n}\n","import { DocumentNode } from 'graphql';\n\nexport class MutationStore {\n  private store: { [mutationId: string]: MutationStoreValue } = {};\n\n  public getStore(): { [mutationId: string]: MutationStoreValue } {\n    return this.store;\n  }\n\n  public get(mutationId: string): MutationStoreValue {\n    return this.store[mutationId];\n  }\n\n  public initMutation(\n    mutationId: string,\n    mutation: DocumentNode,\n    variables: Object | undefined,\n  ) {\n    this.store[mutationId] = {\n      mutation,\n      variables: variables || {},\n      loading: true,\n      error: null,\n    };\n  }\n\n  public markMutationError(mutationId: string, error: Error) {\n    const mutation = this.store[mutationId];\n    if (mutation) {\n      mutation.loading = false;\n      mutation.error = error;\n    }\n  }\n\n  public markMutationResult(mutationId: string) {\n    const mutation = this.store[mutationId];\n    if (mutation) {\n      mutation.loading = false;\n      mutation.error = null;\n    }\n  }\n\n  public reset() {\n    this.store = {};\n  }\n}\n\nexport interface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Object;\n  loading: boolean;\n  error: Error | null;\n}\n","import { DocumentNode, GraphQLError, ExecutionResult } from 'graphql';\nimport { isEqual } from 'apollo-utilities';\nimport { invariant } from 'ts-invariant';\nimport { NetworkStatus } from '../core/networkStatus';\nimport { isNonEmptyArray } from '../util/arrays';\n\nexport type QueryStoreValue = {\n  document: DocumentNode;\n  variables: Object;\n  previousVariables?: Object | null;\n  networkStatus: NetworkStatus;\n  networkError?: Error | null;\n  graphQLErrors?: ReadonlyArray<GraphQLError>;\n  metadata: any;\n};\n\nexport class QueryStore {\n  private store: { [queryId: string]: QueryStoreValue } = {};\n\n  public getStore(): { [queryId: string]: QueryStoreValue } {\n    return this.store;\n  }\n\n  public get(queryId: string): QueryStoreValue {\n    return this.store[queryId];\n  }\n\n  public initQuery(query: {\n    queryId: string;\n    document: DocumentNode;\n    storePreviousVariables: boolean;\n    variables: Object;\n    isPoll: boolean;\n    isRefetch: boolean;\n    metadata: any;\n    fetchMoreForQueryId: string | undefined;\n  }) {\n    const previousQuery = this.store[query.queryId];\n\n    // XXX we're throwing an error here to catch bugs where a query gets overwritten by a new one.\n    // we should implement a separate action for refetching so that QUERY_INIT may never overwrite\n    // an existing query (see also: https://github.com/apollostack/apollo-client/issues/732)\n    invariant(\n      !previousQuery ||\n      previousQuery.document === query.document ||\n      isEqual(previousQuery.document, query.document),\n      'Internal Error: may not update existing query string in store',\n    );\n\n    let isSetVariables = false;\n\n    let previousVariables: Object | null = null;\n    if (\n      query.storePreviousVariables &&\n      previousQuery &&\n      previousQuery.networkStatus !== NetworkStatus.loading\n      // if the previous query was still loading, we don't want to remember it at all.\n    ) {\n      if (!isEqual(previousQuery.variables, query.variables)) {\n        isSetVariables = true;\n        previousVariables = previousQuery.variables;\n      }\n    }\n\n    // TODO break this out into a separate function\n    let networkStatus;\n    if (isSetVariables) {\n      networkStatus = NetworkStatus.setVariables;\n    } else if (query.isPoll) {\n      networkStatus = NetworkStatus.poll;\n    } else if (query.isRefetch) {\n      networkStatus = NetworkStatus.refetch;\n      // TODO: can we determine setVariables here if it's a refetch and the variables have changed?\n    } else {\n      networkStatus = NetworkStatus.loading;\n    }\n\n    let graphQLErrors: ReadonlyArray<GraphQLError> = [];\n    if (previousQuery && previousQuery.graphQLErrors) {\n      graphQLErrors = previousQuery.graphQLErrors;\n    }\n\n    // XXX right now if QUERY_INIT is fired twice, like in a refetch situation, we just overwrite\n    // the store. We probably want a refetch action instead, because I suspect that if you refetch\n    // before the initial fetch is done, you'll get an error.\n    this.store[query.queryId] = {\n      document: query.document,\n      variables: query.variables,\n      previousVariables,\n      networkError: null,\n      graphQLErrors: graphQLErrors,\n      networkStatus,\n      metadata: query.metadata,\n    };\n\n    // If the action had a `moreForQueryId` property then we need to set the\n    // network status on that query as well to `fetchMore`.\n    //\n    // We have a complement to this if statement in the query result and query\n    // error action branch, but importantly *not* in the client result branch.\n    // This is because the implementation of `fetchMore` *always* sets\n    // `fetchPolicy` to `network-only` so we would never have a client result.\n    if (\n      typeof query.fetchMoreForQueryId === 'string' &&\n      this.store[query.fetchMoreForQueryId]\n    ) {\n      this.store[query.fetchMoreForQueryId].networkStatus =\n        NetworkStatus.fetchMore;\n    }\n  }\n\n  public markQueryResult(\n    queryId: string,\n    result: ExecutionResult,\n    fetchMoreForQueryId: string | undefined,\n  ) {\n    if (!this.store || !this.store[queryId]) return;\n\n    this.store[queryId].networkError = null;\n    this.store[queryId].graphQLErrors = isNonEmptyArray(result.errors) ? result.errors : [];\n    this.store[queryId].previousVariables = null;\n    this.store[queryId].networkStatus = NetworkStatus.ready;\n\n    // If we have a `fetchMoreForQueryId` then we need to update the network\n    // status for that query. See the branch for query initialization for more\n    // explanation about this process.\n    if (\n      typeof fetchMoreForQueryId === 'string' &&\n      this.store[fetchMoreForQueryId]\n    ) {\n      this.store[fetchMoreForQueryId].networkStatus = NetworkStatus.ready;\n    }\n  }\n\n  public markQueryError(\n    queryId: string,\n    error: Error,\n    fetchMoreForQueryId: string | undefined,\n  ) {\n    if (!this.store || !this.store[queryId]) return;\n\n    this.store[queryId].networkError = error;\n    this.store[queryId].networkStatus = NetworkStatus.error;\n\n    // If we have a `fetchMoreForQueryId` then we need to update the network\n    // status for that query. See the branch for query initialization for more\n    // explanation about this process.\n    if (typeof fetchMoreForQueryId === 'string') {\n      this.markQueryResultClient(fetchMoreForQueryId, true);\n    }\n  }\n\n  public markQueryResultClient(queryId: string, complete: boolean) {\n    const storeValue = this.store && this.store[queryId];\n    if (storeValue) {\n      storeValue.networkError = null;\n      storeValue.previousVariables = null;\n      if (complete) {\n        storeValue.networkStatus = NetworkStatus.ready;\n      }\n    }\n  }\n\n  public stopQuery(queryId: string) {\n    delete this.store[queryId];\n  }\n\n  public reset(observableQueryIds: string[]) {\n    Object.keys(this.store).forEach(queryId => {\n      if (observableQueryIds.indexOf(queryId) < 0) {\n        this.stopQuery(queryId);\n      } else {\n        // XXX set loading to true so listeners don't trigger unless they want results with partial data\n        this.store[queryId].networkStatus = NetworkStatus.loading;\n      }\n    });\n  }\n}\n","export function capitalizeFirstLetter(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n","import {\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  SelectionNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  FieldNode,\n  ASTNode,\n} from 'graphql';\nimport { visit, BREAK } from 'graphql/language/visitor';\n\nimport { ApolloCache } from 'apollo-cache';\nimport {\n  getMainDefinition,\n  buildQueryFromSelectionSet,\n  hasDirectives,\n  removeClientSetsFromDocument,\n  mergeDeep,\n  mergeDeepArray,\n  FragmentMap,\n  argumentsObjectFromField,\n  resultKeyNameFromField,\n  getFragmentDefinitions,\n  createFragmentMap,\n  shouldInclude,\n  isField,\n  isInlineFragment,\n} from 'apollo-utilities';\nimport { FetchResult } from 'apollo-link';\n\nimport { invariant } from 'ts-invariant';\n\nimport ApolloClient from '../ApolloClient';\nimport { Resolvers, OperationVariables } from './types';\nimport { capitalizeFirstLetter } from '../util/capitalizeFirstLetter';\n\nexport type Resolver = (\n  rootValue?: any,\n  args?: any,\n  context?: any,\n  info?: {\n    field: FieldNode;\n    fragmentMap: FragmentMap;\n  },\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any,\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  context: any;\n  variables: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n  defaultOperationType: string;\n  exportedVariables: Record<string, any>;\n  onlyRunForcedResolvers: boolean;\n};\n\nexport type LocalStateOptions<TCacheShape> = {\n  cache: ApolloCache<TCacheShape>;\n  client?: ApolloClient<TCacheShape>;\n  resolvers?: Resolvers | Resolvers[];\n  fragmentMatcher?: FragmentMatcher;\n};\n\nexport class LocalState<TCacheShape> {\n  private cache: ApolloCache<TCacheShape>;\n  private client: ApolloClient<TCacheShape>;\n  private resolvers?: Resolvers;\n  private fragmentMatcher: FragmentMatcher;\n\n  constructor({\n    cache,\n    client,\n    resolvers,\n    fragmentMatcher,\n  }: LocalStateOptions<TCacheShape>) {\n    this.cache = cache;\n\n    if (client) {\n      this.client = client;\n    }\n\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = this.resolvers || {};\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach(resolverGroup => {\n        this.resolvers = mergeDeep(this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  }\n\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  }\n\n  public getResolvers() {\n    return this.resolvers || {};\n  }\n\n  // Run local client resolvers against the incoming query and remote data.\n  // Locally resolved field values are merged with the incoming remote data,\n  // and returned. Note that locally resolved fields will overwrite\n  // remote data using the same field name.\n  public async runResolvers<TData>({\n    document,\n    remoteResult,\n    context,\n    variables,\n    onlyRunForcedResolvers = false,\n  }: {\n    document: DocumentNode | null;\n    remoteResult: FetchResult<TData>;\n    context?: Record<string, any>;\n    variables?: Record<string, any>;\n    onlyRunForcedResolvers?: boolean;\n  }): Promise<FetchResult<TData>> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        remoteResult.data,\n        context,\n        variables,\n        this.fragmentMatcher,\n        onlyRunForcedResolvers,\n      ).then(localResult => ({\n        ...remoteResult,\n        data: localResult.result,\n      }));\n    }\n\n    return remoteResult;\n  }\n\n  public setFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  }\n\n  public getFragmentMatcher(): FragmentMatcher {\n    return this.fragmentMatcher;\n  }\n\n  // Client queries contain everything in the incoming document (if a @client\n  // directive is found).\n  public clientQuery(document: DocumentNode) {\n    if (hasDirectives(['client'], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n      invariant.warn(\n        'Found @client directives in a query but no ApolloClient resolvers ' +\n        'were specified. This means ApolloClient local resolver handling ' +\n        'has been disabled, and @client directives will be passed through ' +\n        'to your link chain.',\n      );\n    }\n    return null;\n  }\n\n  // Server queries are stripped of all @client based selection sets.\n  public serverQuery(document: DocumentNode) {\n    return this.resolvers ? removeClientSetsFromDocument(document) : document;\n  }\n\n  public prepareContext(context = {}) {\n    const { cache } = this;\n\n    const newContext = {\n      ...context,\n      cache,\n      // Getting an entry's cache key is useful for local state resolvers.\n      getCacheKey: (obj: { __typename: string; id: string | number }) => {\n        if ((cache as any).config) {\n          return (cache as any).config.dataIdFromObject(obj);\n        } else {\n          invariant(false,\n            'To use context.getCacheKey, you need to use a cache that has ' +\n              'a configurable dataIdFromObject, like apollo-cache-inmemory.',\n          );\n        }\n      },\n    };\n\n    return newContext;\n  }\n\n  // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n  // @client @export fields locally, then pass the resolved values back to be\n  // used alongside the original operation variables.\n  public async addExportedVariables(\n    document: DocumentNode,\n    variables: OperationVariables = {},\n    context = {},\n  ) {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        this.buildRootValueFromCache(document, variables) || {},\n        this.prepareContext(context),\n        variables,\n      ).then(data => ({\n        ...variables,\n        ...data.exportedVariables,\n      }));\n    }\n\n    return {\n      ...variables,\n    };\n  }\n\n  public shouldForceResolvers(document: ASTNode) {\n    let forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter(node) {\n          if (node.name.value === 'client' && node.arguments) {\n            forceResolvers = node.arguments.some(\n              arg =>\n                arg.name.value === 'always' &&\n                arg.value.kind === 'BooleanValue' &&\n                arg.value.value === true,\n            );\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        },\n      },\n    });\n    return forceResolvers;\n  }\n\n  // Query the cache and return matching data.\n  private buildRootValueFromCache(\n    document: DocumentNode,\n    variables?: Record<string, any>,\n  ) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables,\n      returnPartialData: true,\n      optimistic: false,\n    }).result;\n  }\n\n  private async resolveDocument<TData>(\n    document: DocumentNode,\n    rootValue: TData,\n    context: any = {},\n    variables: VariableMap = {},\n    fragmentMatcher: FragmentMatcher = () => true,\n    onlyRunForcedResolvers: boolean = false,\n  ) {\n    const mainDefinition = getMainDefinition(document);\n    const fragments = getFragmentDefinitions(document);\n    const fragmentMap = createFragmentMap(fragments);\n\n    const definitionOperation = (mainDefinition as OperationDefinitionNode)\n      .operation;\n\n    const defaultOperationType = definitionOperation\n      ? capitalizeFirstLetter(definitionOperation)\n      : 'Query';\n\n    const { cache, client } = this;\n    const execContext: ExecContext = {\n      fragmentMap,\n      context: {\n        ...context,\n        cache,\n        client,\n      },\n      variables,\n      fragmentMatcher,\n      defaultOperationType,\n      exportedVariables: {},\n      onlyRunForcedResolvers,\n    };\n\n    return this.resolveSelectionSet(\n      mainDefinition.selectionSet,\n      rootValue,\n      execContext,\n    ).then(result => ({\n      result,\n      exportedVariables: execContext.exportedVariables,\n    }));\n  }\n\n  private async resolveSelectionSet<TData>(\n    selectionSet: SelectionSetNode,\n    rootValue: TData,\n    execContext: ExecContext,\n  ) {\n    const { fragmentMap, context, variables } = execContext;\n    const resultsToMerge: TData[] = [rootValue];\n\n    const execute = async (selection: SelectionNode): Promise<void> => {\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely.\n        return;\n      }\n\n      if (isField(selection)) {\n        return this.resolveField(selection, rootValue, execContext).then(\n          fieldResult => {\n            if (typeof fieldResult !== 'undefined') {\n              resultsToMerge.push({\n                [resultKeyNameFromField(selection)]: fieldResult,\n              } as TData);\n            }\n          },\n        );\n      }\n\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment.\n        fragment = fragmentMap[selection.name.value];\n        invariant(fragment, `No fragment named ${selection.name.value}`);\n      }\n\n      if (fragment && fragment.typeCondition) {\n        const typeCondition = fragment.typeCondition.name.value;\n        if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n          return this.resolveSelectionSet(\n            fragment.selectionSet,\n            rootValue,\n            execContext,\n          ).then(fragmentResult => {\n            resultsToMerge.push(fragmentResult);\n          });\n        }\n      }\n    };\n\n    return Promise.all(selectionSet.selections.map(execute)).then(function() {\n      return mergeDeepArray(resultsToMerge);\n    });\n  }\n\n  private async resolveField(\n    field: FieldNode,\n    rootValue: any,\n    execContext: ExecContext,\n  ): Promise<any> {\n    const { variables } = execContext;\n    const fieldName = field.name.value;\n    const aliasedFieldName = resultKeyNameFromField(field);\n    const aliasUsed = fieldName !== aliasedFieldName;\n    const defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n    let resultPromise = Promise.resolve(defaultResult);\n\n    // Usually all local resolvers are run when passing through here, but\n    // if we've specifically identified that we only want to run forced\n    // resolvers (that is, resolvers for fields marked with\n    // `@client(always: true)`), then we'll skip running non-forced resolvers.\n    if (\n      !execContext.onlyRunForcedResolvers ||\n      this.shouldForceResolvers(field)\n    ) {\n      const resolverType =\n        rootValue.__typename || execContext.defaultOperationType;\n      const resolverMap = this.resolvers && this.resolvers[resolverType];\n      if (resolverMap) {\n        const resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n        if (resolve) {\n          resultPromise = Promise.resolve(resolve(\n            rootValue,\n            argumentsObjectFromField(field, variables),\n            execContext.context,\n            { field, fragmentMap: execContext.fragmentMap },\n          ));\n        }\n      }\n    }\n\n    return resultPromise.then((result = defaultResult) => {\n      // If an @export directive is associated with the current field, store\n      // the `as` export variable name and current result for later use.\n      if (field.directives) {\n        field.directives.forEach(directive => {\n          if (directive.name.value === 'export' && directive.arguments) {\n            directive.arguments.forEach(arg => {\n              if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {\n                execContext.exportedVariables[arg.value.value] = result;\n              }\n            });\n          }\n        });\n      }\n\n      // Handle all scalar types here.\n      if (!field.selectionSet) {\n        return result;\n      }\n\n      // From here down, the field has a selection set, which means it's trying\n      // to query a GraphQLObjectType.\n      if (result == null) {\n        // Basically any field in a GraphQL response can be null, or missing\n        return result;\n      }\n\n      if (Array.isArray(result)) {\n        return this.resolveSubSelectedArray(field, result, execContext);\n      }\n\n      // Returned value is an object, and the query has a sub-selection. Recurse.\n      if (field.selectionSet) {\n        return this.resolveSelectionSet(\n          field.selectionSet,\n          result,\n          execContext,\n        );\n      }\n    });\n  }\n\n  private resolveSubSelectedArray(\n    field: FieldNode,\n    result: any[],\n    execContext: ExecContext,\n  ): any {\n    return Promise.all(\n      result.map(item => {\n        if (item === null) {\n          return null;\n        }\n\n        // This is a nested array, recurse.\n        if (Array.isArray(item)) {\n          return this.resolveSubSelectedArray(field, item, execContext);\n        }\n\n        // This is an object, run the selection set on it.\n        if (field.selectionSet) {\n          return this.resolveSelectionSet(field.selectionSet, item, execContext);\n        }\n      }),\n    );\n  }\n}\n","import { Observable, Observer, Subscription } from './Observable';\n\n// Returns a normal Observable that can have any number of subscribers,\n// while ensuring the original Observable gets subscribed to at most once.\nexport function multiplex<T>(inner: Observable<T>): Observable<T> {\n  const observers = new Set<Observer<T>>();\n  let sub: Subscription | null = null;\n  return new Observable<T>(observer => {\n    observers.add(observer);\n    sub = sub || inner.subscribe({\n      next(value) {\n        observers.forEach(obs => obs.next && obs.next(value));\n      },\n      error(error) {\n        observers.forEach(obs => obs.error && obs.error(error));\n      },\n      complete() {\n        observers.forEach(obs => obs.complete && obs.complete());\n      },\n    });\n    return () => {\n      if (observers.delete(observer) && !observers.size && sub) {\n        sub.unsubscribe();\n        sub = null;\n      }\n    };\n  });\n}\n\n// Like Observable.prototype.map, except that the mapping function can\n// optionally return a Promise (or be async).\nexport function asyncMap<V, R>(\n  observable: Observable<V>,\n  mapFn: (value: V) => R | Promise<R>,\n): Observable<R> {\n  return new Observable<R>(observer => {\n    const { next, error, complete } = observer;\n    let activeNextCount = 0;\n    let completed = false;\n\n    const handler: Observer<V> = {\n      next(value) {\n        ++activeNextCount;\n        new Promise(resolve => {\n          resolve(mapFn(value));\n        }).then(\n          result => {\n            --activeNextCount;\n            next && next.call(observer, result);\n            completed && handler.complete!();\n          },\n          e => {\n            --activeNextCount;\n            error && error.call(observer, e);\n          },\n        );\n      },\n      error(e) {\n        error && error.call(observer, e);\n      },\n      complete() {\n        completed = true;\n        if (!activeNextCount) {\n          complete && complete.call(observer);\n        }\n      },\n    };\n\n    const sub = observable.subscribe(handler);\n    return () => sub.unsubscribe();\n  });\n}\n","import { execute, ApolloLink, FetchResult } from 'apollo-link';\nimport { DocumentNode } from 'graphql';\nimport { Cache } from 'apollo-cache';\nimport {\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  hasDirectives,\n  graphQLResultHasError,\n  hasClientExports,\n  removeConnectionDirectiveFromDocument,\n  canUseWeakMap,\n} from 'apollo-utilities';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { isApolloError, ApolloError } from '../errors/ApolloError';\nimport { Observer, Subscription, Observable } from '../util/Observable';\nimport { QueryWithUpdater, DataStore } from '../data/store';\nimport { MutationStore } from '../data/mutations';\nimport { QueryStore, QueryStoreValue } from '../data/queries';\n\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  ErrorPolicy,\n} from './watchQueryOptions';\nimport { ObservableQuery } from './ObservableQuery';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport {\n  QueryListener,\n  ApolloQueryResult,\n  FetchType,\n  OperationVariables,\n} from './types';\nimport { LocalState } from './LocalState';\nimport { asyncMap, multiplex } from '../util/observables';\nimport { isNonEmptyArray } from '../util/arrays';\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport interface QueryInfo {\n  listeners: Set<QueryListener>;\n  invalidated: boolean;\n  newData: Cache.DiffResult<any> | null;\n  document: DocumentNode | null;\n  lastRequestId: number;\n  // A map going from queryId to an observer for a query issued by watchQuery. We use\n  // these to keep track of queries that are inflight and error on the observers associated\n  // with them in case of some destabalizing action (e.g. reset of the Apollo store).\n  observableQuery: ObservableQuery<any> | null;\n  subscriptions: Set<Subscription>;\n  cancel?: () => void;\n}\n\nexport class QueryManager<TStore> {\n  public link: ApolloLink;\n  public mutationStore: MutationStore = new MutationStore();\n  public queryStore: QueryStore = new QueryStore();\n  public dataStore: DataStore<TStore>;\n  public readonly assumeImmutableResults: boolean;\n\n  private queryDeduplication: boolean;\n  private clientAwareness: Record<string, string> = {};\n  private localState: LocalState<TStore>;\n\n  private onBroadcast: () => void;\n\n  private ssrMode: boolean;\n\n  // let's not start at zero to avoid pain with bad checks\n  private idCounter = 1;\n\n  // XXX merge with ObservableQuery but that needs to be expanded to support mutations and\n  // subscriptions as well\n  private queries: Map<string, QueryInfo> = new Map();\n\n  // A map of Promise reject functions for fetchQuery promises that have not\n  // yet been resolved, used to keep track of in-flight queries so that we can\n  // reject them in case a destabilizing event occurs (e.g. Apollo store reset).\n  // The key is in the format of `query:${queryId}` or `fetchRequest:${queryId}`,\n  // depending on where the promise's rejection function was created from.\n  private fetchQueryRejectFns = new Map<string, Function>();\n\n  constructor({\n    link,\n    queryDeduplication = false,\n    store,\n    onBroadcast = () => undefined,\n    ssrMode = false,\n    clientAwareness = {},\n    localState,\n    assumeImmutableResults,\n  }: {\n    link: ApolloLink;\n    queryDeduplication?: boolean;\n    store: DataStore<TStore>;\n    onBroadcast?: () => void;\n    ssrMode?: boolean;\n    clientAwareness?: Record<string, string>;\n    localState?: LocalState<TStore>;\n    assumeImmutableResults?: boolean;\n  }) {\n    this.link = link;\n    this.queryDeduplication = queryDeduplication;\n    this.dataStore = store;\n    this.onBroadcast = onBroadcast;\n    this.clientAwareness = clientAwareness;\n    this.localState = localState || new LocalState({ cache: store.getCache() });\n    this.ssrMode = ssrMode;\n    this.assumeImmutableResults = !!assumeImmutableResults;\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.queries.forEach((_info, queryId) => {\n      this.stopQueryNoBroadcast(queryId);\n    });\n\n    this.fetchQueryRejectFns.forEach(reject => {\n      reject(\n        new InvariantError('QueryManager stopped while query was in flight'),\n      );\n    });\n  }\n\n  public async mutate<T>({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries: updateQueriesByName,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    errorPolicy = 'none',\n    fetchPolicy,\n    context = {},\n  }: MutationOptions): Promise<FetchResult<T>> {\n    invariant(\n      mutation,\n      'mutation option is required. You must specify your GraphQL document in the mutation option.',\n    );\n\n    invariant(\n      !fetchPolicy || fetchPolicy === 'no-cache',\n      \"Mutations only support a 'no-cache' fetchPolicy. If you don't want to disable the cache, remove your fetchPolicy setting to proceed with the default mutation behavior.\"\n    );\n\n    const mutationId = this.generateQueryId();\n    mutation = this.transform(mutation).document;\n\n    this.setQuery(mutationId, () => ({ document: mutation }));\n\n    variables = this.getVariables(mutation, variables);\n\n    if (this.transform(mutation).hasClientExports) {\n      variables = await this.localState.addExportedVariables(mutation, variables, context);\n    }\n\n    // Create a map of update queries by id to the query instead of by name.\n    const generateUpdateQueriesInfo: () => {\n      [queryId: string]: QueryWithUpdater;\n    } = () => {\n      const ret: { [queryId: string]: QueryWithUpdater } = {};\n\n      if (updateQueriesByName) {\n        this.queries.forEach(({ observableQuery }, queryId) => {\n          if (observableQuery) {\n            const { queryName } = observableQuery;\n            if (\n              queryName &&\n              hasOwnProperty.call(updateQueriesByName, queryName)\n            ) {\n              ret[queryId] = {\n                updater: updateQueriesByName[queryName],\n                query: this.queryStore.get(queryId),\n              };\n            }\n          }\n        });\n      }\n\n      return ret;\n    };\n\n    this.mutationStore.initMutation(\n      mutationId,\n      mutation,\n      variables,\n    );\n\n    this.dataStore.markMutationInit({\n      mutationId,\n      document: mutation,\n      variables,\n      updateQueries: generateUpdateQueriesInfo(),\n      update: updateWithProxyFn,\n      optimisticResponse,\n    });\n\n    this.broadcastQueries();\n\n    const self = this;\n\n    return new Promise((resolve, reject) => {\n      let storeResult: FetchResult<T> | null;\n      let error: ApolloError;\n\n      self.getObservableFromLink(\n        mutation,\n        {\n          ...context,\n          optimisticResponse,\n        },\n        variables,\n        false,\n      ).subscribe({\n        next(result: FetchResult<T>) {\n          if (graphQLResultHasError(result) && errorPolicy === 'none') {\n            error = new ApolloError({\n              graphQLErrors: result.errors,\n            });\n            return;\n          }\n\n          self.mutationStore.markMutationResult(mutationId);\n\n          if (fetchPolicy !== 'no-cache') {\n            self.dataStore.markMutationResult({\n              mutationId,\n              result,\n              document: mutation,\n              variables,\n              updateQueries: generateUpdateQueriesInfo(),\n              update: updateWithProxyFn,\n            });\n          }\n\n          storeResult = result;\n        },\n\n        error(err: Error) {\n          self.mutationStore.markMutationError(mutationId, err);\n          self.dataStore.markMutationComplete({\n            mutationId,\n            optimisticResponse,\n          });\n          self.broadcastQueries();\n          self.setQuery(mutationId, () => ({ document: null }));\n          reject(\n            new ApolloError({\n              networkError: err,\n            }),\n          );\n        },\n\n        complete() {\n          if (error) {\n            self.mutationStore.markMutationError(mutationId, error);\n          }\n\n          self.dataStore.markMutationComplete({\n            mutationId,\n            optimisticResponse,\n          });\n\n          self.broadcastQueries();\n\n          if (error) {\n            reject(error);\n            return;\n          }\n\n          // allow for conditional refetches\n          // XXX do we want to make this the only API one day?\n          if (typeof refetchQueries === 'function') {\n            refetchQueries = refetchQueries(storeResult!);\n          }\n\n          const refetchQueryPromises: Promise<\n            ApolloQueryResult<any>[] | ApolloQueryResult<{}>\n          >[] = [];\n\n          if (isNonEmptyArray(refetchQueries)) {\n            refetchQueries.forEach(refetchQuery => {\n              if (typeof refetchQuery === 'string') {\n                self.queries.forEach(({ observableQuery }) => {\n                  if (\n                    observableQuery &&\n                    observableQuery.queryName === refetchQuery\n                  ) {\n                    refetchQueryPromises.push(observableQuery.refetch());\n                  }\n                });\n              } else {\n                const queryOptions: QueryOptions = {\n                  query: refetchQuery.query,\n                  variables: refetchQuery.variables,\n                  fetchPolicy: 'network-only',\n                };\n\n                if (refetchQuery.context) {\n                  queryOptions.context = refetchQuery.context;\n                }\n\n                refetchQueryPromises.push(self.query(queryOptions));\n              }\n            });\n          }\n\n          Promise.all(\n            awaitRefetchQueries ? refetchQueryPromises : [],\n          ).then(() => {\n            self.setQuery(mutationId, () => ({ document: null }));\n\n            if (\n              errorPolicy === 'ignore' &&\n              storeResult &&\n              graphQLResultHasError(storeResult)\n            ) {\n              delete storeResult.errors;\n            }\n\n            resolve(storeResult!);\n          });\n        },\n      });\n    });\n  }\n\n  public async fetchQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    fetchType?: FetchType,\n    // This allows us to track if this is a query spawned by a `fetchMore`\n    // call for another query. We need this data to compute the `fetchMore`\n    // network status for the query this is fetching for.\n    fetchMoreForQueryId?: string,\n  ): Promise<FetchResult<T>> {\n    const {\n      metadata = null,\n      fetchPolicy = 'cache-first', // cache-first is the default fetch policy.\n      context = {},\n    } = options;\n\n    const query = this.transform(options.query).document;\n\n    let variables = this.getVariables(query, options.variables);\n\n    if (this.transform(query).hasClientExports) {\n      variables = await this.localState.addExportedVariables(query, variables, context);\n    }\n\n    options = { ...options, variables };\n\n    let storeResult: any;\n    const isNetworkOnly =\n      fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';\n    let needToFetch = isNetworkOnly;\n\n    // Unless we are completely skipping the cache, we want to diff the query\n    // against the cache before we fetch it from the network interface.\n    if (!isNetworkOnly) {\n      const { complete, result } = this.dataStore.getCache().diff({\n        query,\n        variables,\n        returnPartialData: true,\n        optimistic: false,\n      });\n\n      // If we're in here, only fetch if we have missing fields\n      needToFetch = !complete || fetchPolicy === 'cache-and-network';\n      storeResult = result;\n    }\n\n    let shouldFetch =\n      needToFetch && fetchPolicy !== 'cache-only' && fetchPolicy !== 'standby';\n\n    // we need to check to see if this is an operation that uses the @live directive\n    if (hasDirectives(['live'], query)) shouldFetch = true;\n\n    const requestId = this.idCounter++;\n\n    // set up a watcher to listen to cache updates\n    const cancel = fetchPolicy !== 'no-cache'\n      ? this.updateQueryWatch(queryId, query, options)\n      : undefined;\n\n    // Initialize query in store with unique requestId\n    this.setQuery(queryId, () => ({\n      document: query,\n      lastRequestId: requestId,\n      invalidated: true,\n      cancel,\n    }));\n\n    this.invalidate(fetchMoreForQueryId);\n\n    this.queryStore.initQuery({\n      queryId,\n      document: query,\n      storePreviousVariables: shouldFetch,\n      variables,\n      isPoll: fetchType === FetchType.poll,\n      isRefetch: fetchType === FetchType.refetch,\n      metadata,\n      fetchMoreForQueryId,\n    });\n\n    this.broadcastQueries();\n\n    if (shouldFetch) {\n      const networkResult = this.fetchRequest<T>({\n        requestId,\n        queryId,\n        document: query,\n        options,\n        fetchMoreForQueryId,\n      }).catch(error => {\n        // This is for the benefit of `refetch` promises, which currently don't get their errors\n        // through the store like watchQuery observers do\n        if (isApolloError(error)) {\n          throw error;\n        } else {\n          if (requestId >= this.getQuery(queryId).lastRequestId) {\n            this.queryStore.markQueryError(queryId, error, fetchMoreForQueryId);\n            this.invalidate(queryId);\n            this.invalidate(fetchMoreForQueryId);\n            this.broadcastQueries();\n          }\n          throw new ApolloError({ networkError: error });\n        }\n      });\n\n      // we don't return the promise for cache-and-network since it is already\n      // returned below from the cache\n      if (fetchPolicy !== 'cache-and-network') {\n        return networkResult;\n      }\n\n      // however we need to catch the error so it isn't unhandled in case of\n      // network error\n      networkResult.catch(() => {});\n    }\n\n    // If there is no part of the query we need to fetch from the server (or,\n    // fetchPolicy is cache-only), we just write the store result as the final result.\n    this.queryStore.markQueryResultClient(queryId, !shouldFetch);\n    this.invalidate(queryId);\n    this.invalidate(fetchMoreForQueryId);\n\n    if (this.transform(query).hasForcedResolvers) {\n      return this.localState.runResolvers({\n        document: query,\n        remoteResult: { data: storeResult },\n        context,\n        variables,\n        onlyRunForcedResolvers: true,\n      }).then((result: FetchResult<T>) => {\n        this.markQueryResult(\n          queryId,\n          result,\n          options,\n          fetchMoreForQueryId,\n        );\n        this.broadcastQueries();\n        return result;\n      });\n    }\n\n    this.broadcastQueries();\n\n    // If we have no query to send to the server, we should return the result\n    // found within the store.\n    return { data: storeResult };\n  }\n\n  private markQueryResult<TData>(\n    queryId: string,\n    result: FetchResult<TData>,\n    {\n      fetchPolicy,\n      variables,\n      errorPolicy,\n    }: WatchQueryOptions,\n    fetchMoreForQueryId?: string,\n  ) {\n    if (fetchPolicy === 'no-cache') {\n      this.setQuery(queryId, () => ({\n        newData: { result: result.data, complete: true },\n      }));\n    } else {\n      this.dataStore.markQueryResult(\n        result,\n        this.getQuery(queryId).document!,\n        variables,\n        fetchMoreForQueryId,\n        errorPolicy === 'ignore' || errorPolicy === 'all',\n      );\n    }\n  }\n\n  // Returns a query listener that will update the given observer based on the\n  // results (or lack thereof) for a particular query.\n  public queryListenerForObserver<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    observer: Observer<ApolloQueryResult<T>>,\n  ): QueryListener {\n    function invoke(method: 'next' | 'error', argument: any) {\n      if (observer[method]) {\n        try {\n          observer[method]!(argument);\n        } catch (e) {\n          invariant.error(e);\n        }\n      } else if (method === 'error') {\n        invariant.error(argument);\n      }\n    }\n\n    return (\n      queryStoreValue: QueryStoreValue,\n      newData?: Cache.DiffResult<T>,\n    ) => {\n      // we're going to take a look at the data, so the query is no longer invalidated\n      this.invalidate(queryId, false);\n\n      // The query store value can be undefined in the event of a store\n      // reset.\n      if (!queryStoreValue) return;\n\n      const { observableQuery, document } = this.getQuery(queryId);\n\n      const fetchPolicy = observableQuery\n        ? observableQuery.options.fetchPolicy\n        : options.fetchPolicy;\n\n      // don't watch the store for queries on standby\n      if (fetchPolicy === 'standby') return;\n\n      const loading = isNetworkRequestInFlight(queryStoreValue.networkStatus);\n      const lastResult = observableQuery && observableQuery.getLastResult();\n\n      const networkStatusChanged = !!(\n        lastResult &&\n        lastResult.networkStatus !== queryStoreValue.networkStatus\n      );\n\n      const shouldNotifyIfLoading =\n        options.returnPartialData ||\n        (!newData && queryStoreValue.previousVariables) ||\n        (networkStatusChanged && options.notifyOnNetworkStatusChange) ||\n        fetchPolicy === 'cache-only' ||\n        fetchPolicy === 'cache-and-network';\n\n      if (loading && !shouldNotifyIfLoading) {\n        return;\n      }\n\n      const hasGraphQLErrors = isNonEmptyArray(queryStoreValue.graphQLErrors);\n\n      const errorPolicy: ErrorPolicy = observableQuery\n        && observableQuery.options.errorPolicy\n        || options.errorPolicy\n        || 'none';\n\n      // If we have either a GraphQL error or a network error, we create\n      // an error and tell the observer about it.\n      if (errorPolicy === 'none' && hasGraphQLErrors || queryStoreValue.networkError) {\n        return invoke('error', new ApolloError({\n          graphQLErrors: queryStoreValue.graphQLErrors,\n          networkError: queryStoreValue.networkError,\n        }));\n      }\n\n      try {\n        let data: any;\n        let isMissing: boolean;\n\n        if (newData) {\n          // As long as we're using the cache, clear out the latest\n          // `newData`, since it will now become the current data. We need\n          // to keep the `newData` stored with the query when using\n          // `no-cache` since `getCurrentQueryResult` attemps to pull from\n          // `newData` first, following by trying the cache (which won't\n          // find a hit for `no-cache`).\n          if (fetchPolicy !== 'no-cache' && fetchPolicy !== 'network-only') {\n            this.setQuery(queryId, () => ({ newData: null }));\n          }\n\n          data = newData.result;\n          isMissing = !newData.complete;\n        } else {\n          const lastError = observableQuery && observableQuery.getLastError();\n          const errorStatusChanged =\n            errorPolicy !== 'none' &&\n            (lastError && lastError.graphQLErrors) !==\n              queryStoreValue.graphQLErrors;\n\n          if (lastResult && lastResult.data && !errorStatusChanged) {\n            data = lastResult.data;\n            isMissing = false;\n          } else {\n            const diffResult = this.dataStore.getCache().diff({\n              query: document as DocumentNode,\n              variables:\n                queryStoreValue.previousVariables ||\n                queryStoreValue.variables,\n              returnPartialData: true,\n              optimistic: true,\n            });\n\n            data = diffResult.result;\n            isMissing = !diffResult.complete;\n          }\n        }\n\n        // If there is some data missing and the user has told us that they\n        // do not tolerate partial data then we want to return the previous\n        // result and mark it as stale.\n        const stale = isMissing && !(\n          options.returnPartialData ||\n          fetchPolicy === 'cache-only'\n        );\n\n        const resultFromStore: ApolloQueryResult<T> = {\n          data: stale ? lastResult && lastResult.data : data,\n          loading,\n          networkStatus: queryStoreValue.networkStatus,\n          stale,\n        };\n\n        // if the query wants updates on errors we need to add it to the result\n        if (errorPolicy === 'all' && hasGraphQLErrors) {\n          resultFromStore.errors = queryStoreValue.graphQLErrors;\n        }\n\n        invoke('next', resultFromStore);\n\n      } catch (networkError) {\n        invoke('error', new ApolloError({ networkError }));\n      }\n    };\n  }\n\n  private transformCache = new (canUseWeakMap ? WeakMap : Map)<\n    DocumentNode,\n    Readonly<{\n      document: Readonly<DocumentNode>;\n      hasClientExports: boolean;\n      hasForcedResolvers: boolean;\n      clientQuery: Readonly<DocumentNode> | null;\n      serverQuery: Readonly<DocumentNode> | null;\n      defaultVars: Readonly<OperationVariables>;\n    }>\n  >();\n\n  public transform(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const cache = this.dataStore.getCache();\n      const transformed = cache.transformDocument(document);\n      const forLink = removeConnectionDirectiveFromDocument(\n        cache.transformForLink(transformed));\n\n      const clientQuery = this.localState.clientQuery(transformed);\n      const serverQuery = this.localState.serverQuery(forLink);\n\n      const cacheEntry = {\n        document: transformed,\n        // TODO These two calls (hasClientExports and shouldForceResolvers)\n        // could probably be merged into a single traversal.\n        hasClientExports: hasClientExports(transformed),\n        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),\n        clientQuery,\n        serverQuery,\n        defaultVars: getDefaultValues(\n          getOperationDefinition(transformed)\n        ) as OperationVariables,\n      };\n\n      const add = (doc: DocumentNode | null) => {\n        if (doc && !transformCache.has(doc)) {\n          transformCache.set(doc, cacheEntry);\n        }\n      }\n      // Add cacheEntry to the transformCache using several different keys,\n      // since any one of these documents could end up getting passed to the\n      // transform method again in the future.\n      add(document);\n      add(transformed);\n      add(clientQuery);\n      add(serverQuery);\n    }\n\n    return transformCache.get(document)!;\n  }\n\n  private getVariables(\n    document: DocumentNode,\n    variables?: OperationVariables,\n  ): OperationVariables {\n    return {\n      ...this.transform(document).defaultVars,\n      ...variables,\n    };\n  }\n\n  // The shouldSubscribe option is a temporary fix that tells us whether watchQuery was called\n  // directly (i.e. through ApolloClient) or through the query method within QueryManager.\n  // Currently, the query method uses watchQuery in order to handle non-network errors correctly\n  // but we don't want to keep track observables issued for the query method since those aren't\n  // supposed to be refetched in the event of a store reset. Once we unify error handling for\n  // network errors and non-network errors, the shouldSubscribe option will go away.\n\n  public watchQuery<T, TVariables = OperationVariables>(\n    options: WatchQueryOptions,\n    shouldSubscribe = true,\n  ): ObservableQuery<T, TVariables> {\n    invariant(\n      options.fetchPolicy !== 'standby',\n      'client.watchQuery cannot be called with fetchPolicy set to \"standby\"',\n    );\n\n    // assign variable default values if supplied\n    options.variables = this.getVariables(options.query, options.variables);\n\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    let transformedOptions = { ...options } as WatchQueryOptions<TVariables>;\n\n    return new ObservableQuery<T, TVariables>({\n      queryManager: this,\n      options: transformedOptions,\n      shouldSubscribe: shouldSubscribe,\n    });\n  }\n\n  public query<T>(options: QueryOptions): Promise<ApolloQueryResult<T>> {\n    invariant(\n      options.query,\n      'query option is required. You must specify your GraphQL document ' +\n        'in the query option.',\n    );\n\n    invariant(\n      options.query.kind === 'Document',\n      'You must wrap the query string in a \"gql\" tag.',\n    );\n\n    invariant(\n      !(options as any).returnPartialData,\n      'returnPartialData option only supported on watchQuery.',\n    );\n\n    invariant(\n      !(options as any).pollInterval,\n      'pollInterval option only supported on watchQuery.',\n    );\n\n    return new Promise<ApolloQueryResult<T>>((resolve, reject) => {\n      const watchedQuery = this.watchQuery<T>(options, false);\n      this.fetchQueryRejectFns.set(`query:${watchedQuery.queryId}`, reject);\n      watchedQuery\n        .result()\n        .then(resolve, reject)\n        // Since neither resolve nor reject throw or return a value, this .then\n        // handler is guaranteed to execute. Note that it doesn't really matter\n        // when we remove the reject function from this.fetchQueryRejectFns,\n        // since resolve and reject are mutually idempotent. In fact, it would\n        // not be incorrect to let reject functions accumulate over time; it's\n        // just a waste of memory.\n        .then(() =>\n          this.fetchQueryRejectFns.delete(`query:${watchedQuery.queryId}`),\n        );\n    });\n  }\n\n  public generateQueryId() {\n    return String(this.idCounter++);\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryInStoreNoBroadcast(queryId: string) {\n    this.stopPollingQuery(queryId);\n    this.queryStore.stopQuery(queryId);\n    this.invalidate(queryId);\n  }\n\n  public addQueryListener(queryId: string, listener: QueryListener) {\n    this.setQuery(queryId, ({ listeners }) => {\n      listeners.add(listener);\n      return { invalidated: false };\n    });\n  }\n\n  public updateQueryWatch(\n    queryId: string,\n    document: DocumentNode,\n    options: WatchQueryOptions,\n  ) {\n    const { cancel } = this.getQuery(queryId);\n    if (cancel) cancel();\n    const previousResult = () => {\n      let previousResult = null;\n      const { observableQuery } = this.getQuery(queryId);\n      if (observableQuery) {\n        const lastResult = observableQuery.getLastResult();\n        if (lastResult) {\n          previousResult = lastResult.data;\n        }\n      }\n\n      return previousResult;\n    };\n    return this.dataStore.getCache().watch({\n      query: document as DocumentNode,\n      variables: options.variables,\n      optimistic: true,\n      previousResult,\n      callback: newData => {\n        this.setQuery(queryId, () => ({ invalidated: true, newData }));\n      },\n    });\n  }\n\n  // Adds an ObservableQuery to this.observableQueries and to this.observableQueriesByName.\n  public addObservableQuery<T>(\n    queryId: string,\n    observableQuery: ObservableQuery<T>,\n  ) {\n    this.setQuery(queryId, () => ({ observableQuery }));\n  }\n\n  public removeObservableQuery(queryId: string) {\n    const { cancel } = this.getQuery(queryId);\n    this.setQuery(queryId, () => ({ observableQuery: null }));\n    if (cancel) cancel();\n  }\n\n  public clearStore(): Promise<void> {\n    // Before we have sent the reset action to the store,\n    // we can no longer rely on the results returned by in-flight\n    // requests since these may depend on values that previously existed\n    // in the data portion of the store. So, we cancel the promises and observers\n    // that we have issued so far and not yet resolved (in the case of\n    // queries).\n    this.fetchQueryRejectFns.forEach(reject => {\n      reject(new InvariantError(\n        'Store reset while query was in flight (not completed in link chain)',\n      ));\n    });\n\n    const resetIds: string[] = [];\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (observableQuery) resetIds.push(queryId);\n    });\n\n    this.queryStore.reset(resetIds);\n    this.mutationStore.reset();\n\n    // begin removing data from the store\n    return this.dataStore.reset();\n  }\n\n  public resetStore(): Promise<ApolloQueryResult<any>[]> {\n    // Similarly, we have to have to refetch each of the queries currently being\n    // observed. We refetch instead of error'ing on these since the assumption is that\n    // resetting the store doesn't eliminate the need for the queries currently being\n    // watched. If there is an existing query in flight when the store is reset,\n    // the promise for it will be rejected and its results will not be written to the\n    // store.\n    return this.clearStore().then(() => {\n      return this.reFetchObservableQueries();\n    });\n  }\n\n  public reFetchObservableQueries(\n    includeStandby: boolean = false,\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (observableQuery) {\n        const fetchPolicy = observableQuery.options.fetchPolicy;\n\n        observableQuery.resetLastResults();\n        if (\n          fetchPolicy !== 'cache-only' &&\n          (includeStandby || fetchPolicy !== 'standby')\n        ) {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n\n        this.setQuery(queryId, () => ({ newData: null }));\n        this.invalidate(queryId);\n      }\n    });\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public observeQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    observer: Observer<ApolloQueryResult<T>>,\n  ) {\n    this.addQueryListener(\n      queryId,\n      this.queryListenerForObserver(queryId, options, observer),\n    );\n    return this.fetchQuery<T>(queryId, options);\n  }\n\n  public startQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    listener: QueryListener,\n  ) {\n    invariant.warn(\"The QueryManager.startQuery method has been deprecated\");\n\n    this.addQueryListener(queryId, listener);\n\n    this.fetchQuery<T>(queryId, options)\n      // `fetchQuery` returns a Promise. In case of a failure it should be caucht or else the\n      // console will show an `Uncaught (in promise)` message. Ignore the error for now.\n      .catch(() => undefined);\n\n    return queryId;\n  }\n\n  public startGraphQLSubscription<T = any>({\n    query,\n    fetchPolicy,\n    variables,\n  }: SubscriptionOptions): Observable<FetchResult<T>> {\n    query = this.transform(query).document;\n    variables = this.getVariables(query, variables);\n\n    const makeObservable = (variables: OperationVariables) =>\n      this.getObservableFromLink<T>(\n        query,\n        {},\n        variables,\n        false,\n      ).map(result => {\n        if (!fetchPolicy || fetchPolicy !== 'no-cache') {\n          this.dataStore.markSubscriptionResult(\n            result,\n            query,\n            variables,\n          );\n          this.broadcastQueries();\n        }\n\n        if (graphQLResultHasError(result)) {\n          throw new ApolloError({\n            graphQLErrors: result.errors,\n          });\n        }\n\n        return result;\n      });\n\n    if (this.transform(query).hasClientExports) {\n      const observablePromise = this.localState.addExportedVariables(\n        query,\n        variables,\n      ).then(makeObservable);\n\n      return new Observable<FetchResult<T>>(observer => {\n        let sub: Subscription | null = null;\n        observablePromise.then(\n          observable => sub = observable.subscribe(observer),\n          observer.error,\n        );\n        return () => sub && sub.unsubscribe();\n      });\n    }\n\n    return makeObservable(variables);\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryNoBroadcast(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchQueryRejectFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchQueryRejectFns.delete(`query:${queryId}`);\n    this.fetchQueryRejectFns.delete(`fetchRequest:${queryId}`);\n    this.getQuery(queryId).subscriptions.forEach(x => x.unsubscribe());\n    this.queries.delete(queryId);\n  }\n\n  public getCurrentQueryResult<T>(\n    observableQuery: ObservableQuery<T>,\n    optimistic: boolean = true,\n  ): {\n    data: T | undefined;\n    partial: boolean;\n  } {\n    const { variables, query, fetchPolicy, returnPartialData } = observableQuery.options;\n    const lastResult = observableQuery.getLastResult();\n    const { newData } = this.getQuery(observableQuery.queryId);\n\n    if (newData && newData.complete) {\n      return { data: newData.result, partial: false };\n    }\n\n    if (fetchPolicy === 'no-cache' || fetchPolicy === 'network-only') {\n      return { data: undefined, partial: false };\n    }\n\n    const { result, complete } = this.dataStore.getCache().diff<T>({\n      query,\n      variables,\n      previousResult: lastResult ? lastResult.data : undefined,\n      returnPartialData: true,\n      optimistic,\n    });\n\n    return {\n      data: (complete || returnPartialData) ? result : void 0,\n      partial: !complete,\n    };\n  }\n\n  public getQueryWithPreviousResult<TData, TVariables = OperationVariables>(\n    queryIdOrObservable: string | ObservableQuery<TData, TVariables>,\n  ): {\n    previousResult: any;\n    variables: TVariables | undefined;\n    document: DocumentNode;\n  } {\n    let observableQuery: ObservableQuery<TData, any>;\n    if (typeof queryIdOrObservable === 'string') {\n      const { observableQuery: foundObserveableQuery } = this.getQuery(\n        queryIdOrObservable,\n      );\n      invariant(\n        foundObserveableQuery,\n        `ObservableQuery with this id doesn't exist: ${queryIdOrObservable}`\n      );\n      observableQuery = foundObserveableQuery!;\n    } else {\n      observableQuery = queryIdOrObservable;\n    }\n\n    const { variables, query } = observableQuery.options;\n    return {\n      previousResult: this.getCurrentQueryResult(observableQuery, false).data,\n      variables,\n      document: query,\n    };\n  }\n\n  public broadcastQueries() {\n    this.onBroadcast();\n    this.queries.forEach((info, id) => {\n      if (info.invalidated) {\n        info.listeners.forEach(listener => {\n          // it's possible for the listener to be undefined if the query is being stopped\n          // See here for more detail: https://github.com/apollostack/apollo-client/issues/231\n          if (listener) {\n            listener(this.queryStore.get(id), info.newData);\n          }\n        });\n      }\n    });\n  }\n\n  public getLocalState(): LocalState<TStore> {\n    return this.localState;\n  }\n\n  private inFlightLinkObservables = new Map<\n    DocumentNode,\n    Map<string, Observable<FetchResult>>\n  >();\n\n  private getObservableFromLink<T = any>(\n    query: DocumentNode,\n    context: any,\n    variables?: OperationVariables,\n    deduplication: boolean = this.queryDeduplication,\n  ): Observable<FetchResult<T>> {\n    let observable: Observable<FetchResult<T>>;\n\n    const { serverQuery } = this.transform(query);\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      const operation = {\n        query: serverQuery,\n        variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext({\n          ...context,\n          forceFetch: !deduplication\n        }),\n      };\n\n      context = operation.context;\n\n      if (deduplication) {\n        const byVariables = inFlightLinkObservables.get(serverQuery) || new Map();\n        inFlightLinkObservables.set(serverQuery, byVariables);\n\n        const varJson = JSON.stringify(variables);\n        observable = byVariables.get(varJson);\n\n        if (!observable) {\n          byVariables.set(\n            varJson,\n            observable = multiplex(\n              execute(link, operation) as Observable<FetchResult<T>>\n            )\n          );\n\n          const cleanup = () => {\n            byVariables.delete(varJson);\n            if (!byVariables.size) inFlightLinkObservables.delete(serverQuery);\n            cleanupSub.unsubscribe();\n          };\n\n          const cleanupSub = observable.subscribe({\n            next: cleanup,\n            error: cleanup,\n            complete: cleanup,\n          });\n        }\n\n      } else {\n        observable = multiplex(execute(link, operation) as Observable<FetchResult<T>>);\n      }\n    } else {\n      observable = Observable.of({ data: {} } as FetchResult<T>);\n      context = this.prepareContext(context);\n    }\n\n    const { clientQuery } = this.transform(query);\n    if (clientQuery) {\n      observable = asyncMap(observable, result => {\n        return this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context,\n          variables,\n        });\n      });\n    }\n\n    return observable;\n  }\n\n  // Takes a request id, query id, a query document and information associated with the query\n  // and send it to the network interface. Returns\n  // a promise for the result associated with that request.\n  private fetchRequest<T>({\n    requestId,\n    queryId,\n    document,\n    options,\n    fetchMoreForQueryId,\n  }: {\n    requestId: number;\n    queryId: string;\n    document: DocumentNode;\n    options: WatchQueryOptions;\n    fetchMoreForQueryId?: string;\n  }): Promise<FetchResult<T>> {\n    const { variables, errorPolicy = 'none', fetchPolicy } = options;\n    let resultFromStore: any;\n    let errorsFromStore: any;\n\n    return new Promise<ApolloQueryResult<T>>((resolve, reject) => {\n      const observable = this.getObservableFromLink(\n        document,\n        options.context,\n        variables,\n      );\n\n      const fqrfId = `fetchRequest:${queryId}`;\n      this.fetchQueryRejectFns.set(fqrfId, reject);\n\n      const cleanup = () => {\n        this.fetchQueryRejectFns.delete(fqrfId);\n        this.setQuery(queryId, ({ subscriptions }) => {\n          subscriptions.delete(subscription);\n        });\n      };\n\n      const subscription = observable.map((result: FetchResult<T>) => {\n        if (requestId >= this.getQuery(queryId).lastRequestId) {\n          this.markQueryResult(\n            queryId,\n            result,\n            options,\n            fetchMoreForQueryId,\n          );\n\n          this.queryStore.markQueryResult(\n            queryId,\n            result,\n            fetchMoreForQueryId,\n          );\n\n          this.invalidate(queryId);\n          this.invalidate(fetchMoreForQueryId);\n\n          this.broadcastQueries();\n        }\n\n        if (errorPolicy === 'none' && isNonEmptyArray(result.errors)) {\n          return reject(new ApolloError({\n            graphQLErrors: result.errors,\n          }));\n        }\n\n        if (errorPolicy === 'all') {\n          errorsFromStore = result.errors;\n        }\n\n        if (fetchMoreForQueryId || fetchPolicy === 'no-cache') {\n          // We don't write fetchMore results to the store because this would overwrite\n          // the original result in case an @connection directive is used.\n          resultFromStore = result.data;\n        } else {\n          // ensure result is combined with data already in store\n          const { result, complete } = this.dataStore.getCache().diff<T>({\n            variables,\n            query: document,\n            optimistic: false,\n            returnPartialData: true,\n          });\n\n          if (complete || options.returnPartialData) {\n            resultFromStore = result;\n          }\n        }\n      }).subscribe({\n        error(error: ApolloError) {\n          cleanup();\n          reject(error);\n        },\n\n        complete() {\n          cleanup();\n          resolve({\n            data: resultFromStore,\n            errors: errorsFromStore,\n            loading: false,\n            networkStatus: NetworkStatus.ready,\n            stale: false,\n          });\n        },\n      });\n\n      this.setQuery(queryId, ({ subscriptions }) => {\n        subscriptions.add(subscription);\n      });\n    });\n  }\n\n  private getQuery(queryId: string) {\n    return (\n      this.queries.get(queryId) || {\n        listeners: new Set<QueryListener>(),\n        invalidated: false,\n        document: null,\n        newData: null,\n        lastRequestId: 1,\n        observableQuery: null,\n        subscriptions: new Set<Subscription>(),\n      }\n    );\n  }\n\n  private setQuery<T extends keyof QueryInfo>(\n    queryId: string,\n    updater: (prev: QueryInfo) => Pick<QueryInfo, T> | void,\n  ) {\n    const prev = this.getQuery(queryId);\n    const newInfo = { ...prev, ...updater(prev) };\n    this.queries.set(queryId, newInfo);\n  }\n\n  private invalidate(\n    queryId: string | undefined,\n    invalidated = true,\n  ) {\n    if (queryId) {\n      this.setQuery(queryId, () => ({ invalidated }));\n    }\n  }\n\n  private prepareContext(context = {}) {\n    const newContext = this.localState.prepareContext(context);\n    return {\n      ...newContext,\n      clientAwareness: this.clientAwareness,\n    };\n  }\n\n  public checkInFlight(queryId: string) {\n    const query = this.queryStore.get(queryId);\n\n    return (\n      query &&\n      query.networkStatus !== NetworkStatus.ready &&\n      query.networkStatus !== NetworkStatus.error\n    );\n  }\n\n  // Map from client ID to { interval, options }.\n  private pollingInfoByQueryId = new Map<string, {\n    interval: number;\n    timeout: NodeJS.Timeout;\n    options: WatchQueryOptions;\n  }>();\n\n  public startPollingQuery(\n    options: WatchQueryOptions,\n    queryId: string,\n    listener?: QueryListener,\n  ): string {\n    const { pollInterval } = options;\n\n    invariant(\n      pollInterval,\n      'Attempted to start a polling query without a polling interval.',\n    );\n\n    // Do not poll in SSR mode\n    if (!this.ssrMode) {\n      let info = this.pollingInfoByQueryId.get(queryId)!;\n      if (!info) {\n        this.pollingInfoByQueryId.set(queryId, (info = {} as any));\n      }\n\n      info.interval = pollInterval!;\n      info.options = {\n        ...options,\n        fetchPolicy: 'network-only',\n      };\n\n      const maybeFetch = () => {\n        const info = this.pollingInfoByQueryId.get(queryId);\n        if (info) {\n          if (this.checkInFlight(queryId)) {\n            poll();\n          } else {\n            this.fetchQuery(queryId, info.options, FetchType.poll).then(\n              poll,\n              poll,\n            );\n          }\n        }\n      };\n\n      const poll = () => {\n        const info = this.pollingInfoByQueryId.get(queryId);\n        if (info) {\n          clearTimeout(info.timeout);\n          info.timeout = setTimeout(maybeFetch, info.interval);\n        }\n      };\n\n      if (listener) {\n        this.addQueryListener(queryId, listener);\n      }\n\n      poll();\n    }\n\n    return queryId;\n  }\n\n  public stopPollingQuery(queryId: string) {\n    this.pollingInfoByQueryId.delete(queryId);\n  }\n}\n","import { ExecutionResult, DocumentNode } from 'graphql';\nimport { ApolloCache, Cache, DataProxy } from 'apollo-cache';\n\nimport { QueryStoreValue } from '../data/queries';\nimport {\n  getOperationName,\n  tryFunctionOrLogError,\n  graphQLResultHasError,\n} from 'apollo-utilities';\nimport { MutationQueryReducer } from '../core/types';\n\nexport type QueryWithUpdater = {\n  updater: MutationQueryReducer<Object>;\n  query: QueryStoreValue;\n};\n\nexport interface DataWrite {\n  rootId: string;\n  result: any;\n  document: DocumentNode;\n  operationName: string | null;\n  variables: Object;\n}\n\nexport class DataStore<TSerialized> {\n  private cache: ApolloCache<TSerialized>;\n\n  constructor(initialCache: ApolloCache<TSerialized>) {\n    this.cache = initialCache;\n  }\n\n  public getCache(): ApolloCache<TSerialized> {\n    return this.cache;\n  }\n\n  public markQueryResult(\n    result: ExecutionResult,\n    document: DocumentNode,\n    variables: any,\n    fetchMoreForQueryId: string | undefined,\n    ignoreErrors: boolean = false,\n  ) {\n    let writeWithErrors = !graphQLResultHasError(result);\n    if (ignoreErrors && graphQLResultHasError(result) && result.data) {\n      writeWithErrors = true;\n    }\n    if (!fetchMoreForQueryId && writeWithErrors) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_QUERY',\n        query: document,\n        variables: variables,\n      });\n    }\n  }\n\n  public markSubscriptionResult(\n    result: ExecutionResult,\n    document: DocumentNode,\n    variables: any,\n  ) {\n    // the subscription interface should handle not sending us results we no longer subscribe to.\n    // XXX I don't think we ever send in an object with errors, but we might in the future...\n    if (!graphQLResultHasError(result)) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_SUBSCRIPTION',\n        query: document,\n        variables: variables,\n      });\n    }\n  }\n\n  public markMutationInit(mutation: {\n    mutationId: string;\n    document: DocumentNode;\n    variables: any;\n    updateQueries: { [queryId: string]: QueryWithUpdater };\n    update: ((proxy: DataProxy, mutationResult: Object) => void) | undefined;\n    optimisticResponse: Object | Function | undefined;\n  }) {\n    if (mutation.optimisticResponse) {\n      let optimistic: Object;\n      if (typeof mutation.optimisticResponse === 'function') {\n        optimistic = mutation.optimisticResponse(mutation.variables);\n      } else {\n        optimistic = mutation.optimisticResponse;\n      }\n\n      this.cache.recordOptimisticTransaction(c => {\n        const orig = this.cache;\n        this.cache = c;\n\n        try {\n          this.markMutationResult({\n            mutationId: mutation.mutationId,\n            result: { data: optimistic },\n            document: mutation.document,\n            variables: mutation.variables,\n            updateQueries: mutation.updateQueries,\n            update: mutation.update,\n          });\n        } finally {\n          this.cache = orig;\n        }\n      }, mutation.mutationId);\n    }\n  }\n\n  public markMutationResult(mutation: {\n    mutationId: string;\n    result: ExecutionResult;\n    document: DocumentNode;\n    variables: any;\n    updateQueries: { [queryId: string]: QueryWithUpdater };\n    update: ((proxy: DataProxy, mutationResult: Object) => void) | undefined;\n  }) {\n    // Incorporate the result from this mutation into the store\n    if (!graphQLResultHasError(mutation.result)) {\n      const cacheWrites: Cache.WriteOptions[] = [{\n        result: mutation.result.data,\n        dataId: 'ROOT_MUTATION',\n        query: mutation.document,\n        variables: mutation.variables,\n      }];\n\n      const { updateQueries } = mutation;\n      if (updateQueries) {\n        Object.keys(updateQueries).forEach(id => {\n          const { query, updater } = updateQueries[id];\n\n          // Read the current query result from the store.\n          const { result: currentQueryResult, complete } = this.cache.diff({\n            query: query.document,\n            variables: query.variables,\n            returnPartialData: true,\n            optimistic: false,\n          });\n\n          if (complete) {\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = tryFunctionOrLogError(() =>\n              updater(currentQueryResult, {\n                mutationResult: mutation.result,\n                queryName: getOperationName(query.document) || undefined,\n                queryVariables: query.variables,\n              }),\n            );\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: query.document,\n                variables: query.variables,\n              });\n            }\n          }\n        });\n      }\n\n      this.cache.performTransaction(c => {\n        cacheWrites.forEach(write => c.write(write));\n\n        // If the mutation has some writes associated with it then we need to\n        // apply those writes to the store by running this reducer again with a\n        // write action.\n        const { update } = mutation;\n        if (update) {\n          tryFunctionOrLogError(() => update(c, mutation.result));\n        }\n      });\n    }\n  }\n\n  public markMutationComplete({\n    mutationId,\n    optimisticResponse,\n  }: {\n    mutationId: string;\n    optimisticResponse?: any;\n  }) {\n    if (optimisticResponse) {\n      this.cache.removeOptimistic(mutationId);\n    }\n  }\n\n  public markUpdateQueryResult(\n    document: DocumentNode,\n    variables: any,\n    newResult: any,\n  ) {\n    this.cache.write({\n      result: newResult,\n      dataId: 'ROOT_QUERY',\n      variables,\n      query: document,\n    });\n  }\n\n  public reset(): Promise<void> {\n    return this.cache.reset();\n  }\n}\n","export const version = \"2.6.10\"","import {\n  ApolloLink,\n  FetchResult,\n  GraphQLRequest,\n  execute,\n} from 'apollo-link';\nimport { ExecutionResult, DocumentNode } from 'graphql';\nimport { ApolloCache, DataProxy } from 'apollo-cache';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { QueryManager } from './core/QueryManager';\nimport {\n  ApolloQueryResult,\n  OperationVariables,\n  Resolvers,\n} from './core/types';\nimport { ObservableQuery } from './core/ObservableQuery';\nimport { LocalState, FragmentMatcher } from './core/LocalState';\nimport { Observable } from './util/Observable';\n\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  WatchQueryFetchPolicy,\n} from './core/watchQueryOptions';\n\nimport { DataStore } from './data/store';\n\nimport { version } from './version';\n\nexport interface DefaultOptions {\n  watchQuery?: Partial<WatchQueryOptions>;\n  query?: Partial<QueryOptions>;\n  mutate?: Partial<MutationOptions>;\n}\n\nlet hasSuggestedDevtools = false;\n\nexport type ApolloClientOptions<TCacheShape> = {\n  link?: ApolloLink;\n  cache: ApolloCache<TCacheShape>;\n  ssrForceFetchDelay?: number;\n  ssrMode?: boolean;\n  connectToDevTools?: boolean;\n  queryDeduplication?: boolean;\n  defaultOptions?: DefaultOptions;\n  assumeImmutableResults?: boolean;\n  resolvers?: Resolvers | Resolvers[];\n  typeDefs?: string | string[] | DocumentNode | DocumentNode[];\n  fragmentMatcher?: FragmentMatcher;\n  name?: string;\n  version?: string;\n};\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over a {@link NetworkInterface} instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through {@link Observable} instances.\n */\nexport default class ApolloClient<TCacheShape> implements DataProxy {\n  public link: ApolloLink;\n  public store: DataStore<TCacheShape>;\n  public cache: ApolloCache<TCacheShape>;\n  public readonly queryManager: QueryManager<TCacheShape>;\n  public disableNetworkFetches: boolean;\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: DefaultOptions = {};\n  public readonly typeDefs: ApolloClientOptions<TCacheShape>['typeDefs'];\n\n  private devToolsHookCb: Function;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n  private clearStoreCallbacks: Array<() => Promise<any>> = [];\n  private localState: LocalState<TCacheShape>;\n\n  /**\n   * Constructs an instance of {@link ApolloClient}.\n   *\n   * @param link The {@link ApolloLink} over which GraphQL documents will be resolved into a response.\n   *\n   * @param cache The initial cache to use in the data store.\n   *\n   * @param ssrMode Determines whether this is being run in Server Side Rendering (SSR) mode.\n   *\n   * @param ssrForceFetchDelay Determines the time interval before we force fetch queries for a\n   * server side render.\n   *\n   * @param queryDeduplication If set to false, a query will still be sent to the server even if a query\n   * with identical parameters (query, variables, operationName) is already in flight.\n   *\n   * @param defaultOptions Used to set application wide defaults for the\n   *                       options supplied to `watchQuery`, `query`, or\n   *                       `mutate`.\n   *\n   * @param assumeImmutableResults When this option is true, the client will assume results\n   *                               read from the cache are never mutated by application code,\n   *                               which enables substantial performance optimizations. Passing\n   *                               `{ freezeResults: true }` to the `InMemoryCache` constructor\n   *                               can help enforce this immutability.\n   *\n   * @param name A custom name that can be used to identify this client, when\n   *             using Apollo client awareness features. E.g. \"iOS\".\n   *\n   * @param version A custom version that can be used to identify this client,\n   *                when using Apollo client awareness features. This is the\n   *                version of your client, which you may want to increment on\n   *                new builds. This is NOT the version of Apollo Client that\n   *                you are using.\n   */\n  constructor(options: ApolloClientOptions<TCacheShape>) {\n    const {\n      cache,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      connectToDevTools,\n      queryDeduplication = true,\n      defaultOptions,\n      assumeImmutableResults = false,\n      resolvers,\n      typeDefs,\n      fragmentMatcher,\n      name: clientAwarenessName,\n      version: clientAwarenessVersion,\n    } = options;\n\n    let { link } = options;\n\n    // If a link hasn't been defined, but local state resolvers have been set,\n    // setup a default empty link.\n    if (!link && resolvers) {\n      link = ApolloLink.empty();\n    }\n\n    if (!link || !cache) {\n      throw new InvariantError(\n        \"In order to initialize Apollo Client, you must specify 'link' and 'cache' properties in the options object.\\n\" +\n        \"These options are part of the upgrade requirements when migrating from Apollo Client 1.x to Apollo Client 2.x.\\n\" +\n        \"For more information, please visit: https://www.apollographql.com/docs/tutorial/client.html#apollo-client-setup\"\n      );\n    }\n\n    // remove apollo-client supported directives\n    this.link = link;\n    this.cache = cache;\n    this.store = new DataStore(cache);\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || {};\n    this.typeDefs = typeDefs;\n\n    if (ssrForceFetchDelay) {\n      setTimeout(\n        () => (this.disableNetworkFetches = false),\n        ssrForceFetchDelay,\n      );\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    // Attach the client instance to window to let us be found by chrome devtools, but only in\n    // development mode\n    const defaultConnectToDevTools =\n      process.env.NODE_ENV !== 'production' &&\n      typeof window !== 'undefined' &&\n      !(window as any).__APOLLO_CLIENT__;\n\n    if (\n      typeof connectToDevTools === 'undefined'\n        ? defaultConnectToDevTools\n        : connectToDevTools && typeof window !== 'undefined'\n    ) {\n      (window as any).__APOLLO_CLIENT__ = this;\n    }\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && process.env.NODE_ENV !== 'production') {\n      hasSuggestedDevtools = true;\n      if (\n        typeof window !== 'undefined' &&\n        window.document &&\n        window.top === window.self\n      ) {\n        // First check if devtools is not installed\n        if (\n          typeof (window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__ === 'undefined'\n        ) {\n          // Only for Chrome\n          if (\n            window.navigator &&\n            window.navigator.userAgent &&\n            window.navigator.userAgent.indexOf('Chrome') > -1\n          ) {\n            // tslint:disable-next-line\n            console.debug(\n              'Download the Apollo DevTools ' +\n                'for a better development experience: ' +\n                'https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm',\n            );\n          }\n        }\n      }\n    }\n\n    this.version = version;\n\n    this.localState = new LocalState({\n      cache,\n      client: this,\n      resolvers,\n      fragmentMatcher,\n    });\n\n    this.queryManager = new QueryManager({\n      link: this.link,\n      store: this.store,\n      queryDeduplication,\n      ssrMode,\n      clientAwareness: {\n        name: clientAwarenessName!,\n        version: clientAwarenessVersion!,\n      },\n      localState: this.localState,\n      assumeImmutableResults,\n      onBroadcast: () => {\n        if (this.devToolsHookCb) {\n          this.devToolsHookCb({\n            action: {},\n            state: {\n              queries: this.queryManager.queryStore.getStore(),\n              mutations: this.queryManager.mutationStore.getStore(),\n            },\n            dataWithOptimisticResults: this.cache.extract(true),\n          });\n        }\n      },\n    });\n  }\n\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n  public stop() {\n    this.queryManager.stop();\n  }\n\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an {@link ObservableQuery}. We can subscribe to this {@link ObservableQuery} and\n   * receive updated results through a GraphQL observer when the cache store changes.\n   * <p /><p />\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   * <p /><p />\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifer, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   * <p /><p />\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   * <p /><p />\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<T = any, TVariables = OperationVariables>(\n    options: WatchQueryOptions<TVariables>,\n  ): ObservableQuery<T, TVariables> {\n    if (this.defaultOptions.watchQuery) {\n      options = {\n        ...this.defaultOptions.watchQuery,\n        ...options,\n      } as WatchQueryOptions<TVariables>;\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (\n      this.disableNetworkFetches &&\n      (options.fetchPolicy === 'network-only' ||\n        options.fetchPolicy === 'cache-and-network')\n    ) {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.queryManager.watchQuery<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a {@link Promise} which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options An object of type {@link QueryOptions} that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<T = any, TVariables = OperationVariables>(\n    options: QueryOptions<TVariables>,\n  ): Promise<ApolloQueryResult<T>> {\n    if (this.defaultOptions.query) {\n      options = { ...this.defaultOptions.query, ...options } as QueryOptions<\n        TVariables\n      >;\n    }\n\n    invariant(\n      (options.fetchPolicy as WatchQueryFetchPolicy) !== 'cache-and-network',\n      'The cache-and-network fetchPolicy does not work with client.query, because ' +\n      'client.query can only return a single result. Please use client.watchQuery ' +\n      'to receive multiple results from the cache and the network, or consider ' +\n      'using a different fetchPolicy, such as cache-first or network-only.'\n    );\n\n    if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.queryManager.query<T>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * {@link Promise} which is either resolved with the resulting data or rejected with an\n   * error.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<T = any, TVariables = OperationVariables>(\n    options: MutationOptions<T, TVariables>,\n  ): Promise<FetchResult<T>> {\n    if (this.defaultOptions.mutate) {\n      options = {\n        ...this.defaultOptions.mutate,\n        ...options,\n      } as MutationOptions<T, TVariables>;\n    }\n\n    return this.queryManager.mutate<T>(options);\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * {@link Observable} which either emits received data or an error.\n   */\n  public subscribe<T = any, TVariables = OperationVariables>(\n    options: SubscriptionOptions<TVariables>,\n  ): Observable<FetchResult<T>> {\n    return this.queryManager.startGraphQLSubscription<T>(options);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readQuery<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Query<TVariables>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.cache.readQuery<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readFragment<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Fragment<TVariables>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.cache.readFragment<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  public writeQuery<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>,\n  ): void {\n    const result = this.cache.writeQuery<TData, TVariables>(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>,\n  ): void {\n    const result = this.cache.writeFragment<TData, TVariables>(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  /**\n   * Sugar for writeQuery & writeFragment\n   * This method will construct a query from the data object passed in.\n   * If no id is supplied, writeData will write the data to the root.\n   * If an id is supplied, writeData will write a fragment to the object\n   * specified by the id in the store.\n   *\n   * Since you aren't passing in a query to check the shape of the data,\n   * you must pass in an object that conforms to the shape of valid GraphQL data.\n   */\n  public writeData<TData = any>(\n    options: DataProxy.WriteDataOptions<TData>,\n  ): void {\n    const result = this.cache.writeData<TData>(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(payload: GraphQLRequest): Observable<ExecutionResult> {\n    return execute(this.link, payload);\n  }\n\n  /**\n   * This initializes the query manager that tracks queries and the cache\n   */\n  public initQueryManager(): QueryManager<TCacheShape> {\n    invariant.warn(\n      'Calling the initQueryManager method is no longer necessary, ' +\n        'and it will be removed from ApolloClient in version 3.0.',\n    );\n    return this.queryManager;\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. Youve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<ApolloQueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() => this.queryManager.clearStore())\n      .then(() => Promise.all(this.resetStoreCallbacks.map(fn => fn())))\n      .then(() => this.reFetchObservableQueries());\n  }\n\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  public clearStore(): Promise<any[]> {\n    return Promise.resolve()\n      .then(() => this.queryManager.clearStore())\n      .then(() => Promise.all(this.clearStoreCallbacks.map(fn => fn())));\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onClearStore(cb: () => Promise<any>): () => void {\n    this.clearStoreCallbacks.push(cb);\n    return () => {\n      this.clearStoreCallbacks = this.clearStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  public reFetchObservableQueries(\n    includeStandby?: boolean,\n  ): Promise<ApolloQueryResult<any>[]> {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public extract(optimistic?: boolean): TCacheShape {\n    return this.cache.extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: TCacheShape): ApolloCache<TCacheShape> {\n    return this.cache.restore(serializedState);\n  }\n\n  /**\n   * Add additional local resolvers.\n   */\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.addResolvers(resolvers);\n  }\n\n  /**\n   * Set (override existing) local resolvers.\n   */\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.setResolvers(resolvers);\n  }\n\n  /**\n   * Get all registered local resolvers.\n   */\n  public getResolvers() {\n    return this.localState.getResolvers();\n  }\n\n  /**\n   * Set a custom local state fragment matcher.\n   */\n  public setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  }\n}\n"]}