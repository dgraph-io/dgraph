// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pb.proto

package pb

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	pb "github.com/dgraph-io/badger/pb"
	api "github.com/dgraph-io/dgo/protos/api"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type DirectedEdge_Op int32

const (
	DirectedEdge_SET DirectedEdge_Op = 0
	DirectedEdge_DEL DirectedEdge_Op = 1
)

var DirectedEdge_Op_name = map[int32]string{
	0: "SET",
	1: "DEL",
}

var DirectedEdge_Op_value = map[string]int32{
	"SET": 0,
	"DEL": 1,
}

func (x DirectedEdge_Op) String() string {
	return proto.EnumName(DirectedEdge_Op_name, int32(x))
}

func (DirectedEdge_Op) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{17, 0}
}

type Posting_ValType int32

const (
	Posting_DEFAULT  Posting_ValType = 0
	Posting_BINARY   Posting_ValType = 1
	Posting_INT      Posting_ValType = 2
	Posting_FLOAT    Posting_ValType = 3
	Posting_BOOL     Posting_ValType = 4
	Posting_DATETIME Posting_ValType = 5
	Posting_GEO      Posting_ValType = 6
	Posting_UID      Posting_ValType = 7
	Posting_PASSWORD Posting_ValType = 8
	Posting_STRING   Posting_ValType = 9
	Posting_OBJECT   Posting_ValType = 10
)

var Posting_ValType_name = map[int32]string{
	0:  "DEFAULT",
	1:  "BINARY",
	2:  "INT",
	3:  "FLOAT",
	4:  "BOOL",
	5:  "DATETIME",
	6:  "GEO",
	7:  "UID",
	8:  "PASSWORD",
	9:  "STRING",
	10: "OBJECT",
}

var Posting_ValType_value = map[string]int32{
	"DEFAULT":  0,
	"BINARY":   1,
	"INT":      2,
	"FLOAT":    3,
	"BOOL":     4,
	"DATETIME": 5,
	"GEO":      6,
	"UID":      7,
	"PASSWORD": 8,
	"STRING":   9,
	"OBJECT":   10,
}

func (x Posting_ValType) String() string {
	return proto.EnumName(Posting_ValType_name, int32(x))
}

func (Posting_ValType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{22, 0}
}

type Posting_PostingType int32

const (
	Posting_REF        Posting_PostingType = 0
	Posting_VALUE      Posting_PostingType = 1
	Posting_VALUE_LANG Posting_PostingType = 2
)

var Posting_PostingType_name = map[int32]string{
	0: "REF",
	1: "VALUE",
	2: "VALUE_LANG",
}

var Posting_PostingType_value = map[string]int32{
	"REF":        0,
	"VALUE":      1,
	"VALUE_LANG": 2,
}

func (x Posting_PostingType) String() string {
	return proto.EnumName(Posting_PostingType_name, int32(x))
}

func (Posting_PostingType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{22, 1}
}

type SchemaUpdate_Directive int32

const (
	SchemaUpdate_NONE    SchemaUpdate_Directive = 0
	SchemaUpdate_INDEX   SchemaUpdate_Directive = 1
	SchemaUpdate_REVERSE SchemaUpdate_Directive = 2
	SchemaUpdate_DELETE  SchemaUpdate_Directive = 3
)

var SchemaUpdate_Directive_name = map[int32]string{
	0: "NONE",
	1: "INDEX",
	2: "REVERSE",
	3: "DELETE",
}

var SchemaUpdate_Directive_value = map[string]int32{
	"NONE":    0,
	"INDEX":   1,
	"REVERSE": 2,
	"DELETE":  3,
}

func (x SchemaUpdate_Directive) String() string {
	return proto.EnumName(SchemaUpdate_Directive_name, int32(x))
}

func (SchemaUpdate_Directive) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{34, 0}
}

type List struct {
	Uids                 []uint64 `protobuf:"fixed64,1,rep,packed,name=uids,proto3" json:"uids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *List) Reset()         { *m = List{} }
func (m *List) String() string { return proto.CompactTextString(m) }
func (*List) ProtoMessage()    {}
func (*List) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0}
}
func (m *List) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *List) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_List.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *List) XXX_Merge(src proto.Message) {
	xxx_messageInfo_List.Merge(m, src)
}
func (m *List) XXX_Size() int {
	return m.Size()
}
func (m *List) XXX_DiscardUnknown() {
	xxx_messageInfo_List.DiscardUnknown(m)
}

var xxx_messageInfo_List proto.InternalMessageInfo

func (m *List) GetUids() []uint64 {
	if m != nil {
		return m.Uids
	}
	return nil
}

type TaskValue struct {
	Val                  []byte          `protobuf:"bytes,1,opt,name=val,proto3" json:"val,omitempty"`
	ValType              Posting_ValType `protobuf:"varint,2,opt,name=val_type,json=valType,proto3,enum=pb.Posting_ValType" json:"val_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *TaskValue) Reset()         { *m = TaskValue{} }
func (m *TaskValue) String() string { return proto.CompactTextString(m) }
func (*TaskValue) ProtoMessage()    {}
func (*TaskValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{1}
}
func (m *TaskValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskValue.Merge(m, src)
}
func (m *TaskValue) XXX_Size() int {
	return m.Size()
}
func (m *TaskValue) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskValue.DiscardUnknown(m)
}

var xxx_messageInfo_TaskValue proto.InternalMessageInfo

func (m *TaskValue) GetVal() []byte {
	if m != nil {
		return m.Val
	}
	return nil
}

func (m *TaskValue) GetValType() Posting_ValType {
	if m != nil {
		return m.ValType
	}
	return Posting_DEFAULT
}

type SrcFunction struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Args                 []string `protobuf:"bytes,3,rep,name=args,proto3" json:"args,omitempty"`
	IsCount              bool     `protobuf:"varint,4,opt,name=isCount,proto3" json:"isCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SrcFunction) Reset()         { *m = SrcFunction{} }
func (m *SrcFunction) String() string { return proto.CompactTextString(m) }
func (*SrcFunction) ProtoMessage()    {}
func (*SrcFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{2}
}
func (m *SrcFunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SrcFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SrcFunction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SrcFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SrcFunction.Merge(m, src)
}
func (m *SrcFunction) XXX_Size() int {
	return m.Size()
}
func (m *SrcFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_SrcFunction.DiscardUnknown(m)
}

var xxx_messageInfo_SrcFunction proto.InternalMessageInfo

func (m *SrcFunction) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SrcFunction) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *SrcFunction) GetIsCount() bool {
	if m != nil {
		return m.IsCount
	}
	return false
}

type Query struct {
	Attr     string   `protobuf:"bytes,1,opt,name=attr,proto3" json:"attr,omitempty"`
	Langs    []string `protobuf:"bytes,2,rep,name=langs,proto3" json:"langs,omitempty"`
	AfterUid uint64   `protobuf:"fixed64,3,opt,name=after_uid,json=afterUid,proto3" json:"after_uid,omitempty"`
	DoCount  bool     `protobuf:"varint,4,opt,name=do_count,json=doCount,proto3" json:"do_count,omitempty"`
	// Exactly one of uids and terms is populated.
	UidList *List `protobuf:"bytes,5,opt,name=uid_list,json=uidList,proto3" json:"uid_list,omitempty"`
	// Function to generate or filter UIDs.
	SrcFunc              *SrcFunction `protobuf:"bytes,6,opt,name=src_func,json=srcFunc,proto3" json:"src_func,omitempty"`
	Reverse              bool         `protobuf:"varint,7,opt,name=reverse,proto3" json:"reverse,omitempty"`
	FacetParam           *FacetParams `protobuf:"bytes,8,opt,name=facet_param,json=facetParam,proto3" json:"facet_param,omitempty"`
	FacetsFilter         *FilterTree  `protobuf:"bytes,9,opt,name=facets_filter,json=facetsFilter,proto3" json:"facets_filter,omitempty"`
	ExpandAll            bool         `protobuf:"varint,10,opt,name=expand_all,json=expandAll,proto3" json:"expand_all,omitempty"`
	ReadTs               uint64       `protobuf:"varint,13,opt,name=read_ts,json=readTs,proto3" json:"read_ts,omitempty"`
	Cache                int32        `protobuf:"varint,14,opt,name=cache,proto3" json:"cache,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Query) Reset()         { *m = Query{} }
func (m *Query) String() string { return proto.CompactTextString(m) }
func (*Query) ProtoMessage()    {}
func (*Query) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{3}
}
func (m *Query) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Query) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Query.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Query) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Query.Merge(m, src)
}
func (m *Query) XXX_Size() int {
	return m.Size()
}
func (m *Query) XXX_DiscardUnknown() {
	xxx_messageInfo_Query.DiscardUnknown(m)
}

var xxx_messageInfo_Query proto.InternalMessageInfo

func (m *Query) GetAttr() string {
	if m != nil {
		return m.Attr
	}
	return ""
}

func (m *Query) GetLangs() []string {
	if m != nil {
		return m.Langs
	}
	return nil
}

func (m *Query) GetAfterUid() uint64 {
	if m != nil {
		return m.AfterUid
	}
	return 0
}

func (m *Query) GetDoCount() bool {
	if m != nil {
		return m.DoCount
	}
	return false
}

func (m *Query) GetUidList() *List {
	if m != nil {
		return m.UidList
	}
	return nil
}

func (m *Query) GetSrcFunc() *SrcFunction {
	if m != nil {
		return m.SrcFunc
	}
	return nil
}

func (m *Query) GetReverse() bool {
	if m != nil {
		return m.Reverse
	}
	return false
}

func (m *Query) GetFacetParam() *FacetParams {
	if m != nil {
		return m.FacetParam
	}
	return nil
}

func (m *Query) GetFacetsFilter() *FilterTree {
	if m != nil {
		return m.FacetsFilter
	}
	return nil
}

func (m *Query) GetExpandAll() bool {
	if m != nil {
		return m.ExpandAll
	}
	return false
}

func (m *Query) GetReadTs() uint64 {
	if m != nil {
		return m.ReadTs
	}
	return 0
}

func (m *Query) GetCache() int32 {
	if m != nil {
		return m.Cache
	}
	return 0
}

type ValueList struct {
	Values               []*TaskValue `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ValueList) Reset()         { *m = ValueList{} }
func (m *ValueList) String() string { return proto.CompactTextString(m) }
func (*ValueList) ProtoMessage()    {}
func (*ValueList) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{4}
}
func (m *ValueList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValueList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValueList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValueList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValueList.Merge(m, src)
}
func (m *ValueList) XXX_Size() int {
	return m.Size()
}
func (m *ValueList) XXX_DiscardUnknown() {
	xxx_messageInfo_ValueList.DiscardUnknown(m)
}

var xxx_messageInfo_ValueList proto.InternalMessageInfo

func (m *ValueList) GetValues() []*TaskValue {
	if m != nil {
		return m.Values
	}
	return nil
}

type LangList struct {
	Lang                 []string `protobuf:"bytes,1,rep,name=lang,proto3" json:"lang,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LangList) Reset()         { *m = LangList{} }
func (m *LangList) String() string { return proto.CompactTextString(m) }
func (*LangList) ProtoMessage()    {}
func (*LangList) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{5}
}
func (m *LangList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LangList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LangList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LangList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LangList.Merge(m, src)
}
func (m *LangList) XXX_Size() int {
	return m.Size()
}
func (m *LangList) XXX_DiscardUnknown() {
	xxx_messageInfo_LangList.DiscardUnknown(m)
}

var xxx_messageInfo_LangList proto.InternalMessageInfo

func (m *LangList) GetLang() []string {
	if m != nil {
		return m.Lang
	}
	return nil
}

type Result struct {
	UidMatrix            []*List       `protobuf:"bytes,1,rep,name=uid_matrix,json=uidMatrix,proto3" json:"uid_matrix,omitempty"`
	ValueMatrix          []*ValueList  `protobuf:"bytes,2,rep,name=value_matrix,json=valueMatrix,proto3" json:"value_matrix,omitempty"`
	Counts               []uint32      `protobuf:"varint,3,rep,packed,name=counts,proto3" json:"counts,omitempty"`
	IntersectDest        bool          `protobuf:"varint,4,opt,name=intersect_dest,json=intersectDest,proto3" json:"intersect_dest,omitempty"`
	FacetMatrix          []*FacetsList `protobuf:"bytes,5,rep,name=facet_matrix,json=facetMatrix,proto3" json:"facet_matrix,omitempty"`
	LangMatrix           []*LangList   `protobuf:"bytes,6,rep,name=lang_matrix,json=langMatrix,proto3" json:"lang_matrix,omitempty"`
	List                 bool          `protobuf:"varint,7,opt,name=list,proto3" json:"list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Result) Reset()         { *m = Result{} }
func (m *Result) String() string { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()    {}
func (*Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{6}
}
func (m *Result) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Result.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Result.Merge(m, src)
}
func (m *Result) XXX_Size() int {
	return m.Size()
}
func (m *Result) XXX_DiscardUnknown() {
	xxx_messageInfo_Result.DiscardUnknown(m)
}

var xxx_messageInfo_Result proto.InternalMessageInfo

func (m *Result) GetUidMatrix() []*List {
	if m != nil {
		return m.UidMatrix
	}
	return nil
}

func (m *Result) GetValueMatrix() []*ValueList {
	if m != nil {
		return m.ValueMatrix
	}
	return nil
}

func (m *Result) GetCounts() []uint32 {
	if m != nil {
		return m.Counts
	}
	return nil
}

func (m *Result) GetIntersectDest() bool {
	if m != nil {
		return m.IntersectDest
	}
	return false
}

func (m *Result) GetFacetMatrix() []*FacetsList {
	if m != nil {
		return m.FacetMatrix
	}
	return nil
}

func (m *Result) GetLangMatrix() []*LangList {
	if m != nil {
		return m.LangMatrix
	}
	return nil
}

func (m *Result) GetList() bool {
	if m != nil {
		return m.List
	}
	return false
}

type Order struct {
	Attr                 string   `protobuf:"bytes,1,opt,name=attr,proto3" json:"attr,omitempty"`
	Desc                 bool     `protobuf:"varint,2,opt,name=desc,proto3" json:"desc,omitempty"`
	Langs                []string `protobuf:"bytes,3,rep,name=langs,proto3" json:"langs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{7}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetAttr() string {
	if m != nil {
		return m.Attr
	}
	return ""
}

func (m *Order) GetDesc() bool {
	if m != nil {
		return m.Desc
	}
	return false
}

func (m *Order) GetLangs() []string {
	if m != nil {
		return m.Langs
	}
	return nil
}

type SortMessage struct {
	Order                []*Order `protobuf:"bytes,1,rep,name=order,proto3" json:"order,omitempty"`
	UidMatrix            []*List  `protobuf:"bytes,2,rep,name=uid_matrix,json=uidMatrix,proto3" json:"uid_matrix,omitempty"`
	Count                int32    `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty"`
	Offset               int32    `protobuf:"varint,4,opt,name=offset,proto3" json:"offset,omitempty"`
	ReadTs               uint64   `protobuf:"varint,13,opt,name=read_ts,json=readTs,proto3" json:"read_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SortMessage) Reset()         { *m = SortMessage{} }
func (m *SortMessage) String() string { return proto.CompactTextString(m) }
func (*SortMessage) ProtoMessage()    {}
func (*SortMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{8}
}
func (m *SortMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SortMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SortMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SortMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SortMessage.Merge(m, src)
}
func (m *SortMessage) XXX_Size() int {
	return m.Size()
}
func (m *SortMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_SortMessage.DiscardUnknown(m)
}

var xxx_messageInfo_SortMessage proto.InternalMessageInfo

func (m *SortMessage) GetOrder() []*Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *SortMessage) GetUidMatrix() []*List {
	if m != nil {
		return m.UidMatrix
	}
	return nil
}

func (m *SortMessage) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *SortMessage) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *SortMessage) GetReadTs() uint64 {
	if m != nil {
		return m.ReadTs
	}
	return 0
}

type SortResult struct {
	UidMatrix            []*List  `protobuf:"bytes,1,rep,name=uid_matrix,json=uidMatrix,proto3" json:"uid_matrix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SortResult) Reset()         { *m = SortResult{} }
func (m *SortResult) String() string { return proto.CompactTextString(m) }
func (*SortResult) ProtoMessage()    {}
func (*SortResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{9}
}
func (m *SortResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SortResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SortResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SortResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SortResult.Merge(m, src)
}
func (m *SortResult) XXX_Size() int {
	return m.Size()
}
func (m *SortResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SortResult.DiscardUnknown(m)
}

var xxx_messageInfo_SortResult proto.InternalMessageInfo

func (m *SortResult) GetUidMatrix() []*List {
	if m != nil {
		return m.UidMatrix
	}
	return nil
}

type RaftContext struct {
	Id                   uint64   `protobuf:"fixed64,1,opt,name=id,proto3" json:"id,omitempty"`
	Group                uint32   `protobuf:"varint,2,opt,name=group,proto3" json:"group,omitempty"`
	Addr                 string   `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
	SnapshotTs           uint64   `protobuf:"varint,4,opt,name=snapshot_ts,json=snapshotTs,proto3" json:"snapshot_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RaftContext) Reset()         { *m = RaftContext{} }
func (m *RaftContext) String() string { return proto.CompactTextString(m) }
func (*RaftContext) ProtoMessage()    {}
func (*RaftContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{10}
}
func (m *RaftContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftContext.Merge(m, src)
}
func (m *RaftContext) XXX_Size() int {
	return m.Size()
}
func (m *RaftContext) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftContext.DiscardUnknown(m)
}

var xxx_messageInfo_RaftContext proto.InternalMessageInfo

func (m *RaftContext) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RaftContext) GetGroup() uint32 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *RaftContext) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *RaftContext) GetSnapshotTs() uint64 {
	if m != nil {
		return m.SnapshotTs
	}
	return 0
}

// Member stores information about RAFT group member for a single RAFT node.
// Note that each server can be serving multiple RAFT groups. Each group would have
// one RAFT node per server serving that group.
type Member struct {
	Id                   uint64   `protobuf:"fixed64,1,opt,name=id,proto3" json:"id,omitempty"`
	GroupId              uint32   `protobuf:"varint,2,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	Addr                 string   `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
	Leader               bool     `protobuf:"varint,4,opt,name=leader,proto3" json:"leader,omitempty"`
	AmDead               bool     `protobuf:"varint,5,opt,name=am_dead,json=amDead,proto3" json:"am_dead,omitempty"`
	LastUpdate           uint64   `protobuf:"varint,6,opt,name=last_update,json=lastUpdate,proto3" json:"last_update,omitempty"`
	ClusterInfoOnly      bool     `protobuf:"varint,13,opt,name=cluster_info_only,json=clusterInfoOnly,proto3" json:"cluster_info_only,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Member) Reset()         { *m = Member{} }
func (m *Member) String() string { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()    {}
func (*Member) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{11}
}
func (m *Member) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Member) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Member.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Member) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Member.Merge(m, src)
}
func (m *Member) XXX_Size() int {
	return m.Size()
}
func (m *Member) XXX_DiscardUnknown() {
	xxx_messageInfo_Member.DiscardUnknown(m)
}

var xxx_messageInfo_Member proto.InternalMessageInfo

func (m *Member) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Member) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *Member) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *Member) GetLeader() bool {
	if m != nil {
		return m.Leader
	}
	return false
}

func (m *Member) GetAmDead() bool {
	if m != nil {
		return m.AmDead
	}
	return false
}

func (m *Member) GetLastUpdate() uint64 {
	if m != nil {
		return m.LastUpdate
	}
	return 0
}

func (m *Member) GetClusterInfoOnly() bool {
	if m != nil {
		return m.ClusterInfoOnly
	}
	return false
}

type Group struct {
	Members              map[uint64]*Member `protobuf:"bytes,1,rep,name=members,proto3" json:"members,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Tablets              map[string]*Tablet `protobuf:"bytes,2,rep,name=tablets,proto3" json:"tablets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	SnapshotTs           uint64             `protobuf:"varint,3,opt,name=snapshot_ts,json=snapshotTs,proto3" json:"snapshot_ts,omitempty"`
	Checksum             uint64             `protobuf:"varint,4,opt,name=checksum,proto3" json:"checksum,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *Group) Reset()         { *m = Group{} }
func (m *Group) String() string { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()    {}
func (*Group) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{12}
}
func (m *Group) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Group) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Group.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Group) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Group.Merge(m, src)
}
func (m *Group) XXX_Size() int {
	return m.Size()
}
func (m *Group) XXX_DiscardUnknown() {
	xxx_messageInfo_Group.DiscardUnknown(m)
}

var xxx_messageInfo_Group proto.InternalMessageInfo

func (m *Group) GetMembers() map[uint64]*Member {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *Group) GetTablets() map[string]*Tablet {
	if m != nil {
		return m.Tablets
	}
	return nil
}

func (m *Group) GetSnapshotTs() uint64 {
	if m != nil {
		return m.SnapshotTs
	}
	return 0
}

func (m *Group) GetChecksum() uint64 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

type ZeroProposal struct {
	SnapshotTs           map[uint32]uint64 `protobuf:"bytes,1,rep,name=snapshot_ts,json=snapshotTs,proto3" json:"snapshot_ts,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Member               *Member           `protobuf:"bytes,2,opt,name=member,proto3" json:"member,omitempty"`
	Tablet               *Tablet           `protobuf:"bytes,3,opt,name=tablet,proto3" json:"tablet,omitempty"`
	MaxLeaseId           uint64            `protobuf:"varint,4,opt,name=maxLeaseId,proto3" json:"maxLeaseId,omitempty"`
	MaxTxnTs             uint64            `protobuf:"varint,5,opt,name=maxTxnTs,proto3" json:"maxTxnTs,omitempty"`
	MaxRaftId            uint64            `protobuf:"varint,6,opt,name=maxRaftId,proto3" json:"maxRaftId,omitempty"`
	Txn                  *api.TxnContext   `protobuf:"bytes,7,opt,name=txn,proto3" json:"txn,omitempty"`
	Key                  string            `protobuf:"bytes,8,opt,name=key,proto3" json:"key,omitempty"`
	Cid                  string            `protobuf:"bytes,9,opt,name=cid,proto3" json:"cid,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ZeroProposal) Reset()         { *m = ZeroProposal{} }
func (m *ZeroProposal) String() string { return proto.CompactTextString(m) }
func (*ZeroProposal) ProtoMessage()    {}
func (*ZeroProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{13}
}
func (m *ZeroProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroProposal.Merge(m, src)
}
func (m *ZeroProposal) XXX_Size() int {
	return m.Size()
}
func (m *ZeroProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroProposal.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroProposal proto.InternalMessageInfo

func (m *ZeroProposal) GetSnapshotTs() map[uint32]uint64 {
	if m != nil {
		return m.SnapshotTs
	}
	return nil
}

func (m *ZeroProposal) GetMember() *Member {
	if m != nil {
		return m.Member
	}
	return nil
}

func (m *ZeroProposal) GetTablet() *Tablet {
	if m != nil {
		return m.Tablet
	}
	return nil
}

func (m *ZeroProposal) GetMaxLeaseId() uint64 {
	if m != nil {
		return m.MaxLeaseId
	}
	return 0
}

func (m *ZeroProposal) GetMaxTxnTs() uint64 {
	if m != nil {
		return m.MaxTxnTs
	}
	return 0
}

func (m *ZeroProposal) GetMaxRaftId() uint64 {
	if m != nil {
		return m.MaxRaftId
	}
	return 0
}

func (m *ZeroProposal) GetTxn() *api.TxnContext {
	if m != nil {
		return m.Txn
	}
	return nil
}

func (m *ZeroProposal) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *ZeroProposal) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

// MembershipState is used to pack together the current membership state of all the nodes
// in the caller server; and the membership updates recorded by the callee server since
// the provided lastUpdate.
type MembershipState struct {
	Counter              uint64             `protobuf:"varint,1,opt,name=counter,proto3" json:"counter,omitempty"`
	Groups               map[uint32]*Group  `protobuf:"bytes,2,rep,name=groups,proto3" json:"groups,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Zeros                map[uint64]*Member `protobuf:"bytes,3,rep,name=zeros,proto3" json:"zeros,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MaxLeaseId           uint64             `protobuf:"varint,4,opt,name=maxLeaseId,proto3" json:"maxLeaseId,omitempty"`
	MaxTxnTs             uint64             `protobuf:"varint,5,opt,name=maxTxnTs,proto3" json:"maxTxnTs,omitempty"`
	MaxRaftId            uint64             `protobuf:"varint,6,opt,name=maxRaftId,proto3" json:"maxRaftId,omitempty"`
	Removed              []*Member          `protobuf:"bytes,7,rep,name=removed,proto3" json:"removed,omitempty"`
	Cid                  string             `protobuf:"bytes,8,opt,name=cid,proto3" json:"cid,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *MembershipState) Reset()         { *m = MembershipState{} }
func (m *MembershipState) String() string { return proto.CompactTextString(m) }
func (*MembershipState) ProtoMessage()    {}
func (*MembershipState) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{14}
}
func (m *MembershipState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MembershipState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MembershipState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MembershipState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MembershipState.Merge(m, src)
}
func (m *MembershipState) XXX_Size() int {
	return m.Size()
}
func (m *MembershipState) XXX_DiscardUnknown() {
	xxx_messageInfo_MembershipState.DiscardUnknown(m)
}

var xxx_messageInfo_MembershipState proto.InternalMessageInfo

func (m *MembershipState) GetCounter() uint64 {
	if m != nil {
		return m.Counter
	}
	return 0
}

func (m *MembershipState) GetGroups() map[uint32]*Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *MembershipState) GetZeros() map[uint64]*Member {
	if m != nil {
		return m.Zeros
	}
	return nil
}

func (m *MembershipState) GetMaxLeaseId() uint64 {
	if m != nil {
		return m.MaxLeaseId
	}
	return 0
}

func (m *MembershipState) GetMaxTxnTs() uint64 {
	if m != nil {
		return m.MaxTxnTs
	}
	return 0
}

func (m *MembershipState) GetMaxRaftId() uint64 {
	if m != nil {
		return m.MaxRaftId
	}
	return 0
}

func (m *MembershipState) GetRemoved() []*Member {
	if m != nil {
		return m.Removed
	}
	return nil
}

func (m *MembershipState) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

type ConnectionState struct {
	Member               *Member          `protobuf:"bytes,1,opt,name=member,proto3" json:"member,omitempty"`
	State                *MembershipState `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
	MaxPending           uint64           `protobuf:"varint,3,opt,name=max_pending,json=maxPending,proto3" json:"max_pending,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ConnectionState) Reset()         { *m = ConnectionState{} }
func (m *ConnectionState) String() string { return proto.CompactTextString(m) }
func (*ConnectionState) ProtoMessage()    {}
func (*ConnectionState) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{15}
}
func (m *ConnectionState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectionState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectionState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectionState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionState.Merge(m, src)
}
func (m *ConnectionState) XXX_Size() int {
	return m.Size()
}
func (m *ConnectionState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionState.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionState proto.InternalMessageInfo

func (m *ConnectionState) GetMember() *Member {
	if m != nil {
		return m.Member
	}
	return nil
}

func (m *ConnectionState) GetState() *MembershipState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *ConnectionState) GetMaxPending() uint64 {
	if m != nil {
		return m.MaxPending
	}
	return 0
}

type Tablet struct {
	GroupId              uint32   `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	Predicate            string   `protobuf:"bytes,2,opt,name=predicate,proto3" json:"predicate,omitempty"`
	Force                bool     `protobuf:"varint,3,opt,name=force,proto3" json:"force,omitempty"`
	Space                int64    `protobuf:"varint,7,opt,name=space,proto3" json:"space,omitempty"`
	Remove               bool     `protobuf:"varint,8,opt,name=remove,proto3" json:"remove,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tablet) Reset()         { *m = Tablet{} }
func (m *Tablet) String() string { return proto.CompactTextString(m) }
func (*Tablet) ProtoMessage()    {}
func (*Tablet) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{16}
}
func (m *Tablet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tablet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tablet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tablet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tablet.Merge(m, src)
}
func (m *Tablet) XXX_Size() int {
	return m.Size()
}
func (m *Tablet) XXX_DiscardUnknown() {
	xxx_messageInfo_Tablet.DiscardUnknown(m)
}

var xxx_messageInfo_Tablet proto.InternalMessageInfo

func (m *Tablet) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *Tablet) GetPredicate() string {
	if m != nil {
		return m.Predicate
	}
	return ""
}

func (m *Tablet) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

func (m *Tablet) GetSpace() int64 {
	if m != nil {
		return m.Space
	}
	return 0
}

func (m *Tablet) GetRemove() bool {
	if m != nil {
		return m.Remove
	}
	return false
}

type DirectedEdge struct {
	Entity               uint64          `protobuf:"fixed64,1,opt,name=entity,proto3" json:"entity,omitempty"`
	Attr                 string          `protobuf:"bytes,2,opt,name=attr,proto3" json:"attr,omitempty"`
	Value                []byte          `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	ValueType            Posting_ValType `protobuf:"varint,4,opt,name=value_type,json=valueType,proto3,enum=pb.Posting_ValType" json:"value_type,omitempty"`
	ValueId              uint64          `protobuf:"fixed64,5,opt,name=value_id,json=valueId,proto3" json:"value_id,omitempty"`
	Label                string          `protobuf:"bytes,6,opt,name=label,proto3" json:"label,omitempty"`
	Lang                 string          `protobuf:"bytes,7,opt,name=lang,proto3" json:"lang,omitempty"`
	Op                   DirectedEdge_Op `protobuf:"varint,8,opt,name=op,proto3,enum=pb.DirectedEdge_Op" json:"op,omitempty"`
	Facets               []*api.Facet    `protobuf:"bytes,9,rep,name=facets,proto3" json:"facets,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *DirectedEdge) Reset()         { *m = DirectedEdge{} }
func (m *DirectedEdge) String() string { return proto.CompactTextString(m) }
func (*DirectedEdge) ProtoMessage()    {}
func (*DirectedEdge) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{17}
}
func (m *DirectedEdge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectedEdge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DirectedEdge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DirectedEdge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectedEdge.Merge(m, src)
}
func (m *DirectedEdge) XXX_Size() int {
	return m.Size()
}
func (m *DirectedEdge) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectedEdge.DiscardUnknown(m)
}

var xxx_messageInfo_DirectedEdge proto.InternalMessageInfo

func (m *DirectedEdge) GetEntity() uint64 {
	if m != nil {
		return m.Entity
	}
	return 0
}

func (m *DirectedEdge) GetAttr() string {
	if m != nil {
		return m.Attr
	}
	return ""
}

func (m *DirectedEdge) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *DirectedEdge) GetValueType() Posting_ValType {
	if m != nil {
		return m.ValueType
	}
	return Posting_DEFAULT
}

func (m *DirectedEdge) GetValueId() uint64 {
	if m != nil {
		return m.ValueId
	}
	return 0
}

func (m *DirectedEdge) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *DirectedEdge) GetLang() string {
	if m != nil {
		return m.Lang
	}
	return ""
}

func (m *DirectedEdge) GetOp() DirectedEdge_Op {
	if m != nil {
		return m.Op
	}
	return DirectedEdge_SET
}

func (m *DirectedEdge) GetFacets() []*api.Facet {
	if m != nil {
		return m.Facets
	}
	return nil
}

type Mutations struct {
	GroupId              uint32          `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	StartTs              uint64          `protobuf:"varint,2,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	Edges                []*DirectedEdge `protobuf:"bytes,3,rep,name=edges,proto3" json:"edges,omitempty"`
	Schema               []*SchemaUpdate `protobuf:"bytes,4,rep,name=schema,proto3" json:"schema,omitempty"`
	DropAll              bool            `protobuf:"varint,5,opt,name=drop_all,json=dropAll,proto3" json:"drop_all,omitempty"`
	IgnoreIndexConflict  bool            `protobuf:"varint,6,opt,name=ignore_index_conflict,json=ignoreIndexConflict,proto3" json:"ignore_index_conflict,omitempty"`
	Types                []*TypeUpdate   `protobuf:"bytes,7,rep,name=types,proto3" json:"types,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Mutations) Reset()         { *m = Mutations{} }
func (m *Mutations) String() string { return proto.CompactTextString(m) }
func (*Mutations) ProtoMessage()    {}
func (*Mutations) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{18}
}
func (m *Mutations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Mutations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Mutations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Mutations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Mutations.Merge(m, src)
}
func (m *Mutations) XXX_Size() int {
	return m.Size()
}
func (m *Mutations) XXX_DiscardUnknown() {
	xxx_messageInfo_Mutations.DiscardUnknown(m)
}

var xxx_messageInfo_Mutations proto.InternalMessageInfo

func (m *Mutations) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *Mutations) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *Mutations) GetEdges() []*DirectedEdge {
	if m != nil {
		return m.Edges
	}
	return nil
}

func (m *Mutations) GetSchema() []*SchemaUpdate {
	if m != nil {
		return m.Schema
	}
	return nil
}

func (m *Mutations) GetDropAll() bool {
	if m != nil {
		return m.DropAll
	}
	return false
}

func (m *Mutations) GetIgnoreIndexConflict() bool {
	if m != nil {
		return m.IgnoreIndexConflict
	}
	return false
}

func (m *Mutations) GetTypes() []*TypeUpdate {
	if m != nil {
		return m.Types
	}
	return nil
}

type Snapshot struct {
	Context *RaftContext `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Index   uint64       `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	ReadTs  uint64       `protobuf:"varint,3,opt,name=read_ts,json=readTs,proto3" json:"read_ts,omitempty"`
	// done is used to indicate that snapshot stream was a success.
	Done                 bool     `protobuf:"varint,4,opt,name=done,proto3" json:"done,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Snapshot) Reset()         { *m = Snapshot{} }
func (m *Snapshot) String() string { return proto.CompactTextString(m) }
func (*Snapshot) ProtoMessage()    {}
func (*Snapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{19}
}
func (m *Snapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Snapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot.Merge(m, src)
}
func (m *Snapshot) XXX_Size() int {
	return m.Size()
}
func (m *Snapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot proto.InternalMessageInfo

func (m *Snapshot) GetContext() *RaftContext {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *Snapshot) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Snapshot) GetReadTs() uint64 {
	if m != nil {
		return m.ReadTs
	}
	return 0
}

func (m *Snapshot) GetDone() bool {
	if m != nil {
		return m.Done
	}
	return false
}

type Proposal struct {
	Mutations            *Mutations       `protobuf:"bytes,2,opt,name=mutations,proto3" json:"mutations,omitempty"`
	Kv                   []*pb.KV         `protobuf:"bytes,4,rep,name=kv,proto3" json:"kv,omitempty"`
	State                *MembershipState `protobuf:"bytes,5,opt,name=state,proto3" json:"state,omitempty"`
	CleanPredicate       string           `protobuf:"bytes,6,opt,name=clean_predicate,json=cleanPredicate,proto3" json:"clean_predicate,omitempty"`
	Key                  string           `protobuf:"bytes,7,opt,name=key,proto3" json:"key,omitempty"`
	Delta                *OracleDelta     `protobuf:"bytes,8,opt,name=delta,proto3" json:"delta,omitempty"`
	Snapshot             *Snapshot        `protobuf:"bytes,9,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	Index                uint64           `protobuf:"varint,10,opt,name=index,proto3" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Proposal) Reset()         { *m = Proposal{} }
func (m *Proposal) String() string { return proto.CompactTextString(m) }
func (*Proposal) ProtoMessage()    {}
func (*Proposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{20}
}
func (m *Proposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal.Merge(m, src)
}
func (m *Proposal) XXX_Size() int {
	return m.Size()
}
func (m *Proposal) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal proto.InternalMessageInfo

func (m *Proposal) GetMutations() *Mutations {
	if m != nil {
		return m.Mutations
	}
	return nil
}

func (m *Proposal) GetKv() []*pb.KV {
	if m != nil {
		return m.Kv
	}
	return nil
}

func (m *Proposal) GetState() *MembershipState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *Proposal) GetCleanPredicate() string {
	if m != nil {
		return m.CleanPredicate
	}
	return ""
}

func (m *Proposal) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Proposal) GetDelta() *OracleDelta {
	if m != nil {
		return m.Delta
	}
	return nil
}

func (m *Proposal) GetSnapshot() *Snapshot {
	if m != nil {
		return m.Snapshot
	}
	return nil
}

func (m *Proposal) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

type KVS struct {
	Kv []*pb.KV `protobuf:"bytes,1,rep,name=kv,proto3" json:"kv,omitempty"`
	// done used to indicate if the stream of KVS is over.
	Done                 bool     `protobuf:"varint,2,opt,name=done,proto3" json:"done,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KVS) Reset()         { *m = KVS{} }
func (m *KVS) String() string { return proto.CompactTextString(m) }
func (*KVS) ProtoMessage()    {}
func (*KVS) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{21}
}
func (m *KVS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVS.Merge(m, src)
}
func (m *KVS) XXX_Size() int {
	return m.Size()
}
func (m *KVS) XXX_DiscardUnknown() {
	xxx_messageInfo_KVS.DiscardUnknown(m)
}

var xxx_messageInfo_KVS proto.InternalMessageInfo

func (m *KVS) GetKv() []*pb.KV {
	if m != nil {
		return m.Kv
	}
	return nil
}

func (m *KVS) GetDone() bool {
	if m != nil {
		return m.Done
	}
	return false
}

// Posting messages.
type Posting struct {
	Uid         uint64              `protobuf:"fixed64,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Value       []byte              `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	ValType     Posting_ValType     `protobuf:"varint,3,opt,name=val_type,json=valType,proto3,enum=pb.Posting_ValType" json:"val_type,omitempty"`
	PostingType Posting_PostingType `protobuf:"varint,4,opt,name=posting_type,json=postingType,proto3,enum=pb.Posting_PostingType" json:"posting_type,omitempty"`
	LangTag     []byte              `protobuf:"bytes,5,opt,name=lang_tag,json=langTag,proto3" json:"lang_tag,omitempty"`
	Label       string              `protobuf:"bytes,6,opt,name=label,proto3" json:"label,omitempty"`
	Facets      []*api.Facet        `protobuf:"bytes,9,rep,name=facets,proto3" json:"facets,omitempty"`
	// TODO: op is only used temporarily. See if we can remove it from here.
	Op                   uint32   `protobuf:"varint,12,opt,name=op,proto3" json:"op,omitempty"`
	StartTs              uint64   `protobuf:"varint,13,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	CommitTs             uint64   `protobuf:"varint,14,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Posting) Reset()         { *m = Posting{} }
func (m *Posting) String() string { return proto.CompactTextString(m) }
func (*Posting) ProtoMessage()    {}
func (*Posting) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{22}
}
func (m *Posting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Posting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Posting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Posting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Posting.Merge(m, src)
}
func (m *Posting) XXX_Size() int {
	return m.Size()
}
func (m *Posting) XXX_DiscardUnknown() {
	xxx_messageInfo_Posting.DiscardUnknown(m)
}

var xxx_messageInfo_Posting proto.InternalMessageInfo

func (m *Posting) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *Posting) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Posting) GetValType() Posting_ValType {
	if m != nil {
		return m.ValType
	}
	return Posting_DEFAULT
}

func (m *Posting) GetPostingType() Posting_PostingType {
	if m != nil {
		return m.PostingType
	}
	return Posting_REF
}

func (m *Posting) GetLangTag() []byte {
	if m != nil {
		return m.LangTag
	}
	return nil
}

func (m *Posting) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *Posting) GetFacets() []*api.Facet {
	if m != nil {
		return m.Facets
	}
	return nil
}

func (m *Posting) GetOp() uint32 {
	if m != nil {
		return m.Op
	}
	return 0
}

func (m *Posting) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *Posting) GetCommitTs() uint64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

type UidBlock struct {
	Base uint64 `protobuf:"varint,1,opt,name=base,proto3" json:"base,omitempty"`
	// deltas contains the deltas encoded with Varints. We don't store deltas as a list of integers,
	// because when the PB is brought to memory, Go would always use 8-bytes per integer. Instead,
	// storing it as a byte slice is a lot cheaper in memory.
	Deltas               []byte   `protobuf:"bytes,2,opt,name=deltas,proto3" json:"deltas,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UidBlock) Reset()         { *m = UidBlock{} }
func (m *UidBlock) String() string { return proto.CompactTextString(m) }
func (*UidBlock) ProtoMessage()    {}
func (*UidBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{23}
}
func (m *UidBlock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UidBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UidBlock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UidBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UidBlock.Merge(m, src)
}
func (m *UidBlock) XXX_Size() int {
	return m.Size()
}
func (m *UidBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_UidBlock.DiscardUnknown(m)
}

var xxx_messageInfo_UidBlock proto.InternalMessageInfo

func (m *UidBlock) GetBase() uint64 {
	if m != nil {
		return m.Base
	}
	return 0
}

func (m *UidBlock) GetDeltas() []byte {
	if m != nil {
		return m.Deltas
	}
	return nil
}

type UidPack struct {
	BlockSize            uint32      `protobuf:"varint,1,opt,name=block_size,json=blockSize,proto3" json:"block_size,omitempty"`
	Blocks               []*UidBlock `protobuf:"bytes,2,rep,name=blocks,proto3" json:"blocks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *UidPack) Reset()         { *m = UidPack{} }
func (m *UidPack) String() string { return proto.CompactTextString(m) }
func (*UidPack) ProtoMessage()    {}
func (*UidPack) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{24}
}
func (m *UidPack) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UidPack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UidPack.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UidPack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UidPack.Merge(m, src)
}
func (m *UidPack) XXX_Size() int {
	return m.Size()
}
func (m *UidPack) XXX_DiscardUnknown() {
	xxx_messageInfo_UidPack.DiscardUnknown(m)
}

var xxx_messageInfo_UidPack proto.InternalMessageInfo

func (m *UidPack) GetBlockSize() uint32 {
	if m != nil {
		return m.BlockSize
	}
	return 0
}

func (m *UidPack) GetBlocks() []*UidBlock {
	if m != nil {
		return m.Blocks
	}
	return nil
}

type PostingList struct {
	Pack                 *UidPack   `protobuf:"bytes,1,opt,name=pack,proto3" json:"pack,omitempty"`
	Postings             []*Posting `protobuf:"bytes,2,rep,name=postings,proto3" json:"postings,omitempty"`
	CommitTs             uint64     `protobuf:"varint,3,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *PostingList) Reset()         { *m = PostingList{} }
func (m *PostingList) String() string { return proto.CompactTextString(m) }
func (*PostingList) ProtoMessage()    {}
func (*PostingList) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{25}
}
func (m *PostingList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PostingList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PostingList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PostingList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PostingList.Merge(m, src)
}
func (m *PostingList) XXX_Size() int {
	return m.Size()
}
func (m *PostingList) XXX_DiscardUnknown() {
	xxx_messageInfo_PostingList.DiscardUnknown(m)
}

var xxx_messageInfo_PostingList proto.InternalMessageInfo

func (m *PostingList) GetPack() *UidPack {
	if m != nil {
		return m.Pack
	}
	return nil
}

func (m *PostingList) GetPostings() []*Posting {
	if m != nil {
		return m.Postings
	}
	return nil
}

func (m *PostingList) GetCommitTs() uint64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

type FacetParam struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Alias                string   `protobuf:"bytes,2,opt,name=alias,proto3" json:"alias,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FacetParam) Reset()         { *m = FacetParam{} }
func (m *FacetParam) String() string { return proto.CompactTextString(m) }
func (*FacetParam) ProtoMessage()    {}
func (*FacetParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{26}
}
func (m *FacetParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FacetParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FacetParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FacetParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FacetParam.Merge(m, src)
}
func (m *FacetParam) XXX_Size() int {
	return m.Size()
}
func (m *FacetParam) XXX_DiscardUnknown() {
	xxx_messageInfo_FacetParam.DiscardUnknown(m)
}

var xxx_messageInfo_FacetParam proto.InternalMessageInfo

func (m *FacetParam) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *FacetParam) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

type FacetParams struct {
	AllKeys              bool          `protobuf:"varint,1,opt,name=all_keys,json=allKeys,proto3" json:"all_keys,omitempty"`
	Param                []*FacetParam `protobuf:"bytes,2,rep,name=param,proto3" json:"param,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *FacetParams) Reset()         { *m = FacetParams{} }
func (m *FacetParams) String() string { return proto.CompactTextString(m) }
func (*FacetParams) ProtoMessage()    {}
func (*FacetParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{27}
}
func (m *FacetParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FacetParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FacetParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FacetParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FacetParams.Merge(m, src)
}
func (m *FacetParams) XXX_Size() int {
	return m.Size()
}
func (m *FacetParams) XXX_DiscardUnknown() {
	xxx_messageInfo_FacetParams.DiscardUnknown(m)
}

var xxx_messageInfo_FacetParams proto.InternalMessageInfo

func (m *FacetParams) GetAllKeys() bool {
	if m != nil {
		return m.AllKeys
	}
	return false
}

func (m *FacetParams) GetParam() []*FacetParam {
	if m != nil {
		return m.Param
	}
	return nil
}

type Facets struct {
	Facets               []*api.Facet `protobuf:"bytes,1,rep,name=facets,proto3" json:"facets,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Facets) Reset()         { *m = Facets{} }
func (m *Facets) String() string { return proto.CompactTextString(m) }
func (*Facets) ProtoMessage()    {}
func (*Facets) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{28}
}
func (m *Facets) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Facets) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Facets.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Facets) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Facets.Merge(m, src)
}
func (m *Facets) XXX_Size() int {
	return m.Size()
}
func (m *Facets) XXX_DiscardUnknown() {
	xxx_messageInfo_Facets.DiscardUnknown(m)
}

var xxx_messageInfo_Facets proto.InternalMessageInfo

func (m *Facets) GetFacets() []*api.Facet {
	if m != nil {
		return m.Facets
	}
	return nil
}

type FacetsList struct {
	FacetsList           []*Facets `protobuf:"bytes,1,rep,name=facets_list,json=facetsList,proto3" json:"facets_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *FacetsList) Reset()         { *m = FacetsList{} }
func (m *FacetsList) String() string { return proto.CompactTextString(m) }
func (*FacetsList) ProtoMessage()    {}
func (*FacetsList) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{29}
}
func (m *FacetsList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FacetsList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FacetsList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FacetsList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FacetsList.Merge(m, src)
}
func (m *FacetsList) XXX_Size() int {
	return m.Size()
}
func (m *FacetsList) XXX_DiscardUnknown() {
	xxx_messageInfo_FacetsList.DiscardUnknown(m)
}

var xxx_messageInfo_FacetsList proto.InternalMessageInfo

func (m *FacetsList) GetFacetsList() []*Facets {
	if m != nil {
		return m.FacetsList
	}
	return nil
}

type Function struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Key                  string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Args                 []string `protobuf:"bytes,3,rep,name=args,proto3" json:"args,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Function) Reset()         { *m = Function{} }
func (m *Function) String() string { return proto.CompactTextString(m) }
func (*Function) ProtoMessage()    {}
func (*Function) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{30}
}
func (m *Function) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Function) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Function.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Function) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Function.Merge(m, src)
}
func (m *Function) XXX_Size() int {
	return m.Size()
}
func (m *Function) XXX_DiscardUnknown() {
	xxx_messageInfo_Function.DiscardUnknown(m)
}

var xxx_messageInfo_Function proto.InternalMessageInfo

func (m *Function) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Function) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Function) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

// Op and Children are internal nodes and Func on leaves.
type FilterTree struct {
	Op                   string        `protobuf:"bytes,1,opt,name=op,proto3" json:"op,omitempty"`
	Children             []*FilterTree `protobuf:"bytes,2,rep,name=children,proto3" json:"children,omitempty"`
	Func                 *Function     `protobuf:"bytes,3,opt,name=func,proto3" json:"func,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *FilterTree) Reset()         { *m = FilterTree{} }
func (m *FilterTree) String() string { return proto.CompactTextString(m) }
func (*FilterTree) ProtoMessage()    {}
func (*FilterTree) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{31}
}
func (m *FilterTree) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FilterTree) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FilterTree.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FilterTree) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FilterTree.Merge(m, src)
}
func (m *FilterTree) XXX_Size() int {
	return m.Size()
}
func (m *FilterTree) XXX_DiscardUnknown() {
	xxx_messageInfo_FilterTree.DiscardUnknown(m)
}

var xxx_messageInfo_FilterTree proto.InternalMessageInfo

func (m *FilterTree) GetOp() string {
	if m != nil {
		return m.Op
	}
	return ""
}

func (m *FilterTree) GetChildren() []*FilterTree {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *FilterTree) GetFunc() *Function {
	if m != nil {
		return m.Func
	}
	return nil
}

// Schema messages.
type SchemaRequest struct {
	GroupId    uint32   `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	Predicates []string `protobuf:"bytes,2,rep,name=predicates,proto3" json:"predicates,omitempty"`
	// fields can be on of type, index, reverse or tokenizer
	Fields               []string `protobuf:"bytes,3,rep,name=fields,proto3" json:"fields,omitempty"`
	Types                []string `protobuf:"bytes,4,rep,name=types,proto3" json:"types,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SchemaRequest) Reset()         { *m = SchemaRequest{} }
func (m *SchemaRequest) String() string { return proto.CompactTextString(m) }
func (*SchemaRequest) ProtoMessage()    {}
func (*SchemaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{32}
}
func (m *SchemaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchemaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchemaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaRequest.Merge(m, src)
}
func (m *SchemaRequest) XXX_Size() int {
	return m.Size()
}
func (m *SchemaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaRequest proto.InternalMessageInfo

func (m *SchemaRequest) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *SchemaRequest) GetPredicates() []string {
	if m != nil {
		return m.Predicates
	}
	return nil
}

func (m *SchemaRequest) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *SchemaRequest) GetTypes() []string {
	if m != nil {
		return m.Types
	}
	return nil
}

type SchemaResult struct {
	Schema               []*api.SchemaNode `protobuf:"bytes,1,rep,name=schema,proto3" json:"schema,omitempty"` // Deprecated: Do not use.
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SchemaResult) Reset()         { *m = SchemaResult{} }
func (m *SchemaResult) String() string { return proto.CompactTextString(m) }
func (*SchemaResult) ProtoMessage()    {}
func (*SchemaResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{33}
}
func (m *SchemaResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchemaResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchemaResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaResult.Merge(m, src)
}
func (m *SchemaResult) XXX_Size() int {
	return m.Size()
}
func (m *SchemaResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaResult.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaResult proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *SchemaResult) GetSchema() []*api.SchemaNode {
	if m != nil {
		return m.Schema
	}
	return nil
}

type SchemaUpdate struct {
	Predicate string                 `protobuf:"bytes,1,opt,name=predicate,proto3" json:"predicate,omitempty"`
	ValueType Posting_ValType        `protobuf:"varint,2,opt,name=value_type,json=valueType,proto3,enum=pb.Posting_ValType" json:"value_type,omitempty"`
	Directive SchemaUpdate_Directive `protobuf:"varint,3,opt,name=directive,proto3,enum=pb.SchemaUpdate_Directive" json:"directive,omitempty"`
	Tokenizer []string               `protobuf:"bytes,4,rep,name=tokenizer,proto3" json:"tokenizer,omitempty"`
	Count     bool                   `protobuf:"varint,5,opt,name=count,proto3" json:"count,omitempty"`
	List      bool                   `protobuf:"varint,6,opt,name=list,proto3" json:"list,omitempty"`
	Upsert    bool                   `protobuf:"varint,8,opt,name=upsert,proto3" json:"upsert,omitempty"`
	Lang      bool                   `protobuf:"varint,9,opt,name=lang,proto3" json:"lang,omitempty"`
	// Fields required for type system.
	NonNullable     bool `protobuf:"varint,10,opt,name=non_nullable,json=nonNullable,proto3" json:"non_nullable,omitempty"`
	NonNullableList bool `protobuf:"varint,11,opt,name=non_nullable_list,json=nonNullableList,proto3" json:"non_nullable_list,omitempty"`
	// If value_type is OBJECT, then this represents an object type with a
	// custom name. This field stores said name.
	ObjectTypeName       string   `protobuf:"bytes,12,opt,name=object_type_name,json=objectTypeName,proto3" json:"object_type_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SchemaUpdate) Reset()         { *m = SchemaUpdate{} }
func (m *SchemaUpdate) String() string { return proto.CompactTextString(m) }
func (*SchemaUpdate) ProtoMessage()    {}
func (*SchemaUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{34}
}
func (m *SchemaUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchemaUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchemaUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaUpdate.Merge(m, src)
}
func (m *SchemaUpdate) XXX_Size() int {
	return m.Size()
}
func (m *SchemaUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaUpdate proto.InternalMessageInfo

func (m *SchemaUpdate) GetPredicate() string {
	if m != nil {
		return m.Predicate
	}
	return ""
}

func (m *SchemaUpdate) GetValueType() Posting_ValType {
	if m != nil {
		return m.ValueType
	}
	return Posting_DEFAULT
}

func (m *SchemaUpdate) GetDirective() SchemaUpdate_Directive {
	if m != nil {
		return m.Directive
	}
	return SchemaUpdate_NONE
}

func (m *SchemaUpdate) GetTokenizer() []string {
	if m != nil {
		return m.Tokenizer
	}
	return nil
}

func (m *SchemaUpdate) GetCount() bool {
	if m != nil {
		return m.Count
	}
	return false
}

func (m *SchemaUpdate) GetList() bool {
	if m != nil {
		return m.List
	}
	return false
}

func (m *SchemaUpdate) GetUpsert() bool {
	if m != nil {
		return m.Upsert
	}
	return false
}

func (m *SchemaUpdate) GetLang() bool {
	if m != nil {
		return m.Lang
	}
	return false
}

func (m *SchemaUpdate) GetNonNullable() bool {
	if m != nil {
		return m.NonNullable
	}
	return false
}

func (m *SchemaUpdate) GetNonNullableList() bool {
	if m != nil {
		return m.NonNullableList
	}
	return false
}

func (m *SchemaUpdate) GetObjectTypeName() string {
	if m != nil {
		return m.ObjectTypeName
	}
	return ""
}

type TypeUpdate struct {
	TypeName             string          `protobuf:"bytes,1,opt,name=type_name,json=typeName,proto3" json:"type_name,omitempty"`
	Fields               []*SchemaUpdate `protobuf:"bytes,2,rep,name=fields,proto3" json:"fields,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *TypeUpdate) Reset()         { *m = TypeUpdate{} }
func (m *TypeUpdate) String() string { return proto.CompactTextString(m) }
func (*TypeUpdate) ProtoMessage()    {}
func (*TypeUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{35}
}
func (m *TypeUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypeUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TypeUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeUpdate.Merge(m, src)
}
func (m *TypeUpdate) XXX_Size() int {
	return m.Size()
}
func (m *TypeUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_TypeUpdate proto.InternalMessageInfo

func (m *TypeUpdate) GetTypeName() string {
	if m != nil {
		return m.TypeName
	}
	return ""
}

func (m *TypeUpdate) GetFields() []*SchemaUpdate {
	if m != nil {
		return m.Fields
	}
	return nil
}

// Bulk loader proto.
type MapEntry struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Only one should be set.
	Uid                  uint64   `protobuf:"fixed64,2,opt,name=uid,proto3" json:"uid,omitempty"`
	Posting              *Posting `protobuf:"bytes,3,opt,name=posting,proto3" json:"posting,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MapEntry) Reset()         { *m = MapEntry{} }
func (m *MapEntry) String() string { return proto.CompactTextString(m) }
func (*MapEntry) ProtoMessage()    {}
func (*MapEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{36}
}
func (m *MapEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MapEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MapEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MapEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MapEntry.Merge(m, src)
}
func (m *MapEntry) XXX_Size() int {
	return m.Size()
}
func (m *MapEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_MapEntry.DiscardUnknown(m)
}

var xxx_messageInfo_MapEntry proto.InternalMessageInfo

func (m *MapEntry) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *MapEntry) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *MapEntry) GetPosting() *Posting {
	if m != nil {
		return m.Posting
	}
	return nil
}

type MovePredicatePayload struct {
	Predicate            string   `protobuf:"bytes,1,opt,name=predicate,proto3" json:"predicate,omitempty"`
	SourceGid            uint32   `protobuf:"varint,2,opt,name=source_gid,json=sourceGid,proto3" json:"source_gid,omitempty"`
	DestGid              uint32   `protobuf:"varint,3,opt,name=dest_gid,json=destGid,proto3" json:"dest_gid,omitempty"`
	TxnTs                uint64   `protobuf:"varint,4,opt,name=txn_ts,json=txnTs,proto3" json:"txn_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MovePredicatePayload) Reset()         { *m = MovePredicatePayload{} }
func (m *MovePredicatePayload) String() string { return proto.CompactTextString(m) }
func (*MovePredicatePayload) ProtoMessage()    {}
func (*MovePredicatePayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{37}
}
func (m *MovePredicatePayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MovePredicatePayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MovePredicatePayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MovePredicatePayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MovePredicatePayload.Merge(m, src)
}
func (m *MovePredicatePayload) XXX_Size() int {
	return m.Size()
}
func (m *MovePredicatePayload) XXX_DiscardUnknown() {
	xxx_messageInfo_MovePredicatePayload.DiscardUnknown(m)
}

var xxx_messageInfo_MovePredicatePayload proto.InternalMessageInfo

func (m *MovePredicatePayload) GetPredicate() string {
	if m != nil {
		return m.Predicate
	}
	return ""
}

func (m *MovePredicatePayload) GetSourceGid() uint32 {
	if m != nil {
		return m.SourceGid
	}
	return 0
}

func (m *MovePredicatePayload) GetDestGid() uint32 {
	if m != nil {
		return m.DestGid
	}
	return 0
}

func (m *MovePredicatePayload) GetTxnTs() uint64 {
	if m != nil {
		return m.TxnTs
	}
	return 0
}

type TxnStatus struct {
	StartTs              uint64   `protobuf:"varint,1,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	CommitTs             uint64   `protobuf:"varint,2,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnStatus) Reset()         { *m = TxnStatus{} }
func (m *TxnStatus) String() string { return proto.CompactTextString(m) }
func (*TxnStatus) ProtoMessage()    {}
func (*TxnStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{38}
}
func (m *TxnStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnStatus.Merge(m, src)
}
func (m *TxnStatus) XXX_Size() int {
	return m.Size()
}
func (m *TxnStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnStatus.DiscardUnknown(m)
}

var xxx_messageInfo_TxnStatus proto.InternalMessageInfo

func (m *TxnStatus) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *TxnStatus) GetCommitTs() uint64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

type OracleDelta struct {
	Txns                 []*TxnStatus      `protobuf:"bytes,1,rep,name=txns,proto3" json:"txns,omitempty"`
	MaxAssigned          uint64            `protobuf:"varint,2,opt,name=max_assigned,json=maxAssigned,proto3" json:"max_assigned,omitempty"`
	GroupChecksums       map[uint32]uint64 `protobuf:"bytes,3,rep,name=group_checksums,json=groupChecksums,proto3" json:"group_checksums,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *OracleDelta) Reset()         { *m = OracleDelta{} }
func (m *OracleDelta) String() string { return proto.CompactTextString(m) }
func (*OracleDelta) ProtoMessage()    {}
func (*OracleDelta) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{39}
}
func (m *OracleDelta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleDelta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleDelta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleDelta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleDelta.Merge(m, src)
}
func (m *OracleDelta) XXX_Size() int {
	return m.Size()
}
func (m *OracleDelta) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleDelta.DiscardUnknown(m)
}

var xxx_messageInfo_OracleDelta proto.InternalMessageInfo

func (m *OracleDelta) GetTxns() []*TxnStatus {
	if m != nil {
		return m.Txns
	}
	return nil
}

func (m *OracleDelta) GetMaxAssigned() uint64 {
	if m != nil {
		return m.MaxAssigned
	}
	return 0
}

func (m *OracleDelta) GetGroupChecksums() map[uint32]uint64 {
	if m != nil {
		return m.GroupChecksums
	}
	return nil
}

type TxnTimestamps struct {
	Ts                   []uint64 `protobuf:"varint,1,rep,packed,name=ts,proto3" json:"ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnTimestamps) Reset()         { *m = TxnTimestamps{} }
func (m *TxnTimestamps) String() string { return proto.CompactTextString(m) }
func (*TxnTimestamps) ProtoMessage()    {}
func (*TxnTimestamps) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{40}
}
func (m *TxnTimestamps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnTimestamps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnTimestamps.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnTimestamps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnTimestamps.Merge(m, src)
}
func (m *TxnTimestamps) XXX_Size() int {
	return m.Size()
}
func (m *TxnTimestamps) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnTimestamps.DiscardUnknown(m)
}

var xxx_messageInfo_TxnTimestamps proto.InternalMessageInfo

func (m *TxnTimestamps) GetTs() []uint64 {
	if m != nil {
		return m.Ts
	}
	return nil
}

type PeerResponse struct {
	Status               bool     `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PeerResponse) Reset()         { *m = PeerResponse{} }
func (m *PeerResponse) String() string { return proto.CompactTextString(m) }
func (*PeerResponse) ProtoMessage()    {}
func (*PeerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{41}
}
func (m *PeerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerResponse.Merge(m, src)
}
func (m *PeerResponse) XXX_Size() int {
	return m.Size()
}
func (m *PeerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PeerResponse proto.InternalMessageInfo

func (m *PeerResponse) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type RaftBatch struct {
	Context              *RaftContext `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Payload              *api.Payload `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *RaftBatch) Reset()         { *m = RaftBatch{} }
func (m *RaftBatch) String() string { return proto.CompactTextString(m) }
func (*RaftBatch) ProtoMessage()    {}
func (*RaftBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{42}
}
func (m *RaftBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftBatch.Merge(m, src)
}
func (m *RaftBatch) XXX_Size() int {
	return m.Size()
}
func (m *RaftBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftBatch.DiscardUnknown(m)
}

var xxx_messageInfo_RaftBatch proto.InternalMessageInfo

func (m *RaftBatch) GetContext() *RaftContext {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *RaftBatch) GetPayload() *api.Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type Num struct {
	Val                  uint64   `protobuf:"varint,1,opt,name=val,proto3" json:"val,omitempty"`
	ReadOnly             bool     `protobuf:"varint,2,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Num) Reset()         { *m = Num{} }
func (m *Num) String() string { return proto.CompactTextString(m) }
func (*Num) ProtoMessage()    {}
func (*Num) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{43}
}
func (m *Num) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Num) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Num.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Num) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Num.Merge(m, src)
}
func (m *Num) XXX_Size() int {
	return m.Size()
}
func (m *Num) XXX_DiscardUnknown() {
	xxx_messageInfo_Num.DiscardUnknown(m)
}

var xxx_messageInfo_Num proto.InternalMessageInfo

func (m *Num) GetVal() uint64 {
	if m != nil {
		return m.Val
	}
	return 0
}

func (m *Num) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

type AssignedIds struct {
	StartId uint64 `protobuf:"varint,1,opt,name=startId,proto3" json:"startId,omitempty"`
	EndId   uint64 `protobuf:"varint,2,opt,name=endId,proto3" json:"endId,omitempty"`
	// The following is used for read only transactions.
	ReadOnly             uint64   `protobuf:"varint,5,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AssignedIds) Reset()         { *m = AssignedIds{} }
func (m *AssignedIds) String() string { return proto.CompactTextString(m) }
func (*AssignedIds) ProtoMessage()    {}
func (*AssignedIds) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{44}
}
func (m *AssignedIds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssignedIds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssignedIds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssignedIds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssignedIds.Merge(m, src)
}
func (m *AssignedIds) XXX_Size() int {
	return m.Size()
}
func (m *AssignedIds) XXX_DiscardUnknown() {
	xxx_messageInfo_AssignedIds.DiscardUnknown(m)
}

var xxx_messageInfo_AssignedIds proto.InternalMessageInfo

func (m *AssignedIds) GetStartId() uint64 {
	if m != nil {
		return m.StartId
	}
	return 0
}

func (m *AssignedIds) GetEndId() uint64 {
	if m != nil {
		return m.EndId
	}
	return 0
}

func (m *AssignedIds) GetReadOnly() uint64 {
	if m != nil {
		return m.ReadOnly
	}
	return 0
}

type SnapshotMeta struct {
	ClientTs             uint64   `protobuf:"varint,1,opt,name=client_ts,json=clientTs,proto3" json:"client_ts,omitempty"`
	GroupId              uint32   `protobuf:"varint,2,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SnapshotMeta) Reset()         { *m = SnapshotMeta{} }
func (m *SnapshotMeta) String() string { return proto.CompactTextString(m) }
func (*SnapshotMeta) ProtoMessage()    {}
func (*SnapshotMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{45}
}
func (m *SnapshotMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotMeta.Merge(m, src)
}
func (m *SnapshotMeta) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotMeta.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotMeta proto.InternalMessageInfo

func (m *SnapshotMeta) GetClientTs() uint64 {
	if m != nil {
		return m.ClientTs
	}
	return 0
}

func (m *SnapshotMeta) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

// Status describes a general status response.
// code: 0 = success, 0 != failure.
type Status struct {
	Code                 int32    `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Status) Reset()         { *m = Status{} }
func (m *Status) String() string { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()    {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{46}
}
func (m *Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(m, src)
}
func (m *Status) XXX_Size() int {
	return m.Size()
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

func (m *Status) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Status) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type BackupRequest struct {
	ReadTs               uint64   `protobuf:"varint,1,opt,name=read_ts,json=readTs,proto3" json:"read_ts,omitempty"`
	GroupId              uint32   `protobuf:"varint,2,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	UnixTs               string   `protobuf:"bytes,3,opt,name=unix_ts,json=unixTs,proto3" json:"unix_ts,omitempty"`
	Location             string   `protobuf:"bytes,4,opt,name=location,proto3" json:"location,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BackupRequest) Reset()         { *m = BackupRequest{} }
func (m *BackupRequest) String() string { return proto.CompactTextString(m) }
func (*BackupRequest) ProtoMessage()    {}
func (*BackupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{47}
}
func (m *BackupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupRequest.Merge(m, src)
}
func (m *BackupRequest) XXX_Size() int {
	return m.Size()
}
func (m *BackupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BackupRequest proto.InternalMessageInfo

func (m *BackupRequest) GetReadTs() uint64 {
	if m != nil {
		return m.ReadTs
	}
	return 0
}

func (m *BackupRequest) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *BackupRequest) GetUnixTs() string {
	if m != nil {
		return m.UnixTs
	}
	return ""
}

func (m *BackupRequest) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

type ExportRequest struct {
	GroupId              uint32   `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	ReadTs               uint64   `protobuf:"varint,2,opt,name=read_ts,json=readTs,proto3" json:"read_ts,omitempty"`
	UnixTs               int64    `protobuf:"varint,3,opt,name=unix_ts,json=unixTs,proto3" json:"unix_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExportRequest) Reset()         { *m = ExportRequest{} }
func (m *ExportRequest) String() string { return proto.CompactTextString(m) }
func (*ExportRequest) ProtoMessage()    {}
func (*ExportRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{48}
}
func (m *ExportRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExportRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExportRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportRequest.Merge(m, src)
}
func (m *ExportRequest) XXX_Size() int {
	return m.Size()
}
func (m *ExportRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExportRequest proto.InternalMessageInfo

func (m *ExportRequest) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *ExportRequest) GetReadTs() uint64 {
	if m != nil {
		return m.ReadTs
	}
	return 0
}

func (m *ExportRequest) GetUnixTs() int64 {
	if m != nil {
		return m.UnixTs
	}
	return 0
}

func init() {
	proto.RegisterEnum("pb.DirectedEdge_Op", DirectedEdge_Op_name, DirectedEdge_Op_value)
	proto.RegisterEnum("pb.Posting_ValType", Posting_ValType_name, Posting_ValType_value)
	proto.RegisterEnum("pb.Posting_PostingType", Posting_PostingType_name, Posting_PostingType_value)
	proto.RegisterEnum("pb.SchemaUpdate_Directive", SchemaUpdate_Directive_name, SchemaUpdate_Directive_value)
	proto.RegisterType((*List)(nil), "pb.List")
	proto.RegisterType((*TaskValue)(nil), "pb.TaskValue")
	proto.RegisterType((*SrcFunction)(nil), "pb.SrcFunction")
	proto.RegisterType((*Query)(nil), "pb.Query")
	proto.RegisterType((*ValueList)(nil), "pb.ValueList")
	proto.RegisterType((*LangList)(nil), "pb.LangList")
	proto.RegisterType((*Result)(nil), "pb.Result")
	proto.RegisterType((*Order)(nil), "pb.Order")
	proto.RegisterType((*SortMessage)(nil), "pb.SortMessage")
	proto.RegisterType((*SortResult)(nil), "pb.SortResult")
	proto.RegisterType((*RaftContext)(nil), "pb.RaftContext")
	proto.RegisterType((*Member)(nil), "pb.Member")
	proto.RegisterType((*Group)(nil), "pb.Group")
	proto.RegisterMapType((map[uint64]*Member)(nil), "pb.Group.MembersEntry")
	proto.RegisterMapType((map[string]*Tablet)(nil), "pb.Group.TabletsEntry")
	proto.RegisterType((*ZeroProposal)(nil), "pb.ZeroProposal")
	proto.RegisterMapType((map[uint32]uint64)(nil), "pb.ZeroProposal.SnapshotTsEntry")
	proto.RegisterType((*MembershipState)(nil), "pb.MembershipState")
	proto.RegisterMapType((map[uint32]*Group)(nil), "pb.MembershipState.GroupsEntry")
	proto.RegisterMapType((map[uint64]*Member)(nil), "pb.MembershipState.ZerosEntry")
	proto.RegisterType((*ConnectionState)(nil), "pb.ConnectionState")
	proto.RegisterType((*Tablet)(nil), "pb.Tablet")
	proto.RegisterType((*DirectedEdge)(nil), "pb.DirectedEdge")
	proto.RegisterType((*Mutations)(nil), "pb.Mutations")
	proto.RegisterType((*Snapshot)(nil), "pb.Snapshot")
	proto.RegisterType((*Proposal)(nil), "pb.Proposal")
	proto.RegisterType((*KVS)(nil), "pb.KVS")
	proto.RegisterType((*Posting)(nil), "pb.Posting")
	proto.RegisterType((*UidBlock)(nil), "pb.UidBlock")
	proto.RegisterType((*UidPack)(nil), "pb.UidPack")
	proto.RegisterType((*PostingList)(nil), "pb.PostingList")
	proto.RegisterType((*FacetParam)(nil), "pb.FacetParam")
	proto.RegisterType((*FacetParams)(nil), "pb.FacetParams")
	proto.RegisterType((*Facets)(nil), "pb.Facets")
	proto.RegisterType((*FacetsList)(nil), "pb.FacetsList")
	proto.RegisterType((*Function)(nil), "pb.Function")
	proto.RegisterType((*FilterTree)(nil), "pb.FilterTree")
	proto.RegisterType((*SchemaRequest)(nil), "pb.SchemaRequest")
	proto.RegisterType((*SchemaResult)(nil), "pb.SchemaResult")
	proto.RegisterType((*SchemaUpdate)(nil), "pb.SchemaUpdate")
	proto.RegisterType((*TypeUpdate)(nil), "pb.TypeUpdate")
	proto.RegisterType((*MapEntry)(nil), "pb.MapEntry")
	proto.RegisterType((*MovePredicatePayload)(nil), "pb.MovePredicatePayload")
	proto.RegisterType((*TxnStatus)(nil), "pb.TxnStatus")
	proto.RegisterType((*OracleDelta)(nil), "pb.OracleDelta")
	proto.RegisterMapType((map[uint32]uint64)(nil), "pb.OracleDelta.GroupChecksumsEntry")
	proto.RegisterType((*TxnTimestamps)(nil), "pb.TxnTimestamps")
	proto.RegisterType((*PeerResponse)(nil), "pb.PeerResponse")
	proto.RegisterType((*RaftBatch)(nil), "pb.RaftBatch")
	proto.RegisterType((*Num)(nil), "pb.Num")
	proto.RegisterType((*AssignedIds)(nil), "pb.AssignedIds")
	proto.RegisterType((*SnapshotMeta)(nil), "pb.SnapshotMeta")
	proto.RegisterType((*Status)(nil), "pb.Status")
	proto.RegisterType((*BackupRequest)(nil), "pb.BackupRequest")
	proto.RegisterType((*ExportRequest)(nil), "pb.ExportRequest")
}

func init() { proto.RegisterFile("pb.proto", fileDescriptor_f80abaa17e25ccc8) }

var fileDescriptor_f80abaa17e25ccc8 = []byte{
	// 3342 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x39, 0xcb, 0x72, 0x24, 0x57,
	0x56, 0x9d, 0xf5, 0xc8, 0xca, 0x3c, 0x55, 0x52, 0x97, 0xaf, 0x3d, 0xed, 0xb2, 0x3c, 0xd3, 0x2d,
	0xa7, 0x1f, 0x2d, 0xb7, 0x6d, 0x75, 0x5b, 0x36, 0x30, 0x1e, 0x82, 0x85, 0x5a, 0xaa, 0x6e, 0x64,
	0xeb, 0xc5, 0xad, 0x52, 0x0f, 0x38, 0x08, 0x2a, 0xae, 0x32, 0xaf, 0x4a, 0x39, 0xca, 0xca, 0x4c,
	0xf2, 0x66, 0x29, 0x4a, 0xde, 0xb1, 0x80, 0x80, 0x3f, 0x98, 0x05, 0xc1, 0x8e, 0x0d, 0x1b, 0xb6,
	0xb3, 0x64, 0x43, 0x04, 0x4b, 0x82, 0x2f, 0x20, 0x0c, 0xdf, 0x40, 0x04, 0x3b, 0xe2, 0x9c, 0x7b,
	0xf3, 0x51, 0xd5, 0xea, 0xf6, 0x98, 0x88, 0x59, 0x55, 0x9e, 0xc7, 0x7d, 0x9d, 0xf7, 0x39, 0x05,
	0x4e, 0x7a, 0xbe, 0x9d, 0x66, 0x49, 0x9e, 0xb0, 0x46, 0x7a, 0xbe, 0xe1, 0x8a, 0x34, 0xd4, 0xe0,
	0xc6, 0xc3, 0x69, 0x98, 0x5f, 0xce, 0xcf, 0xb7, 0xfd, 0x64, 0xf6, 0x38, 0x98, 0x66, 0x22, 0xbd,
	0xfc, 0x2c, 0x4c, 0x1e, 0x9f, 0x8b, 0x60, 0x2a, 0xb3, 0xc7, 0xe9, 0xf9, 0xe3, 0x62, 0x9d, 0xb7,
	0x01, 0xad, 0xc3, 0x50, 0xe5, 0x8c, 0x41, 0x6b, 0x1e, 0x06, 0x6a, 0x60, 0x6d, 0x36, 0xb7, 0x6c,
	0x4e, 0xdf, 0xde, 0x11, 0xb8, 0x63, 0xa1, 0xae, 0x5e, 0x88, 0x68, 0x2e, 0x59, 0x1f, 0x9a, 0xd7,
	0x22, 0x1a, 0x58, 0x9b, 0xd6, 0x56, 0x8f, 0xe3, 0x27, 0xdb, 0x06, 0xe7, 0x5a, 0x44, 0x93, 0xfc,
	0x26, 0x95, 0x83, 0xc6, 0xa6, 0xb5, 0xb5, 0xbe, 0xf3, 0xe6, 0x76, 0x7a, 0xbe, 0x7d, 0x9a, 0xa8,
	0x3c, 0x8c, 0xa7, 0xdb, 0x2f, 0x44, 0x34, 0xbe, 0x49, 0x25, 0xef, 0x5c, 0xeb, 0x0f, 0xef, 0x04,
	0xba, 0xa3, 0xcc, 0x7f, 0x36, 0x8f, 0xfd, 0x3c, 0x4c, 0x62, 0x3c, 0x31, 0x16, 0x33, 0x49, 0x3b,
	0xba, 0x9c, 0xbe, 0x11, 0x27, 0xb2, 0xa9, 0x1a, 0x34, 0x37, 0x9b, 0x88, 0xc3, 0x6f, 0x36, 0x80,
	0x4e, 0xa8, 0xf6, 0x92, 0x79, 0x9c, 0x0f, 0x5a, 0x9b, 0xd6, 0x96, 0xc3, 0x0b, 0xd0, 0xfb, 0xbb,
	0x26, 0xb4, 0xff, 0x64, 0x2e, 0xb3, 0x1b, 0x5a, 0x97, 0xe7, 0x59, 0xb1, 0x17, 0x7e, 0xb3, 0xb7,
	0xa0, 0x1d, 0x89, 0x78, 0xaa, 0x06, 0x0d, 0xda, 0x4c, 0x03, 0xec, 0x5d, 0x70, 0xc5, 0x45, 0x2e,
	0xb3, 0xc9, 0x3c, 0x0c, 0x06, 0xcd, 0x4d, 0x6b, 0xcb, 0xe6, 0x0e, 0x21, 0xce, 0xc2, 0x80, 0xbd,
	0x03, 0x4e, 0x90, 0x4c, 0xfc, 0xfa, 0x59, 0x41, 0x42, 0x67, 0xb1, 0xf7, 0xc1, 0x99, 0x87, 0xc1,
	0x24, 0x0a, 0x55, 0x3e, 0x68, 0x6f, 0x5a, 0x5b, 0xdd, 0x1d, 0x07, 0x1f, 0x8b, 0xb2, 0xe3, 0x9d,
	0x79, 0x18, 0x90, 0x10, 0x1f, 0x81, 0xa3, 0x32, 0x7f, 0x72, 0x31, 0x8f, 0xfd, 0x81, 0x4d, 0x4c,
	0x77, 0x91, 0xa9, 0xf6, 0x6a, 0xde, 0x51, 0x1a, 0xc0, 0x67, 0x65, 0xf2, 0x5a, 0x66, 0x4a, 0x0e,
	0x3a, 0xfa, 0x28, 0x03, 0xb2, 0x27, 0xd0, 0xbd, 0x10, 0xbe, 0xcc, 0x27, 0xa9, 0xc8, 0xc4, 0x6c,
	0xe0, 0x54, 0x1b, 0x3d, 0x43, 0xf4, 0x29, 0x62, 0x15, 0x87, 0x8b, 0x12, 0x60, 0x5f, 0xc0, 0x1a,
	0x41, 0x6a, 0x72, 0x11, 0x46, 0xb9, 0xcc, 0x06, 0x2e, 0xad, 0x59, 0xa7, 0x35, 0x84, 0x19, 0x67,
	0x52, 0xf2, 0x9e, 0x66, 0xd2, 0x18, 0xf6, 0x33, 0x00, 0xb9, 0x48, 0x45, 0x1c, 0x4c, 0x44, 0x14,
	0x0d, 0x80, 0xee, 0xe0, 0x6a, 0xcc, 0x6e, 0x14, 0xb1, 0xb7, 0xf1, 0x7e, 0x22, 0x98, 0xe4, 0x6a,
	0xb0, 0xb6, 0x69, 0x6d, 0xb5, 0xb8, 0x8d, 0xe0, 0x58, 0xa1, 0x5c, 0x7d, 0xe1, 0x5f, 0xca, 0xc1,
	0xfa, 0xa6, 0xb5, 0xd5, 0xe6, 0x1a, 0xf0, 0x76, 0xc0, 0x25, 0x3b, 0x21, 0x39, 0x7c, 0x08, 0xf6,
	0x35, 0x02, 0xda, 0x9c, 0xba, 0x3b, 0x6b, 0x78, 0x91, 0xd2, 0x94, 0xb8, 0x21, 0x7a, 0xf7, 0xc1,
	0x39, 0x14, 0xf1, 0xb4, 0xb0, 0x3f, 0x54, 0x10, 0x2d, 0x70, 0x39, 0x7d, 0x7b, 0xbf, 0x6e, 0x80,
	0xcd, 0xa5, 0x9a, 0x47, 0x39, 0x7b, 0x08, 0x80, 0xe2, 0x9f, 0x89, 0x3c, 0x0b, 0x17, 0x66, 0xd7,
	0x4a, 0x01, 0xee, 0x3c, 0x0c, 0x8e, 0x88, 0xc4, 0x9e, 0x40, 0x8f, 0x76, 0x2f, 0x58, 0x1b, 0xd5,
	0x05, 0xca, 0xfb, 0xf1, 0x2e, 0xb1, 0x98, 0x15, 0xf7, 0xc0, 0x26, 0x8d, 0x6b, 0xab, 0x5b, 0xe3,
	0x06, 0x62, 0x1f, 0xc2, 0x7a, 0x18, 0xe7, 0xa8, 0x11, 0x3f, 0x9f, 0x04, 0x52, 0x15, 0x26, 0xb1,
	0x56, 0x62, 0xf7, 0xa5, 0xca, 0xd9, 0xe7, 0xa0, 0xc5, 0x5a, 0x1c, 0xd8, 0xa6, 0x03, 0xd7, 0x4b,
	0x75, 0x29, 0x7d, 0x22, 0xf1, 0x98, 0x13, 0x3f, 0x83, 0x2e, 0xbe, 0xaf, 0x58, 0x61, 0xd3, 0x8a,
	0x1e, 0xbd, 0xc6, 0x88, 0x83, 0x03, 0x32, 0x18, 0x76, 0x14, 0x0d, 0x9a, 0x9d, 0x36, 0x13, 0xfa,
	0xf6, 0x86, 0xd0, 0x3e, 0xc9, 0x02, 0x99, 0xdd, 0x6a, 0xf9, 0x0c, 0x5a, 0x81, 0x54, 0x3e, 0x39,
	0xa5, 0xc3, 0xe9, 0xbb, 0xf2, 0x86, 0x66, 0xcd, 0x1b, 0xbc, 0x7f, 0xb0, 0xa0, 0x3b, 0x4a, 0xb2,
	0xfc, 0x48, 0x2a, 0x25, 0xa6, 0x92, 0x3d, 0x80, 0x76, 0x82, 0xdb, 0x1a, 0x09, 0xbb, 0x78, 0x27,
	0x3a, 0x87, 0x6b, 0xfc, 0x8a, 0x1e, 0x1a, 0xaf, 0xd6, 0x03, 0x5a, 0x09, 0xf9, 0x51, 0xd3, 0x58,
	0x09, 0x79, 0xd1, 0x3d, 0xb0, 0x93, 0x8b, 0x0b, 0x25, 0xb5, 0x2c, 0xdb, 0xdc, 0x40, 0xaf, 0x34,
	0x36, 0xef, 0xf7, 0x00, 0xf0, 0x7e, 0x3f, 0xd2, 0x0a, 0xbc, 0x4b, 0xe8, 0x72, 0x71, 0x91, 0xef,
	0x25, 0x71, 0x2e, 0x17, 0x39, 0x5b, 0x87, 0x46, 0x18, 0x90, 0x88, 0x6c, 0xde, 0x08, 0x03, 0xbc,
	0xdc, 0x34, 0x4b, 0xe6, 0x29, 0x49, 0x68, 0x8d, 0x6b, 0x80, 0x44, 0x19, 0x04, 0x19, 0xdd, 0x18,
	0x45, 0x19, 0x04, 0x19, 0x7b, 0x00, 0x5d, 0x15, 0x8b, 0x54, 0x5d, 0x26, 0x39, 0x5e, 0xae, 0x45,
	0x97, 0x83, 0x02, 0x35, 0x56, 0xde, 0xbf, 0x5a, 0x60, 0x1f, 0xc9, 0xd9, 0xb9, 0xcc, 0x5e, 0x3a,
	0xe5, 0x1d, 0x70, 0x68, 0xe3, 0x49, 0x18, 0x98, 0x83, 0x3a, 0x04, 0x1f, 0x04, 0xb7, 0x1e, 0x75,
	0x0f, 0xec, 0x48, 0x0a, 0x14, 0xbe, 0xb6, 0x33, 0x03, 0xa1, 0x6c, 0xc4, 0x6c, 0x12, 0x48, 0x11,
	0x50, 0xe0, 0x71, 0xb8, 0x2d, 0x66, 0xfb, 0x52, 0x04, 0x78, 0xb7, 0x48, 0xa8, 0x7c, 0x32, 0x4f,
	0x03, 0x91, 0x4b, 0x0a, 0x38, 0x2d, 0x34, 0x1c, 0x95, 0x9f, 0x11, 0x86, 0x3d, 0x82, 0x37, 0xfc,
	0x68, 0xae, 0x30, 0xda, 0x85, 0xf1, 0x45, 0x32, 0x49, 0xe2, 0xe8, 0x86, 0xe4, 0xeb, 0xf0, 0xbb,
	0x86, 0x70, 0x10, 0x5f, 0x24, 0x27, 0x71, 0x74, 0xe3, 0xfd, 0xa6, 0x01, 0xed, 0xe7, 0x24, 0x86,
	0x27, 0xd0, 0x99, 0xd1, 0x83, 0x0a, 0xef, 0xbd, 0x87, 0x12, 0x26, 0xda, 0xb6, 0x7e, 0xa9, 0x1a,
	0xc6, 0x79, 0x76, 0xc3, 0x0b, 0x36, 0x5c, 0x91, 0x8b, 0xf3, 0x48, 0xe6, 0xca, 0x58, 0x44, 0x6d,
	0xc5, 0x58, 0x13, 0xcc, 0x0a, 0xc3, 0xb6, 0x2a, 0xd6, 0xe6, 0xaa, 0x58, 0xd9, 0x06, 0x38, 0xfe,
	0xa5, 0xf4, 0xaf, 0xd4, 0x7c, 0x66, 0x84, 0x5e, 0xc2, 0x1b, 0xcf, 0xa0, 0x57, 0xbf, 0x07, 0x66,
	0xa6, 0x2b, 0x79, 0x43, 0x82, 0x6f, 0x71, 0xfc, 0x64, 0x9b, 0xd0, 0x26, 0x0f, 0x27, 0xb1, 0x77,
	0x77, 0x00, 0xaf, 0xa3, 0x97, 0x70, 0x4d, 0xf8, 0x45, 0xe3, 0xe7, 0x16, 0xee, 0x53, 0xbf, 0x5d,
	0x7d, 0x1f, 0xf7, 0xd5, 0xfb, 0xe8, 0x25, 0xb5, 0x7d, 0xbc, 0xff, 0x6d, 0x40, 0xef, 0x5b, 0x99,
	0x25, 0xa7, 0x59, 0x92, 0x26, 0x4a, 0x44, 0x6c, 0x77, 0xf9, 0x75, 0x5a, 0x8a, 0x9b, 0xb8, 0xb8,
	0xce, 0xb6, 0x3d, 0x2a, 0x9f, 0xab, 0xa5, 0x53, 0x7f, 0xbf, 0x07, 0xb6, 0x96, 0xee, 0x2d, 0x4f,
	0x30, 0x14, 0xe4, 0xd1, 0xf2, 0x24, 0xf9, 0x2d, 0x5f, 0xcf, 0x50, 0xd8, 0x7d, 0x80, 0x99, 0x58,
	0x1c, 0x4a, 0xa1, 0xe4, 0x41, 0x50, 0x98, 0x6f, 0x85, 0x41, 0x39, 0xcf, 0xc4, 0x62, 0xbc, 0x88,
	0xc7, 0x8a, 0xac, 0xab, 0xc5, 0x4b, 0x98, 0xfd, 0x14, 0xdc, 0x99, 0x58, 0xa0, 0x1f, 0x1d, 0x04,
	0xc6, 0xba, 0x2a, 0x04, 0x7b, 0x0f, 0x9a, 0xf9, 0x22, 0xa6, 0xa0, 0x84, 0xd9, 0x09, 0x4b, 0x8f,
	0xf1, 0x22, 0x36, 0x1e, 0xc7, 0x91, 0x56, 0x08, 0xd4, 0xa9, 0x04, 0xda, 0x87, 0xa6, 0x1f, 0x06,
	0x94, 0x9e, 0x5c, 0x8e, 0x9f, 0x1b, 0x7f, 0x04, 0x77, 0x57, 0xe4, 0x50, 0xd7, 0xc3, 0x9a, 0x5e,
	0xf6, 0x56, 0x5d, 0x0f, 0xad, 0xba, 0xec, 0x7f, 0xd3, 0x84, 0xbb, 0xc6, 0x18, 0x2e, 0xc3, 0x74,
	0x94, 0xa3, 0xd9, 0x0f, 0xa0, 0x43, 0xd1, 0x46, 0x66, 0xc6, 0x26, 0x0a, 0x90, 0xfd, 0x01, 0xd8,
	0xe4, 0x81, 0x85, 0x9d, 0x3e, 0xa8, 0xa4, 0x5a, 0x2e, 0xd7, 0x76, 0x6b, 0x54, 0x62, 0xd8, 0xd9,
	0x97, 0xd0, 0xfe, 0x4e, 0x66, 0x89, 0x8e, 0x9e, 0xdd, 0x9d, 0xfb, 0xb7, 0xad, 0x43, 0xdd, 0x9a,
	0x65, 0x9a, 0xf9, 0x77, 0x28, 0xfc, 0x0f, 0x30, 0x5e, 0xce, 0x92, 0x6b, 0x19, 0x0c, 0x3a, 0x74,
	0xa3, 0xba, 0x7d, 0x14, 0xa4, 0x42, 0xda, 0x4e, 0x25, 0xed, 0x7d, 0xe8, 0xd6, 0x9e, 0x77, 0x8b,
	0xa4, 0x1f, 0x2c, 0x5b, 0xbc, 0x5b, 0x3a, 0x72, 0xdd, 0x71, 0xf6, 0x01, 0xaa, 0xc7, 0xfe, 0x7f,
	0xdd, 0xcf, 0xfb, 0x2b, 0x0b, 0xee, 0xee, 0x25, 0x71, 0x2c, 0xa9, 0x30, 0xd2, 0xaa, 0xab, 0xcc,
	0xde, 0x7a, 0xa5, 0xd9, 0x7f, 0x0c, 0x6d, 0x85, 0xcc, 0x66, 0xf7, 0x37, 0x6f, 0xd1, 0x05, 0xd7,
	0x1c, 0x18, 0x66, 0x66, 0x62, 0x31, 0x49, 0x65, 0x1c, 0x84, 0xf1, 0xb4, 0x08, 0x33, 0x33, 0xb1,
	0x38, 0xd5, 0x18, 0xef, 0xaf, 0x2d, 0xb0, 0xb5, 0xc7, 0x2c, 0x45, 0x6b, 0x6b, 0x39, 0x5a, 0xff,
	0x14, 0xdc, 0x34, 0x93, 0x41, 0xe8, 0x17, 0xa7, 0xba, 0xbc, 0x42, 0xa0, 0x71, 0x5e, 0x24, 0x99,
	0x2f, 0x69, 0x7b, 0x87, 0x6b, 0x00, 0xb1, 0x2a, 0x15, 0xbe, 0x2e, 0xee, 0x9a, 0x5c, 0x03, 0x18,
	0xe3, 0xb5, 0x72, 0x48, 0x29, 0x0e, 0x37, 0x90, 0xf7, 0x4f, 0x0d, 0xe8, 0xed, 0x87, 0x99, 0xf4,
	0x73, 0x19, 0x0c, 0x83, 0x29, 0x31, 0xca, 0x38, 0x0f, 0xf3, 0x1b, 0x93, 0x4f, 0x0c, 0x54, 0xa6,
	0xfb, 0xc6, 0x72, 0xa1, 0xab, 0xc5, 0xdd, 0xa4, 0xda, 0x5c, 0x03, 0x6c, 0x07, 0x40, 0x17, 0x42,
	0x54, 0x9f, 0xb7, 0x5e, 0x5d, 0x9f, 0xbb, 0xc4, 0x86, 0x9f, 0x28, 0x03, 0xbd, 0x26, 0xd4, 0xb9,
	0xc6, 0xa6, 0xe2, 0x7d, 0x8e, 0xb6, 0x4a, 0xf5, 0xc3, 0xb9, 0x8c, 0xc8, 0x16, 0xa9, 0x7e, 0x38,
	0x97, 0x51, 0x59, 0xb5, 0x75, 0xf4, 0x75, 0xf0, 0x9b, 0xbd, 0x0f, 0x8d, 0x24, 0xa5, 0xf7, 0x99,
	0x03, 0xeb, 0x0f, 0xdb, 0x3e, 0x49, 0x79, 0x23, 0x49, 0x51, 0xd1, 0xba, 0x18, 0x1d, 0xb8, 0xc6,
	0x7e, 0x31, 0x80, 0x50, 0xc1, 0xc4, 0x0d, 0xc5, 0xbb, 0x07, 0x8d, 0x93, 0x94, 0x75, 0xa0, 0x39,
	0x1a, 0x8e, 0xfb, 0x77, 0xf0, 0x63, 0x7f, 0x78, 0xd8, 0xb7, 0xbc, 0xbf, 0x6d, 0x80, 0x7b, 0x34,
	0xcf, 0x05, 0x9a, 0x8d, 0x7a, 0x9d, 0xde, 0xde, 0x01, 0x47, 0xe5, 0x22, 0xa3, 0x20, 0xac, 0x23,
	0x47, 0x87, 0xe0, 0xb1, 0x62, 0x1f, 0x41, 0x5b, 0x06, 0x53, 0x59, 0x38, 0x74, 0x7f, 0xf5, 0x9e,
	0x5c, 0x93, 0xd9, 0x16, 0xd8, 0xca, 0xbf, 0x94, 0x33, 0x31, 0x68, 0x55, 0x8c, 0x23, 0xc2, 0xe8,
	0x24, 0xcb, 0x0d, 0x9d, 0x7a, 0x87, 0x2c, 0x49, 0xa9, 0x98, 0x6e, 0x9b, 0xde, 0x21, 0x4b, 0x52,
	0x2c, 0xa5, 0x77, 0xe0, 0x27, 0xe1, 0x34, 0x4e, 0x32, 0x39, 0x09, 0xe3, 0x40, 0x2e, 0x26, 0x7e,
	0x12, 0x5f, 0x44, 0xa1, 0x9f, 0x93, 0x2c, 0x1d, 0xfe, 0xa6, 0x26, 0x1e, 0x20, 0x6d, 0xcf, 0x90,
	0xd8, 0x07, 0xd0, 0x46, 0xc5, 0x29, 0xe3, 0xdf, 0x54, 0x4f, 0xa2, 0x8e, 0xcc, 0xa9, 0x9a, 0xe8,
	0x2d, 0xc0, 0x29, 0xa2, 0x27, 0xfb, 0x18, 0xc3, 0x1e, 0x45, 0x5f, 0xe3, 0x3c, 0xd4, 0x32, 0xd4,
	0xca, 0x20, 0x5e, 0xd0, 0x51, 0x99, 0x74, 0x93, 0x22, 0x9e, 0x12, 0x50, 0x2f, 0xc2, 0x9a, 0x4b,
	0x15, 0x3f, 0xd6, 0x93, 0x49, 0x2c, 0x4d, 0x5d, 0x42, 0xdf, 0xde, 0xdf, 0x37, 0xc0, 0x29, 0x13,
	0xde, 0x27, 0xe0, 0xce, 0x0a, 0x85, 0x18, 0xb7, 0xa4, 0x8a, 0xbb, 0xd4, 0x12, 0xaf, 0xe8, 0xec,
	0x1e, 0x34, 0xae, 0xae, 0x8d, 0x38, 0x6d, 0xe4, 0xfa, 0xe6, 0x05, 0x6f, 0x5c, 0x5d, 0x57, 0x7e,
	0xdd, 0xfe, 0x41, 0xbf, 0x7e, 0x08, 0x77, 0xfd, 0x48, 0x8a, 0x78, 0x52, 0xb9, 0xa5, 0x36, 0xcb,
	0x75, 0x42, 0x9f, 0x96, 0xbe, 0x69, 0x62, 0x53, 0xa7, 0xca, 0x40, 0x1f, 0x42, 0x3b, 0x90, 0x51,
	0x2e, 0xea, 0x6d, 0xd5, 0x49, 0x26, 0xfc, 0x48, 0xee, 0x23, 0x9a, 0x6b, 0x2a, 0xdb, 0x02, 0xa7,
	0xc8, 0xc6, 0xa6, 0x99, 0xa2, 0xfa, 0xbc, 0x10, 0x36, 0x2f, 0xa9, 0x95, 0x2c, 0xa1, 0x26, 0x4b,
	0xef, 0x73, 0x68, 0x7e, 0xf3, 0x62, 0x64, 0xde, 0x6a, 0xbd, 0xf4, 0xd6, 0x42, 0xa2, 0x8d, 0x9a,
	0x44, 0xff, 0xa7, 0x09, 0x1d, 0xe3, 0x9b, 0x78, 0xef, 0x79, 0x59, 0x4b, 0xe2, 0xe7, 0x72, 0x0a,
	0x2c, 0x9d, 0xbc, 0xde, 0x82, 0x37, 0x7f, 0xb8, 0x05, 0x67, 0xbf, 0x80, 0x5e, 0xaa, 0x69, 0xf5,
	0xb0, 0xf0, 0x76, 0x7d, 0x8d, 0xf9, 0xa5, 0x75, 0xdd, 0xb4, 0x02, 0xd0, 0xc0, 0xa9, 0x6b, 0xc9,
	0xc5, 0x94, 0x54, 0xd4, 0xe3, 0x1d, 0x84, 0xc7, 0x62, 0xfa, 0x8a, 0xe0, 0xf0, 0x5b, 0xf8, 0x38,
	0xd6, 0xcc, 0x49, 0x3a, 0xe8, 0x91, 0xdf, 0x62, 0x5c, 0xa8, 0xbb, 0xec, 0xda, 0xb2, 0xcb, 0xbe,
	0x0b, 0xae, 0x9f, 0xcc, 0x66, 0x21, 0xd1, 0xd6, 0x4d, 0x4d, 0x48, 0x88, 0xb1, 0xf2, 0xfe, 0xc6,
	0x82, 0x8e, 0x79, 0x2d, 0xeb, 0x42, 0x67, 0x7f, 0xf8, 0x6c, 0xf7, 0xec, 0x10, 0xa3, 0x06, 0x80,
	0xfd, 0xf4, 0xe0, 0x78, 0x97, 0xff, 0x59, 0xdf, 0xc2, 0x08, 0x72, 0x70, 0x3c, 0xee, 0x37, 0x98,
	0x0b, 0xed, 0x67, 0x87, 0x27, 0xbb, 0xe3, 0x7e, 0x93, 0x39, 0xd0, 0x7a, 0x7a, 0x72, 0x72, 0xd8,
	0x6f, 0xb1, 0x1e, 0x38, 0xfb, 0xbb, 0xe3, 0xe1, 0xf8, 0xe0, 0x68, 0xd8, 0x6f, 0x23, 0xef, 0xf3,
	0xe1, 0x49, 0xdf, 0xc6, 0x8f, 0xb3, 0x83, 0xfd, 0x7e, 0x07, 0xe9, 0xa7, 0xbb, 0xa3, 0xd1, 0x2f,
	0x4f, 0xf8, 0x7e, 0xdf, 0xc1, 0x7d, 0x47, 0x63, 0x7e, 0x70, 0xfc, 0xbc, 0xef, 0xe2, 0xf7, 0xc9,
	0xd3, 0xaf, 0x87, 0x7b, 0xe3, 0x3e, 0x78, 0x9f, 0x43, 0xb7, 0x26, 0x41, 0x5c, 0xcd, 0x87, 0xcf,
	0xfa, 0x77, 0xf0, 0xc8, 0x17, 0xbb, 0x87, 0x67, 0xc3, 0xbe, 0xc5, 0xd6, 0x01, 0xe8, 0x73, 0x72,
	0xb8, 0x7b, 0xfc, 0xbc, 0xdf, 0xf0, 0x7e, 0x1f, 0x9c, 0xb3, 0x30, 0x78, 0x1a, 0x25, 0xfe, 0x15,
	0x1a, 0xc6, 0xb9, 0x50, 0xd2, 0x64, 0x53, 0xfa, 0xc6, 0x5c, 0x40, 0x46, 0xa9, 0x8c, 0xee, 0x0d,
	0xe4, 0x1d, 0x43, 0xe7, 0x2c, 0x0c, 0x4e, 0x85, 0x7f, 0x85, 0xbd, 0xfc, 0x39, 0xae, 0x9f, 0xa8,
	0xf0, 0x3b, 0x69, 0xc2, 0xa0, 0x4b, 0x98, 0x51, 0xf8, 0x9d, 0x64, 0x1f, 0x80, 0x4d, 0x40, 0x51,
	0xf7, 0x90, 0x2d, 0x17, 0x67, 0x72, 0x43, 0xf3, 0xf2, 0xf2, 0xea, 0xd4, 0x91, 0x3f, 0x80, 0x56,
	0x2a, 0xfc, 0x2b, 0x13, 0x4c, 0xba, 0x66, 0x09, 0x1e, 0xc7, 0x89, 0xc0, 0x1e, 0x82, 0x63, 0xec,
	0xa3, 0xd8, 0xb7, 0x5b, 0x33, 0x24, 0x5e, 0x12, 0x97, 0x35, 0xd7, 0x5c, 0xd1, 0xdc, 0x97, 0x00,
	0xd5, 0x58, 0xe3, 0x96, 0x1a, 0xfc, 0x2d, 0x68, 0x8b, 0x28, 0x34, 0x8f, 0x77, 0xb9, 0x06, 0xbc,
	0x63, 0xe8, 0xd6, 0x86, 0x21, 0x68, 0x36, 0x22, 0x8a, 0x26, 0x57, 0xf2, 0x46, 0xd1, 0x5a, 0x87,
	0x77, 0x44, 0x14, 0x7d, 0x23, 0x6f, 0x14, 0x06, 0x52, 0x3d, 0x47, 0x69, 0xac, 0x34, 0xe6, 0xb4,
	0x94, 0x6b, 0xa2, 0xf7, 0x29, 0xd8, 0xba, 0x5b, 0xaf, 0x59, 0xad, 0xf5, 0xca, 0xcc, 0xf4, 0x95,
	0xb9, 0x33, 0xf5, 0xf6, 0xec, 0x13, 0x33, 0xaf, 0x51, 0x7a, 0x3a, 0x64, 0x55, 0x05, 0x99, 0x66,
	0x32, 0xa3, 0x1a, 0x62, 0xf6, 0xf6, 0xc1, 0x79, 0xed, 0x04, 0xcc, 0x08, 0xa0, 0x51, 0x09, 0xe0,
	0x96, 0x99, 0x98, 0xf7, 0x2b, 0x80, 0x6a, 0xae, 0x63, 0x9c, 0x48, 0xef, 0x82, 0x4e, 0xf4, 0x08,
	0x9b, 0xa7, 0x30, 0x0a, 0x32, 0x19, 0x2f, 0xbd, 0xba, 0x9a, 0x04, 0x95, 0x74, 0xb6, 0x09, 0x2d,
	0x1a, 0x57, 0x35, 0xab, 0x20, 0x57, 0xce, 0xaa, 0x88, 0xe2, 0x2d, 0x60, 0x4d, 0x27, 0x3c, 0x2e,
	0xff, 0x72, 0x2e, 0xd5, 0x6b, 0x2b, 0xa5, 0xfb, 0x00, 0x65, 0x48, 0x2e, 0x06, 0x6f, 0x35, 0x0c,
	0x9a, 0xf2, 0x45, 0x28, 0xa3, 0xa0, 0x78, 0x8d, 0x81, 0x50, 0xc9, 0x3a, 0xdb, 0xb5, 0xf4, 0x74,
	0x42, 0x67, 0xb7, 0x3f, 0x84, 0x5e, 0x71, 0x32, 0xb5, 0xff, 0x9f, 0x94, 0xc9, 0x58, 0xcb, 0x58,
	0x77, 0x1d, 0x9a, 0xe5, 0x38, 0x09, 0xe4, 0xd3, 0xc6, 0xc0, 0x2a, 0xf2, 0xb1, 0xf7, 0x1f, 0xcd,
	0x62, 0xb5, 0xe9, 0x86, 0x97, 0xaa, 0x38, 0x6b, 0xb5, 0x8a, 0x5b, 0x2e, 0x97, 0x1a, 0xbf, 0x55,
	0xb9, 0xf4, 0x73, 0x70, 0x03, 0xaa, 0x19, 0xc2, 0xeb, 0x22, 0xfc, 0x6e, 0xac, 0xd6, 0x07, 0xa6,
	0xaa, 0x08, 0xaf, 0x25, 0xaf, 0x98, 0xf1, 0x2e, 0x79, 0x72, 0x25, 0xe3, 0xf0, 0x3b, 0x6a, 0xf7,
	0xf1, 0xcd, 0x15, 0xa2, 0x9a, 0x9d, 0xe8, 0x3a, 0xc2, 0xcc, 0x4e, 0x8a, 0x31, 0x90, 0x5d, 0x8d,
	0x81, 0x50, 0x9e, 0xf3, 0x54, 0xc9, 0x2c, 0x2f, 0xea, 0x49, 0x0d, 0x95, 0x75, 0x99, 0x6b, 0x78,
	0xb1, 0x2e, 0x7b, 0x0f, 0x7a, 0x71, 0x12, 0x4f, 0xe2, 0x79, 0x14, 0x61, 0xc5, 0x6b, 0x26, 0x7e,
	0xdd, 0x38, 0x89, 0x8f, 0x0d, 0x8a, 0x3d, 0x82, 0x37, 0xea, 0x2c, 0xda, 0x9e, 0xbb, 0x7a, 0x60,
	0x50, 0xe3, 0x23, 0xab, 0xdf, 0x82, 0x7e, 0x72, 0xfe, 0x2b, 0xe9, 0xe7, 0x24, 0xb1, 0x09, 0x19,
	0x72, 0x4f, 0x27, 0x61, 0x8d, 0x47, 0x11, 0x1d, 0x8b, 0x99, 0xf4, 0xbe, 0x02, 0xb7, 0x14, 0x02,
	0xc6, 0xdb, 0xe3, 0x93, 0xe3, 0xa1, 0x8e, 0x88, 0x07, 0xc7, 0xfb, 0xc3, 0x3f, 0xed, 0x5b, 0x18,
	0xb1, 0xf9, 0xf0, 0xc5, 0x90, 0x8f, 0x86, 0xfd, 0x06, 0x46, 0xd3, 0xfd, 0xe1, 0xe1, 0x70, 0x3c,
	0xec, 0x37, 0xbf, 0x6e, 0x39, 0x9d, 0xbe, 0xc3, 0x1d, 0xb9, 0x48, 0xa3, 0xd0, 0x0f, 0x73, 0x6f,
	0x04, 0x50, 0x15, 0x41, 0x18, 0x57, 0xaa, 0xb3, 0xb5, 0x46, 0x9d, 0xdc, 0x9c, 0x8a, 0x95, 0x9b,
	0x31, 0xb5, 0xc6, 0xab, 0x2a, 0x37, 0x4d, 0xf7, 0xce, 0xc0, 0x39, 0x12, 0xe9, 0x4b, 0xcd, 0x4c,
	0xaf, 0x6c, 0x59, 0xe7, 0x66, 0x80, 0x63, 0x52, 0xf1, 0x87, 0xd0, 0x31, 0xa1, 0xcd, 0x78, 0xcd,
	0x52, 0xd8, 0x2b, 0x68, 0xd8, 0x5b, 0xbc, 0x75, 0x94, 0x5c, 0xcb, 0xb2, 0x1a, 0x39, 0x15, 0x37,
	0x51, 0x22, 0x82, 0x1f, 0x30, 0xc4, 0x9f, 0x01, 0xa8, 0x64, 0x9e, 0xf9, 0x72, 0x32, 0x2d, 0xe7,
	0x46, 0xae, 0xc6, 0x3c, 0x37, 0x23, 0x6a, 0xa9, 0x72, 0x22, 0x36, 0xb5, 0xf3, 0x21, 0x8c, 0xa4,
	0x9f, 0x80, 0x9d, 0x2f, 0xe2, 0x6a, 0x4c, 0xd5, 0xce, 0xb1, 0x93, 0xf4, 0xf6, 0xc0, 0x1d, 0x2f,
	0xa8, 0xbf, 0x9a, 0xab, 0xa5, 0xfc, 0x6a, 0xbd, 0x26, 0xbf, 0x36, 0x56, 0xa2, 0xf4, 0x7f, 0x5b,
	0xd0, 0xad, 0x95, 0x49, 0xec, 0x3d, 0x68, 0xe5, 0x8b, 0x78, 0x79, 0xbe, 0x5b, 0x1c, 0xc2, 0x89,
	0x84, 0xf6, 0x86, 0xcd, 0x97, 0x50, 0x2a, 0x9c, 0xc6, 0x32, 0x30, 0x5b, 0x62, 0x43, 0xb6, 0x6b,
	0x50, 0xec, 0x10, 0xee, 0xea, 0x48, 0x52, 0xcc, 0x76, 0x8a, 0x7a, 0xfc, 0xfd, 0x95, 0xb2, 0x4c,
	0xf7, 0xa0, 0x7b, 0x05, 0x97, 0xee, 0xb2, 0xd7, 0xa7, 0x4b, 0xc8, 0x8d, 0x5d, 0x78, 0xf3, 0x16,
	0xb6, 0x1f, 0x35, 0x4e, 0x78, 0x00, 0x6b, 0xd8, 0x7e, 0x87, 0x33, 0xa9, 0x72, 0x31, 0x4b, 0xa9,
	0x3e, 0x31, 0x99, 0xa0, 0xc5, 0x1b, 0xb9, 0xf2, 0x3e, 0x82, 0xde, 0xa9, 0x94, 0x19, 0x97, 0x2a,
	0x4d, 0x62, 0x9d, 0x9b, 0x15, 0x3d, 0xda, 0xa4, 0x1d, 0x03, 0x79, 0x7f, 0x01, 0x2e, 0x56, 0xde,
	0x4f, 0x45, 0xee, 0x5f, 0xfe, 0x98, 0xca, 0xfc, 0x23, 0xe8, 0xa4, 0xda, 0x4c, 0x4c, 0x1d, 0xdd,
	0xa3, 0x18, 0x67, 0x4c, 0x87, 0x17, 0x44, 0xef, 0x4b, 0x68, 0x1e, 0xcf, 0x67, 0xf5, 0x3f, 0x65,
	0x5a, 0xfa, 0x4f, 0x99, 0x77, 0xc1, 0xa5, 0x22, 0x9e, 0x66, 0x7d, 0xba, 0xbc, 0x74, 0x10, 0x41,
	0x43, 0xbe, 0x6f, 0xa1, 0x5b, 0xc8, 0xfe, 0x20, 0xa0, 0x7f, 0x56, 0x48, 0xf9, 0x07, 0xc1, 0x92,
	0x2d, 0xe8, 0x6e, 0x4f, 0xc6, 0xc1, 0x41, 0xa1, 0x34, 0x0d, 0x2c, 0xef, 0x6d, 0x06, 0x16, 0xe5,
	0xde, 0xcf, 0xa0, 0x57, 0x54, 0xc7, 0x47, 0x32, 0x17, 0x64, 0x4e, 0x51, 0x28, 0xe3, 0x9a, 0xa9,
	0x39, 0x1a, 0x31, 0x56, 0xaf, 0x19, 0x8d, 0x7a, 0xdb, 0x60, 0x1b, 0x5b, 0x65, 0xd0, 0xf2, 0x93,
	0x40, 0xbb, 0x48, 0x9b, 0xd3, 0x37, 0x3e, 0x78, 0xa6, 0xa6, 0x45, 0x7a, 0x9c, 0xa9, 0x29, 0xa6,
	0xa7, 0xa7, 0xc2, 0xbf, 0x9a, 0xa7, 0x45, 0x7a, 0xaa, 0xb5, 0x31, 0xd6, 0x52, 0x1b, 0xf3, 0x9a,
	0x79, 0xec, 0xdb, 0xd0, 0x99, 0xc7, 0xe1, 0xa2, 0xa8, 0x4f, 0x5c, 0x6e, 0x23, 0xa8, 0xe7, 0x90,
	0x51, 0xe2, 0x53, 0xe7, 0x42, 0x5e, 0xe5, 0xf2, 0x12, 0xf6, 0xfe, 0x1c, 0xd6, 0x86, 0x8b, 0x94,
	0xa6, 0xd3, 0x3f, 0x98, 0x18, 0x6b, 0x97, 0x6a, 0x2c, 0x5d, 0x6a, 0xe5, 0xe4, 0x66, 0x71, 0xf2,
	0xce, 0xbf, 0x58, 0xd0, 0x42, 0x13, 0xc1, 0xe6, 0xea, 0x8f, 0xa5, 0xc8, 0xf2, 0x73, 0x29, 0x72,
	0xb6, 0x64, 0x0e, 0x1b, 0x4b, 0x90, 0x77, 0xe7, 0x89, 0xc5, 0x3e, 0xd5, 0x83, 0xef, 0x62, 0x9e,
	0xbf, 0x56, 0x18, 0x1a, 0x19, 0xe2, 0x2a, 0x3f, 0xdb, 0x86, 0xee, 0xd7, 0x49, 0x18, 0xef, 0xe9,
	0x59, 0x30, 0x5b, 0x35, 0xcb, 0x97, 0xf8, 0x3f, 0x03, 0xfb, 0x40, 0xa1, 0xfd, 0xbf, 0xcc, 0x4a,
	0xe1, 0xb5, 0xee, 0x1a, 0xde, 0x9d, 0x9d, 0x7f, 0x6e, 0x42, 0xeb, 0x5b, 0x99, 0x25, 0xec, 0x53,
	0xe8, 0x98, 0x49, 0x0f, 0xab, 0x4d, 0x74, 0x36, 0x28, 0xbf, 0xae, 0x8c, 0x80, 0xe8, 0x94, 0xbe,
	0x8e, 0xd0, 0x55, 0xf7, 0xc7, 0xaa, 0x41, 0xd4, 0x4b, 0x97, 0xfa, 0x0a, 0xfa, 0xa3, 0x3c, 0x93,
	0x62, 0x56, 0x63, 0x5f, 0x16, 0xd3, 0x6d, 0xad, 0x24, 0x49, 0xeb, 0x13, 0xb0, 0x75, 0x90, 0x59,
	0x59, 0xb0, 0xda, 0x15, 0x12, 0xf3, 0x43, 0xe8, 0x8e, 0x2e, 0x93, 0x79, 0x14, 0x8c, 0x64, 0x76,
	0x2d, 0x59, 0x6d, 0xda, 0xba, 0x51, 0xfb, 0xf6, 0xee, 0xb0, 0x2d, 0x00, 0xed, 0x65, 0x67, 0x61,
	0xa0, 0x58, 0x07, 0x69, 0xc7, 0xf3, 0x99, 0xde, 0xb4, 0xe6, 0x7e, 0x9a, 0xb3, 0x16, 0x6b, 0x5e,
	0xc7, 0xf9, 0x05, 0xac, 0xed, 0x51, 0x2c, 0x3e, 0xc9, 0x76, 0xcf, 0x93, 0x2c, 0x67, 0xab, 0x13,
	0xd7, 0x8d, 0x55, 0x84, 0x77, 0x87, 0x3d, 0x01, 0x67, 0x9c, 0xdd, 0x68, 0xfe, 0x37, 0x4c, 0x88,
	0xae, 0xce, 0xbb, 0xe5, 0x95, 0x3b, 0xff, 0xd8, 0x04, 0xfb, 0x97, 0x49, 0x76, 0x25, 0x33, 0xf6,
	0x08, 0x6c, 0x6a, 0xdf, 0x8d, 0x11, 0x95, 0xad, 0xfc, 0x6d, 0x07, 0x7d, 0x00, 0x2e, 0x09, 0x65,
	0x2c, 0xd4, 0x95, 0x56, 0x15, 0xfd, 0x2d, 0xab, 0xe5, 0xa2, 0x8b, 0x37, 0xd2, 0xeb, 0xba, 0x56,
	0x54, 0x39, 0xb2, 0x58, 0xea, 0xa9, 0x37, 0x3a, 0xba, 0x41, 0x1e, 0x79, 0x77, 0xb6, 0xac, 0x27,
	0x16, 0xfb, 0x18, 0x5a, 0x23, 0xfd, 0x52, 0x64, 0xaa, 0xfe, 0xa4, 0xda, 0x58, 0x2f, 0x10, 0xe5,
	0xce, 0x8f, 0xc1, 0xd6, 0x99, 0x5d, 0x3f, 0x73, 0xa9, 0x5c, 0xdd, 0xe8, 0xd7, 0x51, 0x66, 0xc1,
	0xc7, 0x60, 0xeb, 0xa0, 0xa1, 0x17, 0x2c, 0x05, 0x10, 0x7d, 0x6b, 0x1d, 0x83, 0x34, 0xab, 0xf6,
	0x72, 0xcd, 0xba, 0xe4, 0xf1, 0x2b, 0xac, 0x9f, 0x41, 0x9f, 0x4b, 0x5f, 0x86, 0xb5, 0x9c, 0xcf,
	0x8a, 0x47, 0xad, 0x9a, 0xed, 0x96, 0xc5, 0xbe, 0x82, 0xb5, 0xa5, 0xfa, 0x80, 0x0d, 0x48, 0xd0,
	0xb7, 0x94, 0x0c, 0xab, 0x8b, 0x9f, 0xf6, 0xff, 0xed, 0xfb, 0xfb, 0xd6, 0xbf, 0x7f, 0x7f, 0xdf,
	0xfa, 0xcf, 0xef, 0xef, 0x5b, 0xbf, 0xfe, 0xaf, 0xfb, 0x77, 0xce, 0x6d, 0xfa, 0x3b, 0xff, 0x8b,
	0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x02, 0x75, 0x7b, 0x47, 0x12, 0x20, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RaftClient is the client API for Raft service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RaftClient interface {
	Heartbeat(ctx context.Context, in *api.Payload, opts ...grpc.CallOption) (Raft_HeartbeatClient, error)
	RaftMessage(ctx context.Context, in *RaftBatch, opts ...grpc.CallOption) (*api.Payload, error)
	JoinCluster(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (*api.Payload, error)
	IsPeer(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (*PeerResponse, error)
}

type raftClient struct {
	cc *grpc.ClientConn
}

func NewRaftClient(cc *grpc.ClientConn) RaftClient {
	return &raftClient{cc}
}

func (c *raftClient) Heartbeat(ctx context.Context, in *api.Payload, opts ...grpc.CallOption) (Raft_HeartbeatClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Raft_serviceDesc.Streams[0], "/pb.Raft/Heartbeat", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftHeartbeatClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Raft_HeartbeatClient interface {
	Recv() (*api.Payload, error)
	grpc.ClientStream
}

type raftHeartbeatClient struct {
	grpc.ClientStream
}

func (x *raftHeartbeatClient) Recv() (*api.Payload, error) {
	m := new(api.Payload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *raftClient) RaftMessage(ctx context.Context, in *RaftBatch, opts ...grpc.CallOption) (*api.Payload, error) {
	out := new(api.Payload)
	err := c.cc.Invoke(ctx, "/pb.Raft/RaftMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftClient) JoinCluster(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (*api.Payload, error) {
	out := new(api.Payload)
	err := c.cc.Invoke(ctx, "/pb.Raft/JoinCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftClient) IsPeer(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (*PeerResponse, error) {
	out := new(PeerResponse)
	err := c.cc.Invoke(ctx, "/pb.Raft/IsPeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RaftServer is the server API for Raft service.
type RaftServer interface {
	Heartbeat(*api.Payload, Raft_HeartbeatServer) error
	RaftMessage(context.Context, *RaftBatch) (*api.Payload, error)
	JoinCluster(context.Context, *RaftContext) (*api.Payload, error)
	IsPeer(context.Context, *RaftContext) (*PeerResponse, error)
}

func RegisterRaftServer(s *grpc.Server, srv RaftServer) {
	s.RegisterService(&_Raft_serviceDesc, srv)
}

func _Raft_Heartbeat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.Payload)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RaftServer).Heartbeat(m, &raftHeartbeatServer{stream})
}

type Raft_HeartbeatServer interface {
	Send(*api.Payload) error
	grpc.ServerStream
}

type raftHeartbeatServer struct {
	grpc.ServerStream
}

func (x *raftHeartbeatServer) Send(m *api.Payload) error {
	return x.ServerStream.SendMsg(m)
}

func _Raft_RaftMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaftBatch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServer).RaftMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Raft/RaftMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServer).RaftMessage(ctx, req.(*RaftBatch))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raft_JoinCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaftContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServer).JoinCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Raft/JoinCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServer).JoinCluster(ctx, req.(*RaftContext))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raft_IsPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaftContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServer).IsPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Raft/IsPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServer).IsPeer(ctx, req.(*RaftContext))
	}
	return interceptor(ctx, in, info, handler)
}

var _Raft_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Raft",
	HandlerType: (*RaftServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RaftMessage",
			Handler:    _Raft_RaftMessage_Handler,
		},
		{
			MethodName: "JoinCluster",
			Handler:    _Raft_JoinCluster_Handler,
		},
		{
			MethodName: "IsPeer",
			Handler:    _Raft_IsPeer_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Heartbeat",
			Handler:       _Raft_Heartbeat_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pb.proto",
}

// ZeroClient is the client API for Zero service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ZeroClient interface {
	// These 3 endpoints are for handling membership.
	Connect(ctx context.Context, in *Member, opts ...grpc.CallOption) (*ConnectionState, error)
	UpdateMembership(ctx context.Context, in *Group, opts ...grpc.CallOption) (*api.Payload, error)
	StreamMembership(ctx context.Context, in *api.Payload, opts ...grpc.CallOption) (Zero_StreamMembershipClient, error)
	Oracle(ctx context.Context, in *api.Payload, opts ...grpc.CallOption) (Zero_OracleClient, error)
	ShouldServe(ctx context.Context, in *Tablet, opts ...grpc.CallOption) (*Tablet, error)
	AssignUids(ctx context.Context, in *Num, opts ...grpc.CallOption) (*AssignedIds, error)
	Timestamps(ctx context.Context, in *Num, opts ...grpc.CallOption) (*AssignedIds, error)
	CommitOrAbort(ctx context.Context, in *api.TxnContext, opts ...grpc.CallOption) (*api.TxnContext, error)
	TryAbort(ctx context.Context, in *TxnTimestamps, opts ...grpc.CallOption) (*OracleDelta, error)
}

type zeroClient struct {
	cc *grpc.ClientConn
}

func NewZeroClient(cc *grpc.ClientConn) ZeroClient {
	return &zeroClient{cc}
}

func (c *zeroClient) Connect(ctx context.Context, in *Member, opts ...grpc.CallOption) (*ConnectionState, error) {
	out := new(ConnectionState)
	err := c.cc.Invoke(ctx, "/pb.Zero/Connect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) UpdateMembership(ctx context.Context, in *Group, opts ...grpc.CallOption) (*api.Payload, error) {
	out := new(api.Payload)
	err := c.cc.Invoke(ctx, "/pb.Zero/UpdateMembership", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) StreamMembership(ctx context.Context, in *api.Payload, opts ...grpc.CallOption) (Zero_StreamMembershipClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Zero_serviceDesc.Streams[0], "/pb.Zero/StreamMembership", opts...)
	if err != nil {
		return nil, err
	}
	x := &zeroStreamMembershipClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Zero_StreamMembershipClient interface {
	Recv() (*MembershipState, error)
	grpc.ClientStream
}

type zeroStreamMembershipClient struct {
	grpc.ClientStream
}

func (x *zeroStreamMembershipClient) Recv() (*MembershipState, error) {
	m := new(MembershipState)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *zeroClient) Oracle(ctx context.Context, in *api.Payload, opts ...grpc.CallOption) (Zero_OracleClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Zero_serviceDesc.Streams[1], "/pb.Zero/Oracle", opts...)
	if err != nil {
		return nil, err
	}
	x := &zeroOracleClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Zero_OracleClient interface {
	Recv() (*OracleDelta, error)
	grpc.ClientStream
}

type zeroOracleClient struct {
	grpc.ClientStream
}

func (x *zeroOracleClient) Recv() (*OracleDelta, error) {
	m := new(OracleDelta)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *zeroClient) ShouldServe(ctx context.Context, in *Tablet, opts ...grpc.CallOption) (*Tablet, error) {
	out := new(Tablet)
	err := c.cc.Invoke(ctx, "/pb.Zero/ShouldServe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) AssignUids(ctx context.Context, in *Num, opts ...grpc.CallOption) (*AssignedIds, error) {
	out := new(AssignedIds)
	err := c.cc.Invoke(ctx, "/pb.Zero/AssignUids", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) Timestamps(ctx context.Context, in *Num, opts ...grpc.CallOption) (*AssignedIds, error) {
	out := new(AssignedIds)
	err := c.cc.Invoke(ctx, "/pb.Zero/Timestamps", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) CommitOrAbort(ctx context.Context, in *api.TxnContext, opts ...grpc.CallOption) (*api.TxnContext, error) {
	out := new(api.TxnContext)
	err := c.cc.Invoke(ctx, "/pb.Zero/CommitOrAbort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) TryAbort(ctx context.Context, in *TxnTimestamps, opts ...grpc.CallOption) (*OracleDelta, error) {
	out := new(OracleDelta)
	err := c.cc.Invoke(ctx, "/pb.Zero/TryAbort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ZeroServer is the server API for Zero service.
type ZeroServer interface {
	// These 3 endpoints are for handling membership.
	Connect(context.Context, *Member) (*ConnectionState, error)
	UpdateMembership(context.Context, *Group) (*api.Payload, error)
	StreamMembership(*api.Payload, Zero_StreamMembershipServer) error
	Oracle(*api.Payload, Zero_OracleServer) error
	ShouldServe(context.Context, *Tablet) (*Tablet, error)
	AssignUids(context.Context, *Num) (*AssignedIds, error)
	Timestamps(context.Context, *Num) (*AssignedIds, error)
	CommitOrAbort(context.Context, *api.TxnContext) (*api.TxnContext, error)
	TryAbort(context.Context, *TxnTimestamps) (*OracleDelta, error)
}

func RegisterZeroServer(s *grpc.Server, srv ZeroServer) {
	s.RegisterService(&_Zero_serviceDesc, srv)
}

func _Zero_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Member)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Zero/Connect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).Connect(ctx, req.(*Member))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_UpdateMembership_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Group)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).UpdateMembership(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Zero/UpdateMembership",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).UpdateMembership(ctx, req.(*Group))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_StreamMembership_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.Payload)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ZeroServer).StreamMembership(m, &zeroStreamMembershipServer{stream})
}

type Zero_StreamMembershipServer interface {
	Send(*MembershipState) error
	grpc.ServerStream
}

type zeroStreamMembershipServer struct {
	grpc.ServerStream
}

func (x *zeroStreamMembershipServer) Send(m *MembershipState) error {
	return x.ServerStream.SendMsg(m)
}

func _Zero_Oracle_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.Payload)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ZeroServer).Oracle(m, &zeroOracleServer{stream})
}

type Zero_OracleServer interface {
	Send(*OracleDelta) error
	grpc.ServerStream
}

type zeroOracleServer struct {
	grpc.ServerStream
}

func (x *zeroOracleServer) Send(m *OracleDelta) error {
	return x.ServerStream.SendMsg(m)
}

func _Zero_ShouldServe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Tablet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).ShouldServe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Zero/ShouldServe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).ShouldServe(ctx, req.(*Tablet))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_AssignUids_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Num)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).AssignUids(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Zero/AssignUids",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).AssignUids(ctx, req.(*Num))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_Timestamps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Num)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).Timestamps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Zero/Timestamps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).Timestamps(ctx, req.(*Num))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_CommitOrAbort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.TxnContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).CommitOrAbort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Zero/CommitOrAbort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).CommitOrAbort(ctx, req.(*api.TxnContext))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_TryAbort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxnTimestamps)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).TryAbort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Zero/TryAbort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).TryAbort(ctx, req.(*TxnTimestamps))
	}
	return interceptor(ctx, in, info, handler)
}

var _Zero_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Zero",
	HandlerType: (*ZeroServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Connect",
			Handler:    _Zero_Connect_Handler,
		},
		{
			MethodName: "UpdateMembership",
			Handler:    _Zero_UpdateMembership_Handler,
		},
		{
			MethodName: "ShouldServe",
			Handler:    _Zero_ShouldServe_Handler,
		},
		{
			MethodName: "AssignUids",
			Handler:    _Zero_AssignUids_Handler,
		},
		{
			MethodName: "Timestamps",
			Handler:    _Zero_Timestamps_Handler,
		},
		{
			MethodName: "CommitOrAbort",
			Handler:    _Zero_CommitOrAbort_Handler,
		},
		{
			MethodName: "TryAbort",
			Handler:    _Zero_TryAbort_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamMembership",
			Handler:       _Zero_StreamMembership_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Oracle",
			Handler:       _Zero_Oracle_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pb.proto",
}

// WorkerClient is the client API for Worker service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WorkerClient interface {
	// Data serving RPCs.
	Mutate(ctx context.Context, in *Mutations, opts ...grpc.CallOption) (*api.TxnContext, error)
	ServeTask(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Result, error)
	StreamSnapshot(ctx context.Context, opts ...grpc.CallOption) (Worker_StreamSnapshotClient, error)
	Sort(ctx context.Context, in *SortMessage, opts ...grpc.CallOption) (*SortResult, error)
	Schema(ctx context.Context, in *SchemaRequest, opts ...grpc.CallOption) (*SchemaResult, error)
	Backup(ctx context.Context, in *BackupRequest, opts ...grpc.CallOption) (*Status, error)
	Export(ctx context.Context, in *ExportRequest, opts ...grpc.CallOption) (*Status, error)
	ReceivePredicate(ctx context.Context, opts ...grpc.CallOption) (Worker_ReceivePredicateClient, error)
	MovePredicate(ctx context.Context, in *MovePredicatePayload, opts ...grpc.CallOption) (*api.Payload, error)
}

type workerClient struct {
	cc *grpc.ClientConn
}

func NewWorkerClient(cc *grpc.ClientConn) WorkerClient {
	return &workerClient{cc}
}

func (c *workerClient) Mutate(ctx context.Context, in *Mutations, opts ...grpc.CallOption) (*api.TxnContext, error) {
	out := new(api.TxnContext)
	err := c.cc.Invoke(ctx, "/pb.Worker/Mutate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) ServeTask(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/pb.Worker/ServeTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) StreamSnapshot(ctx context.Context, opts ...grpc.CallOption) (Worker_StreamSnapshotClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Worker_serviceDesc.Streams[0], "/pb.Worker/StreamSnapshot", opts...)
	if err != nil {
		return nil, err
	}
	x := &workerStreamSnapshotClient{stream}
	return x, nil
}

type Worker_StreamSnapshotClient interface {
	Send(*Snapshot) error
	Recv() (*KVS, error)
	grpc.ClientStream
}

type workerStreamSnapshotClient struct {
	grpc.ClientStream
}

func (x *workerStreamSnapshotClient) Send(m *Snapshot) error {
	return x.ClientStream.SendMsg(m)
}

func (x *workerStreamSnapshotClient) Recv() (*KVS, error) {
	m := new(KVS)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workerClient) Sort(ctx context.Context, in *SortMessage, opts ...grpc.CallOption) (*SortResult, error) {
	out := new(SortResult)
	err := c.cc.Invoke(ctx, "/pb.Worker/Sort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) Schema(ctx context.Context, in *SchemaRequest, opts ...grpc.CallOption) (*SchemaResult, error) {
	out := new(SchemaResult)
	err := c.cc.Invoke(ctx, "/pb.Worker/Schema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) Backup(ctx context.Context, in *BackupRequest, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/pb.Worker/Backup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) Export(ctx context.Context, in *ExportRequest, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/pb.Worker/Export", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) ReceivePredicate(ctx context.Context, opts ...grpc.CallOption) (Worker_ReceivePredicateClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Worker_serviceDesc.Streams[1], "/pb.Worker/ReceivePredicate", opts...)
	if err != nil {
		return nil, err
	}
	x := &workerReceivePredicateClient{stream}
	return x, nil
}

type Worker_ReceivePredicateClient interface {
	Send(*KVS) error
	CloseAndRecv() (*api.Payload, error)
	grpc.ClientStream
}

type workerReceivePredicateClient struct {
	grpc.ClientStream
}

func (x *workerReceivePredicateClient) Send(m *KVS) error {
	return x.ClientStream.SendMsg(m)
}

func (x *workerReceivePredicateClient) CloseAndRecv() (*api.Payload, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(api.Payload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workerClient) MovePredicate(ctx context.Context, in *MovePredicatePayload, opts ...grpc.CallOption) (*api.Payload, error) {
	out := new(api.Payload)
	err := c.cc.Invoke(ctx, "/pb.Worker/MovePredicate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkerServer is the server API for Worker service.
type WorkerServer interface {
	// Data serving RPCs.
	Mutate(context.Context, *Mutations) (*api.TxnContext, error)
	ServeTask(context.Context, *Query) (*Result, error)
	StreamSnapshot(Worker_StreamSnapshotServer) error
	Sort(context.Context, *SortMessage) (*SortResult, error)
	Schema(context.Context, *SchemaRequest) (*SchemaResult, error)
	Backup(context.Context, *BackupRequest) (*Status, error)
	Export(context.Context, *ExportRequest) (*Status, error)
	ReceivePredicate(Worker_ReceivePredicateServer) error
	MovePredicate(context.Context, *MovePredicatePayload) (*api.Payload, error)
}

func RegisterWorkerServer(s *grpc.Server, srv WorkerServer) {
	s.RegisterService(&_Worker_serviceDesc, srv)
}

func _Worker_Mutate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Mutations)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Mutate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/Mutate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Mutate(ctx, req.(*Mutations))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_ServeTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).ServeTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/ServeTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).ServeTask(ctx, req.(*Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_StreamSnapshot_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WorkerServer).StreamSnapshot(&workerStreamSnapshotServer{stream})
}

type Worker_StreamSnapshotServer interface {
	Send(*KVS) error
	Recv() (*Snapshot, error)
	grpc.ServerStream
}

type workerStreamSnapshotServer struct {
	grpc.ServerStream
}

func (x *workerStreamSnapshotServer) Send(m *KVS) error {
	return x.ServerStream.SendMsg(m)
}

func (x *workerStreamSnapshotServer) Recv() (*Snapshot, error) {
	m := new(Snapshot)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Worker_Sort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SortMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Sort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/Sort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Sort(ctx, req.(*SortMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_Schema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Schema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/Schema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Schema(ctx, req.(*SchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_Backup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BackupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Backup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/Backup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Backup(ctx, req.(*BackupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_Export_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Export(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/Export",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Export(ctx, req.(*ExportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_ReceivePredicate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WorkerServer).ReceivePredicate(&workerReceivePredicateServer{stream})
}

type Worker_ReceivePredicateServer interface {
	SendAndClose(*api.Payload) error
	Recv() (*KVS, error)
	grpc.ServerStream
}

type workerReceivePredicateServer struct {
	grpc.ServerStream
}

func (x *workerReceivePredicateServer) SendAndClose(m *api.Payload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *workerReceivePredicateServer) Recv() (*KVS, error) {
	m := new(KVS)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Worker_MovePredicate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MovePredicatePayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).MovePredicate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/MovePredicate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).MovePredicate(ctx, req.(*MovePredicatePayload))
	}
	return interceptor(ctx, in, info, handler)
}

var _Worker_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Worker",
	HandlerType: (*WorkerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Mutate",
			Handler:    _Worker_Mutate_Handler,
		},
		{
			MethodName: "ServeTask",
			Handler:    _Worker_ServeTask_Handler,
		},
		{
			MethodName: "Sort",
			Handler:    _Worker_Sort_Handler,
		},
		{
			MethodName: "Schema",
			Handler:    _Worker_Schema_Handler,
		},
		{
			MethodName: "Backup",
			Handler:    _Worker_Backup_Handler,
		},
		{
			MethodName: "Export",
			Handler:    _Worker_Export_Handler,
		},
		{
			MethodName: "MovePredicate",
			Handler:    _Worker_MovePredicate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamSnapshot",
			Handler:       _Worker_StreamSnapshot_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "ReceivePredicate",
			Handler:       _Worker_ReceivePredicate_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "pb.proto",
}

func (m *List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *List) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uids) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Uids)*8))
		for _, num := range m.Uids {
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(num))
			i += 8
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TaskValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Val) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Val)))
		i += copy(dAtA[i:], m.Val)
	}
	if m.ValType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.ValType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SrcFunction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SrcFunction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IsCount {
		dAtA[i] = 0x20
		i++
		if m.IsCount {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Query) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Query) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Attr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Attr)))
		i += copy(dAtA[i:], m.Attr)
	}
	if len(m.Langs) > 0 {
		for _, s := range m.Langs {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.AfterUid != 0 {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AfterUid))
		i += 8
	}
	if m.DoCount {
		dAtA[i] = 0x20
		i++
		if m.DoCount {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UidList != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.UidList.Size()))
		n1, err := m.UidList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.SrcFunc != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.SrcFunc.Size()))
		n2, err := m.SrcFunc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Reverse {
		dAtA[i] = 0x38
		i++
		if m.Reverse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FacetParam != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.FacetParam.Size()))
		n3, err := m.FacetParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.FacetsFilter != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.FacetsFilter.Size()))
		n4, err := m.FacetsFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.ExpandAll {
		dAtA[i] = 0x50
		i++
		if m.ExpandAll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReadTs != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.ReadTs))
	}
	if m.Cache != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Cache))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValueList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValueList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, msg := range m.Values {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LangList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LangList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Lang) > 0 {
		for _, s := range m.Lang {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UidMatrix) > 0 {
		for _, msg := range m.UidMatrix {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ValueMatrix) > 0 {
		for _, msg := range m.ValueMatrix {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Counts) > 0 {
		dAtA6 := make([]byte, len(m.Counts)*10)
		var j5 int
		for _, num := range m.Counts {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPb(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if m.IntersectDest {
		dAtA[i] = 0x20
		i++
		if m.IntersectDest {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.FacetMatrix) > 0 {
		for _, msg := range m.FacetMatrix {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.LangMatrix) > 0 {
		for _, msg := range m.LangMatrix {
			dAtA[i] = 0x32
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.List {
		dAtA[i] = 0x38
		i++
		if m.List {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Attr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Attr)))
		i += copy(dAtA[i:], m.Attr)
	}
	if m.Desc {
		dAtA[i] = 0x10
		i++
		if m.Desc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Langs) > 0 {
		for _, s := range m.Langs {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SortMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SortMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Order) > 0 {
		for _, msg := range m.Order {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.UidMatrix) > 0 {
		for _, msg := range m.UidMatrix {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Count != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Count))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Offset))
	}
	if m.ReadTs != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.ReadTs))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SortResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SortResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UidMatrix) > 0 {
		for _, msg := range m.UidMatrix {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RaftContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftContext) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Id))
		i += 8
	}
	if m.Group != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Group))
	}
	if len(m.Addr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	if m.SnapshotTs != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.SnapshotTs))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Member) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Id))
		i += 8
	}
	if m.GroupId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
	}
	if len(m.Addr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	if m.Leader {
		dAtA[i] = 0x20
		i++
		if m.Leader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AmDead {
		dAtA[i] = 0x28
		i++
		if m.AmDead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LastUpdate != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.LastUpdate))
	}
	if m.ClusterInfoOnly {
		dAtA[i] = 0x68
		i++
		if m.ClusterInfoOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Group) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Group) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Members) > 0 {
		for k, _ := range m.Members {
			dAtA[i] = 0xa
			i++
			v := m.Members[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovPb(uint64(msgSize))
			}
			mapSize := 1 + sovPb(uint64(k)) + msgSize
			i = encodeVarintPb(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintPb(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintPb(dAtA, i, uint64(v.Size()))
				n7, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n7
			}
		}
	}
	if len(m.Tablets) > 0 {
		for k, _ := range m.Tablets {
			dAtA[i] = 0x12
			i++
			v := m.Tablets[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovPb(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovPb(uint64(len(k))) + msgSize
			i = encodeVarintPb(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPb(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintPb(dAtA, i, uint64(v.Size()))
				n8, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n8
			}
		}
	}
	if m.SnapshotTs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.SnapshotTs))
	}
	if m.Checksum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Checksum))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ZeroProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroProposal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SnapshotTs) > 0 {
		for k, _ := range m.SnapshotTs {
			dAtA[i] = 0xa
			i++
			v := m.SnapshotTs[k]
			mapSize := 1 + sovPb(uint64(k)) + 1 + sovPb(uint64(v))
			i = encodeVarintPb(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintPb(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintPb(dAtA, i, uint64(v))
		}
	}
	if m.Member != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Member.Size()))
		n9, err := m.Member.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Tablet != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Tablet.Size()))
		n10, err := m.Tablet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.MaxLeaseId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.MaxLeaseId))
	}
	if m.MaxTxnTs != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.MaxTxnTs))
	}
	if m.MaxRaftId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.MaxRaftId))
	}
	if m.Txn != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Txn.Size()))
		n11, err := m.Txn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Cid) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Cid)))
		i += copy(dAtA[i:], m.Cid)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MembershipState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MembershipState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Counter != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Counter))
	}
	if len(m.Groups) > 0 {
		for k, _ := range m.Groups {
			dAtA[i] = 0x12
			i++
			v := m.Groups[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovPb(uint64(msgSize))
			}
			mapSize := 1 + sovPb(uint64(k)) + msgSize
			i = encodeVarintPb(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintPb(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintPb(dAtA, i, uint64(v.Size()))
				n12, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n12
			}
		}
	}
	if len(m.Zeros) > 0 {
		for k, _ := range m.Zeros {
			dAtA[i] = 0x1a
			i++
			v := m.Zeros[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovPb(uint64(msgSize))
			}
			mapSize := 1 + sovPb(uint64(k)) + msgSize
			i = encodeVarintPb(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintPb(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintPb(dAtA, i, uint64(v.Size()))
				n13, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n13
			}
		}
	}
	if m.MaxLeaseId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.MaxLeaseId))
	}
	if m.MaxTxnTs != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.MaxTxnTs))
	}
	if m.MaxRaftId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.MaxRaftId))
	}
	if len(m.Removed) > 0 {
		for _, msg := range m.Removed {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Cid) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Cid)))
		i += copy(dAtA[i:], m.Cid)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConnectionState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Member != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Member.Size()))
		n14, err := m.Member.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.State != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.State.Size()))
		n15, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.MaxPending != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.MaxPending))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Tablet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tablet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
	}
	if len(m.Predicate) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Predicate)))
		i += copy(dAtA[i:], m.Predicate)
	}
	if m.Force {
		dAtA[i] = 0x18
		i++
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Space != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Space))
	}
	if m.Remove {
		dAtA[i] = 0x40
		i++
		if m.Remove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DirectedEdge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectedEdge) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Entity != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Entity))
		i += 8
	}
	if len(m.Attr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Attr)))
		i += copy(dAtA[i:], m.Attr)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.ValueType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.ValueType))
	}
	if m.ValueId != 0 {
		dAtA[i] = 0x29
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ValueId))
		i += 8
	}
	if len(m.Label) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Label)))
		i += copy(dAtA[i:], m.Label)
	}
	if len(m.Lang) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Lang)))
		i += copy(dAtA[i:], m.Lang)
	}
	if m.Op != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Op))
	}
	if len(m.Facets) > 0 {
		for _, msg := range m.Facets {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Mutations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mutations) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
	}
	if m.StartTs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.StartTs))
	}
	if len(m.Edges) > 0 {
		for _, msg := range m.Edges {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Schema) > 0 {
		for _, msg := range m.Schema {
			dAtA[i] = 0x22
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DropAll {
		dAtA[i] = 0x28
		i++
		if m.DropAll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IgnoreIndexConflict {
		dAtA[i] = 0x30
		i++
		if m.IgnoreIndexConflict {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Types) > 0 {
		for _, msg := range m.Types {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Snapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Context.Size()))
		n16, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Index != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Index))
	}
	if m.ReadTs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.ReadTs))
	}
	if m.Done {
		dAtA[i] = 0x20
		i++
		if m.Done {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Proposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mutations != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Mutations.Size()))
		n17, err := m.Mutations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.Kv) > 0 {
		for _, msg := range m.Kv {
			dAtA[i] = 0x22
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.State != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.State.Size()))
		n18, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if len(m.CleanPredicate) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.CleanPredicate)))
		i += copy(dAtA[i:], m.CleanPredicate)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Delta != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Delta.Size()))
		n19, err := m.Delta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Snapshot != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Snapshot.Size()))
		n20, err := m.Snapshot.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Index != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KVS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVS) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kv) > 0 {
		for _, msg := range m.Kv {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Done {
		dAtA[i] = 0x10
		i++
		if m.Done {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Posting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Posting) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Uid))
		i += 8
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.ValType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.ValType))
	}
	if m.PostingType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.PostingType))
	}
	if len(m.LangTag) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.LangTag)))
		i += copy(dAtA[i:], m.LangTag)
	}
	if len(m.Label) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Label)))
		i += copy(dAtA[i:], m.Label)
	}
	if len(m.Facets) > 0 {
		for _, msg := range m.Facets {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Op != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Op))
	}
	if m.StartTs != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.StartTs))
	}
	if m.CommitTs != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.CommitTs))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UidBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UidBlock) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Base != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Base))
	}
	if len(m.Deltas) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Deltas)))
		i += copy(dAtA[i:], m.Deltas)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UidPack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UidPack) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockSize != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.BlockSize))
	}
	if len(m.Blocks) > 0 {
		for _, msg := range m.Blocks {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PostingList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PostingList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pack != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Pack.Size()))
		n21, err := m.Pack.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.Postings) > 0 {
		for _, msg := range m.Postings {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CommitTs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.CommitTs))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FacetParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FacetParam) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Alias) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Alias)))
		i += copy(dAtA[i:], m.Alias)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FacetParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FacetParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AllKeys {
		dAtA[i] = 0x8
		i++
		if m.AllKeys {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Param) > 0 {
		for _, msg := range m.Param {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Facets) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Facets) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Facets) > 0 {
		for _, msg := range m.Facets {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FacetsList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FacetsList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FacetsList) > 0 {
		for _, msg := range m.FacetsList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Function) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Function) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FilterTree) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterTree) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Op) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Op)))
		i += copy(dAtA[i:], m.Op)
	}
	if len(m.Children) > 0 {
		for _, msg := range m.Children {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Func != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Func.Size()))
		n22, err := m.Func.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SchemaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
	}
	if len(m.Predicates) > 0 {
		for _, s := range m.Predicates {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Types) > 0 {
		for _, s := range m.Types {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SchemaResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Schema) > 0 {
		for _, msg := range m.Schema {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SchemaUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Predicate) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Predicate)))
		i += copy(dAtA[i:], m.Predicate)
	}
	if m.ValueType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.ValueType))
	}
	if m.Directive != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Directive))
	}
	if len(m.Tokenizer) > 0 {
		for _, s := range m.Tokenizer {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Count {
		dAtA[i] = 0x28
		i++
		if m.Count {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.List {
		dAtA[i] = 0x30
		i++
		if m.List {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Upsert {
		dAtA[i] = 0x40
		i++
		if m.Upsert {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Lang {
		dAtA[i] = 0x48
		i++
		if m.Lang {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NonNullable {
		dAtA[i] = 0x50
		i++
		if m.NonNullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NonNullableList {
		dAtA[i] = 0x58
		i++
		if m.NonNullableList {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ObjectTypeName) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.ObjectTypeName)))
		i += copy(dAtA[i:], m.ObjectTypeName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TypeUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TypeName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.TypeName)))
		i += copy(dAtA[i:], m.TypeName)
	}
	if len(m.Fields) > 0 {
		for _, msg := range m.Fields {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MapEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MapEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Uid != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Uid))
		i += 8
	}
	if m.Posting != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Posting.Size()))
		n23, err := m.Posting.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MovePredicatePayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MovePredicatePayload) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Predicate) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Predicate)))
		i += copy(dAtA[i:], m.Predicate)
	}
	if m.SourceGid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.SourceGid))
	}
	if m.DestGid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.DestGid))
	}
	if m.TxnTs != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.TxnTs))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.StartTs))
	}
	if m.CommitTs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.CommitTs))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OracleDelta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleDelta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Txns) > 0 {
		for _, msg := range m.Txns {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MaxAssigned != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.MaxAssigned))
	}
	if len(m.GroupChecksums) > 0 {
		for k, _ := range m.GroupChecksums {
			dAtA[i] = 0x1a
			i++
			v := m.GroupChecksums[k]
			mapSize := 1 + sovPb(uint64(k)) + 1 + sovPb(uint64(v))
			i = encodeVarintPb(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintPb(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintPb(dAtA, i, uint64(v))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnTimestamps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnTimestamps) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ts) > 0 {
		dAtA25 := make([]byte, len(m.Ts)*10)
		var j24 int
		for _, num := range m.Ts {
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintPb(dAtA, i, uint64(j24))
		i += copy(dAtA[i:], dAtA25[:j24])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PeerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status {
		dAtA[i] = 0x8
		i++
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RaftBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Context.Size()))
		n26, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Payload != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Payload.Size()))
		n27, err := m.Payload.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Num) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Num) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Val != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Val))
	}
	if m.ReadOnly {
		dAtA[i] = 0x10
		i++
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AssignedIds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssignedIds) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.StartId))
	}
	if m.EndId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.EndId))
	}
	if m.ReadOnly != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.ReadOnly))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SnapshotMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClientTs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.ClientTs))
	}
	if m.GroupId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BackupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReadTs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.ReadTs))
	}
	if m.GroupId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
	}
	if len(m.UnixTs) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.UnixTs)))
		i += copy(dAtA[i:], m.UnixTs)
	}
	if len(m.Location) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Location)))
		i += copy(dAtA[i:], m.Location)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExportRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
	}
	if m.ReadTs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.ReadTs))
	}
	if m.UnixTs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPb(dAtA, i, uint64(m.UnixTs))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintPb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Uids) > 0 {
		n += 1 + sovPb(uint64(len(m.Uids)*8)) + len(m.Uids)*8
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TaskValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Val)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.ValType != 0 {
		n += 1 + sovPb(uint64(m.ValType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SrcFunction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.IsCount {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Query) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Attr)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Langs) > 0 {
		for _, s := range m.Langs {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.AfterUid != 0 {
		n += 9
	}
	if m.DoCount {
		n += 2
	}
	if m.UidList != nil {
		l = m.UidList.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.SrcFunc != nil {
		l = m.SrcFunc.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Reverse {
		n += 2
	}
	if m.FacetParam != nil {
		l = m.FacetParam.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.FacetsFilter != nil {
		l = m.FacetsFilter.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.ExpandAll {
		n += 2
	}
	if m.ReadTs != 0 {
		n += 1 + sovPb(uint64(m.ReadTs))
	}
	if m.Cache != 0 {
		n += 1 + sovPb(uint64(m.Cache))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValueList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LangList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Lang) > 0 {
		for _, s := range m.Lang {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Result) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UidMatrix) > 0 {
		for _, e := range m.UidMatrix {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.ValueMatrix) > 0 {
		for _, e := range m.ValueMatrix {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.Counts) > 0 {
		l = 0
		for _, e := range m.Counts {
			l += sovPb(uint64(e))
		}
		n += 1 + sovPb(uint64(l)) + l
	}
	if m.IntersectDest {
		n += 2
	}
	if len(m.FacetMatrix) > 0 {
		for _, e := range m.FacetMatrix {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.LangMatrix) > 0 {
		for _, e := range m.LangMatrix {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.List {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Attr)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Desc {
		n += 2
	}
	if len(m.Langs) > 0 {
		for _, s := range m.Langs {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SortMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Order) > 0 {
		for _, e := range m.Order {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.UidMatrix) > 0 {
		for _, e := range m.UidMatrix {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovPb(uint64(m.Count))
	}
	if m.Offset != 0 {
		n += 1 + sovPb(uint64(m.Offset))
	}
	if m.ReadTs != 0 {
		n += 1 + sovPb(uint64(m.ReadTs))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SortResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UidMatrix) > 0 {
		for _, e := range m.UidMatrix {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 9
	}
	if m.Group != 0 {
		n += 1 + sovPb(uint64(m.Group))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.SnapshotTs != 0 {
		n += 1 + sovPb(uint64(m.SnapshotTs))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Member) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 9
	}
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Leader {
		n += 2
	}
	if m.AmDead {
		n += 2
	}
	if m.LastUpdate != 0 {
		n += 1 + sovPb(uint64(m.LastUpdate))
	}
	if m.ClusterInfoOnly {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Group) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Members) > 0 {
		for k, v := range m.Members {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPb(uint64(l))
			}
			mapEntrySize := 1 + sovPb(uint64(k)) + l
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	if len(m.Tablets) > 0 {
		for k, v := range m.Tablets {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPb(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPb(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	if m.SnapshotTs != 0 {
		n += 1 + sovPb(uint64(m.SnapshotTs))
	}
	if m.Checksum != 0 {
		n += 1 + sovPb(uint64(m.Checksum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZeroProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SnapshotTs) > 0 {
		for k, v := range m.SnapshotTs {
			_ = k
			_ = v
			mapEntrySize := 1 + sovPb(uint64(k)) + 1 + sovPb(uint64(v))
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	if m.Member != nil {
		l = m.Member.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Tablet != nil {
		l = m.Tablet.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.MaxLeaseId != 0 {
		n += 1 + sovPb(uint64(m.MaxLeaseId))
	}
	if m.MaxTxnTs != 0 {
		n += 1 + sovPb(uint64(m.MaxTxnTs))
	}
	if m.MaxRaftId != 0 {
		n += 1 + sovPb(uint64(m.MaxRaftId))
	}
	if m.Txn != nil {
		l = m.Txn.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MembershipState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Counter != 0 {
		n += 1 + sovPb(uint64(m.Counter))
	}
	if len(m.Groups) > 0 {
		for k, v := range m.Groups {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPb(uint64(l))
			}
			mapEntrySize := 1 + sovPb(uint64(k)) + l
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	if len(m.Zeros) > 0 {
		for k, v := range m.Zeros {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPb(uint64(l))
			}
			mapEntrySize := 1 + sovPb(uint64(k)) + l
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	if m.MaxLeaseId != 0 {
		n += 1 + sovPb(uint64(m.MaxLeaseId))
	}
	if m.MaxTxnTs != 0 {
		n += 1 + sovPb(uint64(m.MaxTxnTs))
	}
	if m.MaxRaftId != 0 {
		n += 1 + sovPb(uint64(m.MaxRaftId))
	}
	if len(m.Removed) > 0 {
		for _, e := range m.Removed {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectionState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Member != nil {
		l = m.Member.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.MaxPending != 0 {
		n += 1 + sovPb(uint64(m.MaxPending))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tablet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	l = len(m.Predicate)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Force {
		n += 2
	}
	if m.Space != 0 {
		n += 1 + sovPb(uint64(m.Space))
	}
	if m.Remove {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DirectedEdge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Entity != 0 {
		n += 9
	}
	l = len(m.Attr)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.ValueType != 0 {
		n += 1 + sovPb(uint64(m.ValueType))
	}
	if m.ValueId != 0 {
		n += 9
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Lang)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovPb(uint64(m.Op))
	}
	if len(m.Facets) > 0 {
		for _, e := range m.Facets {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Mutations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	if m.StartTs != 0 {
		n += 1 + sovPb(uint64(m.StartTs))
	}
	if len(m.Edges) > 0 {
		for _, e := range m.Edges {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.Schema) > 0 {
		for _, e := range m.Schema {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.DropAll {
		n += 2
	}
	if m.IgnoreIndexConflict {
		n += 2
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Snapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovPb(uint64(m.Index))
	}
	if m.ReadTs != 0 {
		n += 1 + sovPb(uint64(m.ReadTs))
	}
	if m.Done {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Proposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mutations != nil {
		l = m.Mutations.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Kv) > 0 {
		for _, e := range m.Kv {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.CleanPredicate)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Delta != nil {
		l = m.Delta.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Snapshot != nil {
		l = m.Snapshot.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovPb(uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KVS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Kv) > 0 {
		for _, e := range m.Kv {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.Done {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Posting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 9
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.ValType != 0 {
		n += 1 + sovPb(uint64(m.ValType))
	}
	if m.PostingType != 0 {
		n += 1 + sovPb(uint64(m.PostingType))
	}
	l = len(m.LangTag)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Facets) > 0 {
		for _, e := range m.Facets {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.Op != 0 {
		n += 1 + sovPb(uint64(m.Op))
	}
	if m.StartTs != 0 {
		n += 1 + sovPb(uint64(m.StartTs))
	}
	if m.CommitTs != 0 {
		n += 1 + sovPb(uint64(m.CommitTs))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UidBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != 0 {
		n += 1 + sovPb(uint64(m.Base))
	}
	l = len(m.Deltas)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UidPack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockSize != 0 {
		n += 1 + sovPb(uint64(m.BlockSize))
	}
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PostingList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pack != nil {
		l = m.Pack.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Postings) > 0 {
		for _, e := range m.Postings {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.CommitTs != 0 {
		n += 1 + sovPb(uint64(m.CommitTs))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FacetParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Alias)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FacetParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllKeys {
		n += 2
	}
	if len(m.Param) > 0 {
		for _, e := range m.Param {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Facets) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Facets) > 0 {
		for _, e := range m.Facets {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FacetsList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FacetsList) > 0 {
		for _, e := range m.FacetsList {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Function) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FilterTree) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Op)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.Func != nil {
		l = m.Func.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SchemaRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	if len(m.Predicates) > 0 {
		for _, s := range m.Predicates {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.Types) > 0 {
		for _, s := range m.Types {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SchemaResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Schema) > 0 {
		for _, e := range m.Schema {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SchemaUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Predicate)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.ValueType != 0 {
		n += 1 + sovPb(uint64(m.ValueType))
	}
	if m.Directive != 0 {
		n += 1 + sovPb(uint64(m.Directive))
	}
	if len(m.Tokenizer) > 0 {
		for _, s := range m.Tokenizer {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.Count {
		n += 2
	}
	if m.List {
		n += 2
	}
	if m.Upsert {
		n += 2
	}
	if m.Lang {
		n += 2
	}
	if m.NonNullable {
		n += 2
	}
	if m.NonNullableList {
		n += 2
	}
	l = len(m.ObjectTypeName)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TypeUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TypeName)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MapEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Uid != 0 {
		n += 9
	}
	if m.Posting != nil {
		l = m.Posting.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MovePredicatePayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Predicate)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.SourceGid != 0 {
		n += 1 + sovPb(uint64(m.SourceGid))
	}
	if m.DestGid != 0 {
		n += 1 + sovPb(uint64(m.DestGid))
	}
	if m.TxnTs != 0 {
		n += 1 + sovPb(uint64(m.TxnTs))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartTs != 0 {
		n += 1 + sovPb(uint64(m.StartTs))
	}
	if m.CommitTs != 0 {
		n += 1 + sovPb(uint64(m.CommitTs))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OracleDelta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Txns) > 0 {
		for _, e := range m.Txns {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.MaxAssigned != 0 {
		n += 1 + sovPb(uint64(m.MaxAssigned))
	}
	if len(m.GroupChecksums) > 0 {
		for k, v := range m.GroupChecksums {
			_ = k
			_ = v
			mapEntrySize := 1 + sovPb(uint64(k)) + 1 + sovPb(uint64(v))
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnTimestamps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ts) > 0 {
		l = 0
		for _, e := range m.Ts {
			l += sovPb(uint64(e))
		}
		n += 1 + sovPb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PeerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Num) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Val != 0 {
		n += 1 + sovPb(uint64(m.Val))
	}
	if m.ReadOnly {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AssignedIds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartId != 0 {
		n += 1 + sovPb(uint64(m.StartId))
	}
	if m.EndId != 0 {
		n += 1 + sovPb(uint64(m.EndId))
	}
	if m.ReadOnly != 0 {
		n += 1 + sovPb(uint64(m.ReadOnly))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SnapshotMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientTs != 0 {
		n += 1 + sovPb(uint64(m.ClientTs))
	}
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovPb(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BackupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReadTs != 0 {
		n += 1 + sovPb(uint64(m.ReadTs))
	}
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	l = len(m.UnixTs)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExportRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	if m.ReadTs != 0 {
		n += 1 + sovPb(uint64(m.ReadTs))
	}
	if m.UnixTs != 0 {
		n += 1 + sovPb(uint64(m.UnixTs))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPb(x uint64) (n int) {
	return sovPb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.Uids = append(m.Uids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Uids) == 0 {
					m.Uids = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.Uids = append(m.Uids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = append(m.Val[:0], dAtA[iNdEx:postIndex]...)
			if m.Val == nil {
				m.Val = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValType", wireType)
			}
			m.ValType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValType |= (Posting_ValType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SrcFunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SrcFunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SrcFunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCount", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCount = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Query) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Query: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Query: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Langs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Langs = append(m.Langs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterUid", wireType)
			}
			m.AfterUid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AfterUid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoCount", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DoCount = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UidList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UidList == nil {
				m.UidList = &List{}
			}
			if err := m.UidList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcFunc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcFunc == nil {
				m.SrcFunc = &SrcFunction{}
			}
			if err := m.SrcFunc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FacetParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FacetParam == nil {
				m.FacetParam = &FacetParams{}
			}
			if err := m.FacetParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FacetsFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FacetsFilter == nil {
				m.FacetsFilter = &FilterTree{}
			}
			if err := m.FacetsFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpandAll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExpandAll = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTs", wireType)
			}
			m.ReadTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cache", wireType)
			}
			m.Cache = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cache |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValueList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &TaskValue{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LangList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LangList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LangList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lang", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lang = append(m.Lang, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UidMatrix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UidMatrix = append(m.UidMatrix, &List{})
			if err := m.UidMatrix[len(m.UidMatrix)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueMatrix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueMatrix = append(m.ValueMatrix, &ValueList{})
			if err := m.ValueMatrix[len(m.ValueMatrix)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Counts = append(m.Counts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Counts) == 0 {
					m.Counts = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Counts = append(m.Counts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Counts", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntersectDest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IntersectDest = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FacetMatrix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FacetMatrix = append(m.FacetMatrix, &FacetsList{})
			if err := m.FacetMatrix[len(m.FacetMatrix)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangMatrix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangMatrix = append(m.LangMatrix, &LangList{})
			if err := m.LangMatrix[len(m.LangMatrix)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.List = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Desc = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Langs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Langs = append(m.Langs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SortMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SortMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SortMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Order = append(m.Order, &Order{})
			if err := m.Order[len(m.Order)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UidMatrix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UidMatrix = append(m.UidMatrix, &List{})
			if err := m.UidMatrix[len(m.UidMatrix)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTs", wireType)
			}
			m.ReadTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SortResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SortResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SortResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UidMatrix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UidMatrix = append(m.UidMatrix, &List{})
			if err := m.UidMatrix[len(m.UidMatrix)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotTs", wireType)
			}
			m.SnapshotTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapshotTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Leader = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmDead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AmDead = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdate", wireType)
			}
			m.LastUpdate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdate |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterInfoOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClusterInfoOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Group) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Members == nil {
				m.Members = make(map[uint64]*Member)
			}
			var mapkey uint64
			var mapvalue *Member
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPb
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthPb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Member{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Members[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tablets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tablets == nil {
				m.Tablets = make(map[string]*Tablet)
			}
			var mapkey string
			var mapvalue *Tablet
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPb
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthPb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Tablet{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tablets[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotTs", wireType)
			}
			m.SnapshotTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapshotTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SnapshotTs == nil {
				m.SnapshotTs = make(map[uint32]uint64)
			}
			var mapkey uint32
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SnapshotTs[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Member == nil {
				m.Member = &Member{}
			}
			if err := m.Member.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tablet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tablet == nil {
				m.Tablet = &Tablet{}
			}
			if err := m.Tablet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLeaseId", wireType)
			}
			m.MaxLeaseId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLeaseId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTxnTs", wireType)
			}
			m.MaxTxnTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTxnTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRaftId", wireType)
			}
			m.MaxRaftId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRaftId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Txn == nil {
				m.Txn = &api.TxnContext{}
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MembershipState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MembershipState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MembershipState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counter", wireType)
			}
			m.Counter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Counter |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Groups == nil {
				m.Groups = make(map[uint32]*Group)
			}
			var mapkey uint32
			var mapvalue *Group
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPb
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthPb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Group{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Groups[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zeros", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Zeros == nil {
				m.Zeros = make(map[uint64]*Member)
			}
			var mapkey uint64
			var mapvalue *Member
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPb
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthPb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Member{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Zeros[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLeaseId", wireType)
			}
			m.MaxLeaseId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLeaseId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTxnTs", wireType)
			}
			m.MaxTxnTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTxnTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRaftId", wireType)
			}
			m.MaxRaftId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRaftId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Removed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Removed = append(m.Removed, &Member{})
			if err := m.Removed[len(m.Removed)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Member == nil {
				m.Member = &Member{}
			}
			if err := m.Member.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &MembershipState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPending", wireType)
			}
			m.MaxPending = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPending |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tablet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tablet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tablet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Space", wireType)
			}
			m.Space = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Space |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Remove = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectedEdge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectedEdge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectedEdge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entity", wireType)
			}
			m.Entity = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Entity = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueType", wireType)
			}
			m.ValueType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValueType |= (Posting_ValType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueId", wireType)
			}
			m.ValueId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueId = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lang", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lang = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (DirectedEdge_Op(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Facets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Facets = append(m.Facets, &api.Facet{})
			if err := m.Facets[len(m.Facets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mutations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mutations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mutations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Edges = append(m.Edges, &DirectedEdge{})
			if err := m.Edges[len(m.Edges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = append(m.Schema, &SchemaUpdate{})
			if err := m.Schema[len(m.Schema)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropAll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropAll = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreIndexConflict", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreIndexConflict = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, &TypeUpdate{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Snapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Snapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &RaftContext{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTs", wireType)
			}
			m.ReadTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Done = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mutations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mutations == nil {
				m.Mutations = &Mutations{}
			}
			if err := m.Mutations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kv = append(m.Kv, &pb.KV{})
			if err := m.Kv[len(m.Kv)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &MembershipState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CleanPredicate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CleanPredicate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta == nil {
				m.Delta = &OracleDelta{}
			}
			if err := m.Delta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Snapshot == nil {
				m.Snapshot = &Snapshot{}
			}
			if err := m.Snapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kv = append(m.Kv, &pb.KV{})
			if err := m.Kv[len(m.Kv)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Done = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Posting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Posting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Posting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValType", wireType)
			}
			m.ValType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValType |= (Posting_ValType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostingType", wireType)
			}
			m.PostingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PostingType |= (Posting_PostingType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangTag", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangTag = append(m.LangTag[:0], dAtA[iNdEx:postIndex]...)
			if m.LangTag == nil {
				m.LangTag = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Facets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Facets = append(m.Facets, &api.Facet{})
			if err := m.Facets[len(m.Facets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UidBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UidBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UidBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			m.Base = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Base |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deltas", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deltas = append(m.Deltas[:0], dAtA[iNdEx:postIndex]...)
			if m.Deltas == nil {
				m.Deltas = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UidPack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UidPack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UidPack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockSize", wireType)
			}
			m.BlockSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &UidBlock{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PostingList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PostingList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PostingList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pack", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pack == nil {
				m.Pack = &UidPack{}
			}
			if err := m.Pack.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Postings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Postings = append(m.Postings, &Posting{})
			if err := m.Postings[len(m.Postings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FacetParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FacetParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FacetParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alias = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FacetParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FacetParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FacetParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllKeys", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllKeys = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param = append(m.Param, &FacetParam{})
			if err := m.Param[len(m.Param)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Facets) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Facets: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Facets: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Facets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Facets = append(m.Facets, &api.Facet{})
			if err := m.Facets[len(m.Facets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FacetsList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FacetsList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FacetsList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FacetsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FacetsList = append(m.FacetsList, &Facets{})
			if err := m.FacetsList[len(m.FacetsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Function) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Function: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Function: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterTree) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterTree: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterTree: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Op = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &FilterTree{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Func", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Func == nil {
				m.Func = &Function{}
			}
			if err := m.Func.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicates", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicates = append(m.Predicates, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = append(m.Schema, &api.SchemaNode{})
			if err := m.Schema[len(m.Schema)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueType", wireType)
			}
			m.ValueType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValueType |= (Posting_ValType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Directive", wireType)
			}
			m.Directive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Directive |= (SchemaUpdate_Directive(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokenizer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tokenizer = append(m.Tokenizer, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.List = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upsert", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Upsert = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lang", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lang = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonNullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NonNullable = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonNullableList", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NonNullableList = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectTypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectTypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, &SchemaUpdate{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MapEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Posting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Posting == nil {
				m.Posting = &Posting{}
			}
			if err := m.Posting.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MovePredicatePayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MovePredicatePayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MovePredicatePayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceGid", wireType)
			}
			m.SourceGid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceGid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestGid", wireType)
			}
			m.DestGid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestGid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnTs", wireType)
			}
			m.TxnTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleDelta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleDelta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleDelta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txns = append(m.Txns, &TxnStatus{})
			if err := m.Txns[len(m.Txns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAssigned", wireType)
			}
			m.MaxAssigned = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAssigned |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupChecksums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupChecksums == nil {
				m.GroupChecksums = make(map[uint32]uint64)
			}
			var mapkey uint32
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.GroupChecksums[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnTimestamps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnTimestamps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnTimestamps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ts = append(m.Ts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ts) == 0 {
					m.Ts = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ts = append(m.Ts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &RaftContext{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &api.Payload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Num) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Num: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Num: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			m.Val = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Val |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssignedIds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssignedIds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssignedIds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartId", wireType)
			}
			m.StartId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndId", wireType)
			}
			m.EndId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			m.ReadOnly = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadOnly |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientTs", wireType)
			}
			m.ClientTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTs", wireType)
			}
			m.ReadTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnixTs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnixTs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTs", wireType)
			}
			m.ReadTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnixTs", wireType)
			}
			m.UnixTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnixTs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPb   = fmt.Errorf("proto: integer overflow")
)
