// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pb.proto

package pb

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	pb "github.com/dgraph-io/badger/v3/pb"
	api "github.com/dgraph-io/dgo/v200/protos/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type DirectedEdge_Op int32

const (
	DirectedEdge_SET DirectedEdge_Op = 0
	DirectedEdge_DEL DirectedEdge_Op = 1
)

var DirectedEdge_Op_name = map[int32]string{
	0: "SET",
	1: "DEL",
}

var DirectedEdge_Op_value = map[string]int32{
	"SET": 0,
	"DEL": 1,
}

func (x DirectedEdge_Op) String() string {
	return proto.EnumName(DirectedEdge_Op_name, int32(x))
}

func (DirectedEdge_Op) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{19, 0}
}

type Mutations_DropOp int32

const (
	Mutations_NONE Mutations_DropOp = 0
	Mutations_ALL  Mutations_DropOp = 1
	Mutations_DATA Mutations_DropOp = 2
	Mutations_TYPE Mutations_DropOp = 3
)

var Mutations_DropOp_name = map[int32]string{
	0: "NONE",
	1: "ALL",
	2: "DATA",
	3: "TYPE",
}

var Mutations_DropOp_value = map[string]int32{
	"NONE": 0,
	"ALL":  1,
	"DATA": 2,
	"TYPE": 3,
}

func (x Mutations_DropOp) String() string {
	return proto.EnumName(Mutations_DropOp_name, int32(x))
}

func (Mutations_DropOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{20, 0}
}

// HintType represents a hint that will be passed along the mutation and used
// to add the predicate to the schema if it's not already there.
type Metadata_HintType int32

const (
	// DEFAULT means no hint is provided and Dgraph will follow the default behavior.
	Metadata_DEFAULT Metadata_HintType = 0
	// SINGLE signals that the predicate should be created as a single type (e.g string, uid).
	Metadata_SINGLE Metadata_HintType = 1
	// LIST signals that the predicate should be created as a list (e.g [string], [uid]).
	Metadata_LIST Metadata_HintType = 2
)

var Metadata_HintType_name = map[int32]string{
	0: "DEFAULT",
	1: "SINGLE",
	2: "LIST",
}

var Metadata_HintType_value = map[string]int32{
	"DEFAULT": 0,
	"SINGLE":  1,
	"LIST":    2,
}

func (x Metadata_HintType) String() string {
	return proto.EnumName(Metadata_HintType_name, int32(x))
}

func (Metadata_HintType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{21, 0}
}

type Posting_ValType int32

const (
	Posting_DEFAULT  Posting_ValType = 0
	Posting_BINARY   Posting_ValType = 1
	Posting_INT      Posting_ValType = 2
	Posting_FLOAT    Posting_ValType = 3
	Posting_BOOL     Posting_ValType = 4
	Posting_DATETIME Posting_ValType = 5
	Posting_GEO      Posting_ValType = 6
	Posting_UID      Posting_ValType = 7
	Posting_PASSWORD Posting_ValType = 8
	Posting_STRING   Posting_ValType = 9
	Posting_OBJECT   Posting_ValType = 10
)

var Posting_ValType_name = map[int32]string{
	0:  "DEFAULT",
	1:  "BINARY",
	2:  "INT",
	3:  "FLOAT",
	4:  "BOOL",
	5:  "DATETIME",
	6:  "GEO",
	7:  "UID",
	8:  "PASSWORD",
	9:  "STRING",
	10: "OBJECT",
}

var Posting_ValType_value = map[string]int32{
	"DEFAULT":  0,
	"BINARY":   1,
	"INT":      2,
	"FLOAT":    3,
	"BOOL":     4,
	"DATETIME": 5,
	"GEO":      6,
	"UID":      7,
	"PASSWORD": 8,
	"STRING":   9,
	"OBJECT":   10,
}

func (x Posting_ValType) String() string {
	return proto.EnumName(Posting_ValType_name, int32(x))
}

func (Posting_ValType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{27, 0}
}

type Posting_PostingType int32

const (
	Posting_REF        Posting_PostingType = 0
	Posting_VALUE      Posting_PostingType = 1
	Posting_VALUE_LANG Posting_PostingType = 2
)

var Posting_PostingType_name = map[int32]string{
	0: "REF",
	1: "VALUE",
	2: "VALUE_LANG",
}

var Posting_PostingType_value = map[string]int32{
	"REF":        0,
	"VALUE":      1,
	"VALUE_LANG": 2,
}

func (x Posting_PostingType) String() string {
	return proto.EnumName(Posting_PostingType_name, int32(x))
}

func (Posting_PostingType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{27, 1}
}

type SchemaUpdate_Directive int32

const (
	SchemaUpdate_NONE    SchemaUpdate_Directive = 0
	SchemaUpdate_INDEX   SchemaUpdate_Directive = 1
	SchemaUpdate_REVERSE SchemaUpdate_Directive = 2
	SchemaUpdate_DELETE  SchemaUpdate_Directive = 3
)

var SchemaUpdate_Directive_name = map[int32]string{
	0: "NONE",
	1: "INDEX",
	2: "REVERSE",
	3: "DELETE",
}

var SchemaUpdate_Directive_value = map[string]int32{
	"NONE":    0,
	"INDEX":   1,
	"REVERSE": 2,
	"DELETE":  3,
}

func (x SchemaUpdate_Directive) String() string {
	return proto.EnumName(SchemaUpdate_Directive_name, int32(x))
}

func (SchemaUpdate_Directive) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{40, 0}
}

type NumLeaseType int32

const (
	Num_NS_ID  NumLeaseType = 0
	Num_UID    NumLeaseType = 1
	Num_TXN_TS NumLeaseType = 2
)

var NumLeaseType_name = map[int32]string{
	0: "NS_ID",
	1: "UID",
	2: "TXN_TS",
}

var NumLeaseType_value = map[string]int32{
	"NS_ID":  0,
	"UID":    1,
	"TXN_TS": 2,
}

func (x NumLeaseType) String() string {
	return proto.EnumName(NumLeaseType_name, int32(x))
}

func (NumLeaseType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{51, 0}
}

type DropOperation_DropOp int32

const (
	DropOperation_ALL  DropOperation_DropOp = 0
	DropOperation_DATA DropOperation_DropOp = 1
	DropOperation_ATTR DropOperation_DropOp = 2
)

var DropOperation_DropOp_name = map[int32]string{
	0: "ALL",
	1: "DATA",
	2: "ATTR",
}

var DropOperation_DropOp_value = map[string]int32{
	"ALL":  0,
	"DATA": 1,
	"ATTR": 2,
}

func (x DropOperation_DropOp) String() string {
	return proto.EnumName(DropOperation_DropOp_name, int32(x))
}

func (DropOperation_DropOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{57, 0}
}

type BackupKey_KeyType int32

const (
	BackupKey_UNKNOWN   BackupKey_KeyType = 0
	BackupKey_DATA      BackupKey_KeyType = 1
	BackupKey_INDEX     BackupKey_KeyType = 2
	BackupKey_REVERSE   BackupKey_KeyType = 3
	BackupKey_COUNT     BackupKey_KeyType = 4
	BackupKey_COUNT_REV BackupKey_KeyType = 5
	BackupKey_SCHEMA    BackupKey_KeyType = 6
	BackupKey_TYPE      BackupKey_KeyType = 7
)

var BackupKey_KeyType_name = map[int32]string{
	0: "UNKNOWN",
	1: "DATA",
	2: "INDEX",
	3: "REVERSE",
	4: "COUNT",
	5: "COUNT_REV",
	6: "SCHEMA",
	7: "TYPE",
}

var BackupKey_KeyType_value = map[string]int32{
	"UNKNOWN":   0,
	"DATA":      1,
	"INDEX":     2,
	"REVERSE":   3,
	"COUNT":     4,
	"COUNT_REV": 5,
	"SCHEMA":    6,
	"TYPE":      7,
}

func (x BackupKey_KeyType) String() string {
	return proto.EnumName(BackupKey_KeyType_name, int32(x))
}

func (BackupKey_KeyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{60, 0}
}

type List struct {
	Uids []uint64 `protobuf:"fixed64,1,rep,packed,name=uids,proto3" json:"uids,omitempty"`
}

func (m *List) Reset()         { *m = List{} }
func (m *List) String() string { return proto.CompactTextString(m) }
func (*List) ProtoMessage()    {}
func (*List) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0}
}
func (m *List) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *List) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_List.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *List) XXX_Merge(src proto.Message) {
	xxx_messageInfo_List.Merge(m, src)
}
func (m *List) XXX_Size() int {
	return m.Size()
}
func (m *List) XXX_DiscardUnknown() {
	xxx_messageInfo_List.DiscardUnknown(m)
}

var xxx_messageInfo_List proto.InternalMessageInfo

func (m *List) GetUids() []uint64 {
	if m != nil {
		return m.Uids
	}
	return nil
}

type TaskValue struct {
	Val     []byte          `protobuf:"bytes,1,opt,name=val,proto3" json:"val,omitempty"`
	ValType Posting_ValType `protobuf:"varint,2,opt,name=val_type,json=valType,proto3,enum=pb.Posting_ValType" json:"val_type,omitempty"`
}

func (m *TaskValue) Reset()         { *m = TaskValue{} }
func (m *TaskValue) String() string { return proto.CompactTextString(m) }
func (*TaskValue) ProtoMessage()    {}
func (*TaskValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{1}
}
func (m *TaskValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskValue.Merge(m, src)
}
func (m *TaskValue) XXX_Size() int {
	return m.Size()
}
func (m *TaskValue) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskValue.DiscardUnknown(m)
}

var xxx_messageInfo_TaskValue proto.InternalMessageInfo

func (m *TaskValue) GetVal() []byte {
	if m != nil {
		return m.Val
	}
	return nil
}

func (m *TaskValue) GetValType() Posting_ValType {
	if m != nil {
		return m.ValType
	}
	return Posting_DEFAULT
}

type SrcFunction struct {
	Name    string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Args    []string `protobuf:"bytes,3,rep,name=args,proto3" json:"args,omitempty"`
	IsCount bool     `protobuf:"varint,4,opt,name=isCount,proto3" json:"isCount,omitempty"`
}

func (m *SrcFunction) Reset()         { *m = SrcFunction{} }
func (m *SrcFunction) String() string { return proto.CompactTextString(m) }
func (*SrcFunction) ProtoMessage()    {}
func (*SrcFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{2}
}
func (m *SrcFunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SrcFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SrcFunction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SrcFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SrcFunction.Merge(m, src)
}
func (m *SrcFunction) XXX_Size() int {
	return m.Size()
}
func (m *SrcFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_SrcFunction.DiscardUnknown(m)
}

var xxx_messageInfo_SrcFunction proto.InternalMessageInfo

func (m *SrcFunction) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SrcFunction) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *SrcFunction) GetIsCount() bool {
	if m != nil {
		return m.IsCount
	}
	return false
}

type Query struct {
	Attr     string   `protobuf:"bytes,1,opt,name=attr,proto3" json:"attr,omitempty"`
	Langs    []string `protobuf:"bytes,2,rep,name=langs,proto3" json:"langs,omitempty"`
	AfterUid uint64   `protobuf:"fixed64,3,opt,name=after_uid,json=afterUid,proto3" json:"after_uid,omitempty"`
	DoCount  bool     `protobuf:"varint,4,opt,name=do_count,json=doCount,proto3" json:"do_count,omitempty"`
	// Exactly one of uids and terms is populated.
	UidList *List `protobuf:"bytes,5,opt,name=uid_list,json=uidList,proto3" json:"uid_list,omitempty"`
	// Function to generate or filter UIDs.
	SrcFunc      *SrcFunction `protobuf:"bytes,6,opt,name=src_func,json=srcFunc,proto3" json:"src_func,omitempty"`
	Reverse      bool         `protobuf:"varint,7,opt,name=reverse,proto3" json:"reverse,omitempty"`
	FacetParam   *FacetParams `protobuf:"bytes,8,opt,name=facet_param,json=facetParam,proto3" json:"facet_param,omitempty"`
	FacetsFilter *FilterTree  `protobuf:"bytes,9,opt,name=facets_filter,json=facetsFilter,proto3" json:"facets_filter,omitempty"`
	ExpandAll    bool         `protobuf:"varint,10,opt,name=expand_all,json=expandAll,proto3" json:"expand_all,omitempty"`
	ReadTs       uint64       `protobuf:"varint,13,opt,name=read_ts,json=readTs,proto3" json:"read_ts,omitempty"`
	Cache        int32        `protobuf:"varint,14,opt,name=cache,proto3" json:"cache,omitempty"`
	First        int32        `protobuf:"varint,15,opt,name=first,proto3" json:"first,omitempty"`
}

func (m *Query) Reset()         { *m = Query{} }
func (m *Query) String() string { return proto.CompactTextString(m) }
func (*Query) ProtoMessage()    {}
func (*Query) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{3}
}
func (m *Query) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Query) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Query.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Query) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Query.Merge(m, src)
}
func (m *Query) XXX_Size() int {
	return m.Size()
}
func (m *Query) XXX_DiscardUnknown() {
	xxx_messageInfo_Query.DiscardUnknown(m)
}

var xxx_messageInfo_Query proto.InternalMessageInfo

func (m *Query) GetAttr() string {
	if m != nil {
		return m.Attr
	}
	return ""
}

func (m *Query) GetLangs() []string {
	if m != nil {
		return m.Langs
	}
	return nil
}

func (m *Query) GetAfterUid() uint64 {
	if m != nil {
		return m.AfterUid
	}
	return 0
}

func (m *Query) GetDoCount() bool {
	if m != nil {
		return m.DoCount
	}
	return false
}

func (m *Query) GetUidList() *List {
	if m != nil {
		return m.UidList
	}
	return nil
}

func (m *Query) GetSrcFunc() *SrcFunction {
	if m != nil {
		return m.SrcFunc
	}
	return nil
}

func (m *Query) GetReverse() bool {
	if m != nil {
		return m.Reverse
	}
	return false
}

func (m *Query) GetFacetParam() *FacetParams {
	if m != nil {
		return m.FacetParam
	}
	return nil
}

func (m *Query) GetFacetsFilter() *FilterTree {
	if m != nil {
		return m.FacetsFilter
	}
	return nil
}

func (m *Query) GetExpandAll() bool {
	if m != nil {
		return m.ExpandAll
	}
	return false
}

func (m *Query) GetReadTs() uint64 {
	if m != nil {
		return m.ReadTs
	}
	return 0
}

func (m *Query) GetCache() int32 {
	if m != nil {
		return m.Cache
	}
	return 0
}

func (m *Query) GetFirst() int32 {
	if m != nil {
		return m.First
	}
	return 0
}

type ValueList struct {
	Values []*TaskValue `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
}

func (m *ValueList) Reset()         { *m = ValueList{} }
func (m *ValueList) String() string { return proto.CompactTextString(m) }
func (*ValueList) ProtoMessage()    {}
func (*ValueList) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{4}
}
func (m *ValueList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValueList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValueList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValueList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValueList.Merge(m, src)
}
func (m *ValueList) XXX_Size() int {
	return m.Size()
}
func (m *ValueList) XXX_DiscardUnknown() {
	xxx_messageInfo_ValueList.DiscardUnknown(m)
}

var xxx_messageInfo_ValueList proto.InternalMessageInfo

func (m *ValueList) GetValues() []*TaskValue {
	if m != nil {
		return m.Values
	}
	return nil
}

type LangList struct {
	Lang []string `protobuf:"bytes,1,rep,name=lang,proto3" json:"lang,omitempty"`
}

func (m *LangList) Reset()         { *m = LangList{} }
func (m *LangList) String() string { return proto.CompactTextString(m) }
func (*LangList) ProtoMessage()    {}
func (*LangList) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{5}
}
func (m *LangList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LangList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LangList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LangList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LangList.Merge(m, src)
}
func (m *LangList) XXX_Size() int {
	return m.Size()
}
func (m *LangList) XXX_DiscardUnknown() {
	xxx_messageInfo_LangList.DiscardUnknown(m)
}

var xxx_messageInfo_LangList proto.InternalMessageInfo

func (m *LangList) GetLang() []string {
	if m != nil {
		return m.Lang
	}
	return nil
}

type Result struct {
	UidMatrix     []*List       `protobuf:"bytes,1,rep,name=uid_matrix,json=uidMatrix,proto3" json:"uid_matrix,omitempty"`
	ValueMatrix   []*ValueList  `protobuf:"bytes,2,rep,name=value_matrix,json=valueMatrix,proto3" json:"value_matrix,omitempty"`
	Counts        []uint32      `protobuf:"varint,3,rep,packed,name=counts,proto3" json:"counts,omitempty"`
	IntersectDest bool          `protobuf:"varint,4,opt,name=intersect_dest,json=intersectDest,proto3" json:"intersect_dest,omitempty"`
	FacetMatrix   []*FacetsList `protobuf:"bytes,5,rep,name=facet_matrix,json=facetMatrix,proto3" json:"facet_matrix,omitempty"`
	LangMatrix    []*LangList   `protobuf:"bytes,6,rep,name=lang_matrix,json=langMatrix,proto3" json:"lang_matrix,omitempty"`
	List          bool          `protobuf:"varint,7,opt,name=list,proto3" json:"list,omitempty"`
}

func (m *Result) Reset()         { *m = Result{} }
func (m *Result) String() string { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()    {}
func (*Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{6}
}
func (m *Result) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Result.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Result.Merge(m, src)
}
func (m *Result) XXX_Size() int {
	return m.Size()
}
func (m *Result) XXX_DiscardUnknown() {
	xxx_messageInfo_Result.DiscardUnknown(m)
}

var xxx_messageInfo_Result proto.InternalMessageInfo

func (m *Result) GetUidMatrix() []*List {
	if m != nil {
		return m.UidMatrix
	}
	return nil
}

func (m *Result) GetValueMatrix() []*ValueList {
	if m != nil {
		return m.ValueMatrix
	}
	return nil
}

func (m *Result) GetCounts() []uint32 {
	if m != nil {
		return m.Counts
	}
	return nil
}

func (m *Result) GetIntersectDest() bool {
	if m != nil {
		return m.IntersectDest
	}
	return false
}

func (m *Result) GetFacetMatrix() []*FacetsList {
	if m != nil {
		return m.FacetMatrix
	}
	return nil
}

func (m *Result) GetLangMatrix() []*LangList {
	if m != nil {
		return m.LangMatrix
	}
	return nil
}

func (m *Result) GetList() bool {
	if m != nil {
		return m.List
	}
	return false
}

type Order struct {
	Attr  string   `protobuf:"bytes,1,opt,name=attr,proto3" json:"attr,omitempty"`
	Desc  bool     `protobuf:"varint,2,opt,name=desc,proto3" json:"desc,omitempty"`
	Langs []string `protobuf:"bytes,3,rep,name=langs,proto3" json:"langs,omitempty"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{7}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetAttr() string {
	if m != nil {
		return m.Attr
	}
	return ""
}

func (m *Order) GetDesc() bool {
	if m != nil {
		return m.Desc
	}
	return false
}

func (m *Order) GetLangs() []string {
	if m != nil {
		return m.Langs
	}
	return nil
}

type SortMessage struct {
	Order     []*Order `protobuf:"bytes,1,rep,name=order,proto3" json:"order,omitempty"`
	UidMatrix []*List  `protobuf:"bytes,2,rep,name=uid_matrix,json=uidMatrix,proto3" json:"uid_matrix,omitempty"`
	Count     int32    `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty"`
	Offset    int32    `protobuf:"varint,4,opt,name=offset,proto3" json:"offset,omitempty"`
	ReadTs    uint64   `protobuf:"varint,13,opt,name=read_ts,json=readTs,proto3" json:"read_ts,omitempty"`
}

func (m *SortMessage) Reset()         { *m = SortMessage{} }
func (m *SortMessage) String() string { return proto.CompactTextString(m) }
func (*SortMessage) ProtoMessage()    {}
func (*SortMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{8}
}
func (m *SortMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SortMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SortMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SortMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SortMessage.Merge(m, src)
}
func (m *SortMessage) XXX_Size() int {
	return m.Size()
}
func (m *SortMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_SortMessage.DiscardUnknown(m)
}

var xxx_messageInfo_SortMessage proto.InternalMessageInfo

func (m *SortMessage) GetOrder() []*Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *SortMessage) GetUidMatrix() []*List {
	if m != nil {
		return m.UidMatrix
	}
	return nil
}

func (m *SortMessage) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *SortMessage) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *SortMessage) GetReadTs() uint64 {
	if m != nil {
		return m.ReadTs
	}
	return 0
}

type SortResult struct {
	UidMatrix []*List `protobuf:"bytes,1,rep,name=uid_matrix,json=uidMatrix,proto3" json:"uid_matrix,omitempty"`
}

func (m *SortResult) Reset()         { *m = SortResult{} }
func (m *SortResult) String() string { return proto.CompactTextString(m) }
func (*SortResult) ProtoMessage()    {}
func (*SortResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{9}
}
func (m *SortResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SortResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SortResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SortResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SortResult.Merge(m, src)
}
func (m *SortResult) XXX_Size() int {
	return m.Size()
}
func (m *SortResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SortResult.DiscardUnknown(m)
}

var xxx_messageInfo_SortResult proto.InternalMessageInfo

func (m *SortResult) GetUidMatrix() []*List {
	if m != nil {
		return m.UidMatrix
	}
	return nil
}

type RaftContext struct {
	Id         uint64 `protobuf:"fixed64,1,opt,name=id,proto3" json:"id,omitempty"`
	Group      uint32 `protobuf:"varint,2,opt,name=group,proto3" json:"group,omitempty"`
	Addr       string `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
	SnapshotTs uint64 `protobuf:"varint,4,opt,name=snapshot_ts,json=snapshotTs,proto3" json:"snapshot_ts,omitempty"`
	IsLearner  bool   `protobuf:"varint,5,opt,name=is_learner,json=isLearner,proto3" json:"is_learner,omitempty"`
}

func (m *RaftContext) Reset()         { *m = RaftContext{} }
func (m *RaftContext) String() string { return proto.CompactTextString(m) }
func (*RaftContext) ProtoMessage()    {}
func (*RaftContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{10}
}
func (m *RaftContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftContext.Merge(m, src)
}
func (m *RaftContext) XXX_Size() int {
	return m.Size()
}
func (m *RaftContext) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftContext.DiscardUnknown(m)
}

var xxx_messageInfo_RaftContext proto.InternalMessageInfo

func (m *RaftContext) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RaftContext) GetGroup() uint32 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *RaftContext) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *RaftContext) GetSnapshotTs() uint64 {
	if m != nil {
		return m.SnapshotTs
	}
	return 0
}

func (m *RaftContext) GetIsLearner() bool {
	if m != nil {
		return m.IsLearner
	}
	return false
}

// Member stores information about RAFT group member for a single RAFT node.
// Note that each server can be serving multiple RAFT groups. Each group would have
// one RAFT node per server serving that group.
type Member struct {
	Id              uint64 `protobuf:"fixed64,1,opt,name=id,proto3" json:"id,omitempty"`
	GroupId         uint32 `protobuf:"varint,2,opt,name=group_id,json=groupId,proto3" json:"groupId,omitempty"`
	Addr            string `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
	Leader          bool   `protobuf:"varint,4,opt,name=leader,proto3" json:"leader,omitempty"`
	AmDead          bool   `protobuf:"varint,5,opt,name=am_dead,json=amDead,proto3" json:"amDead,omitempty"`
	LastUpdate      uint64 `protobuf:"varint,6,opt,name=last_update,json=lastUpdate,proto3" json:"lastUpdate,omitempty"`
	Learner         bool   `protobuf:"varint,7,opt,name=learner,proto3" json:"learner,omitempty"`
	ClusterInfoOnly bool   `protobuf:"varint,13,opt,name=cluster_info_only,json=clusterInfoOnly,proto3" json:"clusterInfoOnly,omitempty"`
	ForceGroupId    bool   `protobuf:"varint,14,opt,name=force_group_id,json=forceGroupId,proto3" json:"forceGroupId,omitempty"`
}

func (m *Member) Reset()         { *m = Member{} }
func (m *Member) String() string { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()    {}
func (*Member) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{11}
}
func (m *Member) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Member) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Member.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Member) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Member.Merge(m, src)
}
func (m *Member) XXX_Size() int {
	return m.Size()
}
func (m *Member) XXX_DiscardUnknown() {
	xxx_messageInfo_Member.DiscardUnknown(m)
}

var xxx_messageInfo_Member proto.InternalMessageInfo

func (m *Member) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Member) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *Member) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *Member) GetLeader() bool {
	if m != nil {
		return m.Leader
	}
	return false
}

func (m *Member) GetAmDead() bool {
	if m != nil {
		return m.AmDead
	}
	return false
}

func (m *Member) GetLastUpdate() uint64 {
	if m != nil {
		return m.LastUpdate
	}
	return 0
}

func (m *Member) GetLearner() bool {
	if m != nil {
		return m.Learner
	}
	return false
}

func (m *Member) GetClusterInfoOnly() bool {
	if m != nil {
		return m.ClusterInfoOnly
	}
	return false
}

func (m *Member) GetForceGroupId() bool {
	if m != nil {
		return m.ForceGroupId
	}
	return false
}

type Group struct {
	Members      map[uint64]*Member `protobuf:"bytes,1,rep,name=members,proto3" json:"members,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Tablets      map[string]*Tablet `protobuf:"bytes,2,rep,name=tablets,proto3" json:"tablets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	SnapshotTs   uint64             `protobuf:"varint,3,opt,name=snapshot_ts,json=snapshotTs,proto3" json:"snapshot_ts,omitempty"`
	Checksum     uint64             `protobuf:"varint,4,opt,name=checksum,proto3" json:"checksum,omitempty"`
	CheckpointTs uint64             `protobuf:"varint,5,opt,name=checkpoint_ts,json=checkpointTs,proto3" json:"checkpoint_ts,omitempty"`
}

func (m *Group) Reset()         { *m = Group{} }
func (m *Group) String() string { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()    {}
func (*Group) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{12}
}
func (m *Group) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Group) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Group.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Group) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Group.Merge(m, src)
}
func (m *Group) XXX_Size() int {
	return m.Size()
}
func (m *Group) XXX_DiscardUnknown() {
	xxx_messageInfo_Group.DiscardUnknown(m)
}

var xxx_messageInfo_Group proto.InternalMessageInfo

func (m *Group) GetMembers() map[uint64]*Member {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *Group) GetTablets() map[string]*Tablet {
	if m != nil {
		return m.Tablets
	}
	return nil
}

func (m *Group) GetSnapshotTs() uint64 {
	if m != nil {
		return m.SnapshotTs
	}
	return 0
}

func (m *Group) GetChecksum() uint64 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *Group) GetCheckpointTs() uint64 {
	if m != nil {
		return m.CheckpointTs
	}
	return 0
}

type License struct {
	User     string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	MaxNodes uint64 `protobuf:"varint,2,opt,name=maxNodes,proto3" json:"maxNodes,omitempty"`
	ExpiryTs int64  `protobuf:"varint,3,opt,name=expiryTs,proto3" json:"expiryTs,omitempty"`
	Enabled  bool   `protobuf:"varint,4,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *License) Reset()         { *m = License{} }
func (m *License) String() string { return proto.CompactTextString(m) }
func (*License) ProtoMessage()    {}
func (*License) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{13}
}
func (m *License) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *License) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_License.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *License) XXX_Merge(src proto.Message) {
	xxx_messageInfo_License.Merge(m, src)
}
func (m *License) XXX_Size() int {
	return m.Size()
}
func (m *License) XXX_DiscardUnknown() {
	xxx_messageInfo_License.DiscardUnknown(m)
}

var xxx_messageInfo_License proto.InternalMessageInfo

func (m *License) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *License) GetMaxNodes() uint64 {
	if m != nil {
		return m.MaxNodes
	}
	return 0
}

func (m *License) GetExpiryTs() int64 {
	if m != nil {
		return m.ExpiryTs
	}
	return 0
}

func (m *License) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

type ZeroProposal struct {
	SnapshotTs map[uint32]uint64 `protobuf:"bytes,1,rep,name=snapshot_ts,json=snapshotTs,proto3" json:"snapshot_ts,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Member     *Member           `protobuf:"bytes,2,opt,name=member,proto3" json:"member,omitempty"`
	Tablet     *Tablet           `protobuf:"bytes,3,opt,name=tablet,proto3" json:"tablet,omitempty"`
	MaxUID     uint64            `protobuf:"varint,4,opt,name=maxUID,proto3" json:"maxUID,omitempty"`
	MaxTxnTs   uint64            `protobuf:"varint,5,opt,name=maxTxnTs,proto3" json:"maxTxnTs,omitempty"`
	MaxNsID    uint64            `protobuf:"varint,12,opt,name=maxNsID,proto3" json:"maxNsID,omitempty"`
	MaxRaftId  uint64            `protobuf:"varint,6,opt,name=maxRaftId,proto3" json:"maxRaftId,omitempty"`
	Txn        *api.TxnContext   `protobuf:"bytes,7,opt,name=txn,proto3" json:"txn,omitempty"`
	Cid        string            `protobuf:"bytes,9,opt,name=cid,proto3" json:"cid,omitempty"`
	License    *License          `protobuf:"bytes,10,opt,name=license,proto3" json:"license,omitempty"`
	Snapshot   *ZeroSnapshot     `protobuf:"bytes,11,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
}

func (m *ZeroProposal) Reset()         { *m = ZeroProposal{} }
func (m *ZeroProposal) String() string { return proto.CompactTextString(m) }
func (*ZeroProposal) ProtoMessage()    {}
func (*ZeroProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{14}
}
func (m *ZeroProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroProposal.Merge(m, src)
}
func (m *ZeroProposal) XXX_Size() int {
	return m.Size()
}
func (m *ZeroProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroProposal.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroProposal proto.InternalMessageInfo

func (m *ZeroProposal) GetSnapshotTs() map[uint32]uint64 {
	if m != nil {
		return m.SnapshotTs
	}
	return nil
}

func (m *ZeroProposal) GetMember() *Member {
	if m != nil {
		return m.Member
	}
	return nil
}

func (m *ZeroProposal) GetTablet() *Tablet {
	if m != nil {
		return m.Tablet
	}
	return nil
}

func (m *ZeroProposal) GetMaxUID() uint64 {
	if m != nil {
		return m.MaxUID
	}
	return 0
}

func (m *ZeroProposal) GetMaxTxnTs() uint64 {
	if m != nil {
		return m.MaxTxnTs
	}
	return 0
}

func (m *ZeroProposal) GetMaxNsID() uint64 {
	if m != nil {
		return m.MaxNsID
	}
	return 0
}

func (m *ZeroProposal) GetMaxRaftId() uint64 {
	if m != nil {
		return m.MaxRaftId
	}
	return 0
}

func (m *ZeroProposal) GetTxn() *api.TxnContext {
	if m != nil {
		return m.Txn
	}
	return nil
}

func (m *ZeroProposal) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

func (m *ZeroProposal) GetLicense() *License {
	if m != nil {
		return m.License
	}
	return nil
}

func (m *ZeroProposal) GetSnapshot() *ZeroSnapshot {
	if m != nil {
		return m.Snapshot
	}
	return nil
}

// MembershipState is used to pack together the current membership state of all the nodes
// in the caller server; and the membership updates recorded by the callee server since
// the provided lastUpdate.
type MembershipState struct {
	Counter   uint64             `protobuf:"varint,1,opt,name=counter,proto3" json:"counter,omitempty"`
	Groups    map[uint32]*Group  `protobuf:"bytes,2,rep,name=groups,proto3" json:"groups,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Zeros     map[uint64]*Member `protobuf:"bytes,3,rep,name=zeros,proto3" json:"zeros,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MaxUID    uint64             `protobuf:"varint,4,opt,name=maxUID,proto3" json:"maxUID,omitempty"`
	MaxTxnTs  uint64             `protobuf:"varint,5,opt,name=maxTxnTs,proto3" json:"maxTxnTs,omitempty"`
	MaxNsID   uint64             `protobuf:"varint,10,opt,name=maxNsID,proto3" json:"maxNsID,omitempty"`
	MaxRaftId uint64             `protobuf:"varint,6,opt,name=maxRaftId,proto3" json:"maxRaftId,omitempty"`
	Removed   []*Member          `protobuf:"bytes,7,rep,name=removed,proto3" json:"removed,omitempty"`
	Cid       string             `protobuf:"bytes,8,opt,name=cid,proto3" json:"cid,omitempty"`
	License   *License           `protobuf:"bytes,9,opt,name=license,proto3" json:"license,omitempty"`
}

func (m *MembershipState) Reset()         { *m = MembershipState{} }
func (m *MembershipState) String() string { return proto.CompactTextString(m) }
func (*MembershipState) ProtoMessage()    {}
func (*MembershipState) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{15}
}
func (m *MembershipState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MembershipState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MembershipState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MembershipState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MembershipState.Merge(m, src)
}
func (m *MembershipState) XXX_Size() int {
	return m.Size()
}
func (m *MembershipState) XXX_DiscardUnknown() {
	xxx_messageInfo_MembershipState.DiscardUnknown(m)
}

var xxx_messageInfo_MembershipState proto.InternalMessageInfo

func (m *MembershipState) GetCounter() uint64 {
	if m != nil {
		return m.Counter
	}
	return 0
}

func (m *MembershipState) GetGroups() map[uint32]*Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *MembershipState) GetZeros() map[uint64]*Member {
	if m != nil {
		return m.Zeros
	}
	return nil
}

func (m *MembershipState) GetMaxUID() uint64 {
	if m != nil {
		return m.MaxUID
	}
	return 0
}

func (m *MembershipState) GetMaxTxnTs() uint64 {
	if m != nil {
		return m.MaxTxnTs
	}
	return 0
}

func (m *MembershipState) GetMaxNsID() uint64 {
	if m != nil {
		return m.MaxNsID
	}
	return 0
}

func (m *MembershipState) GetMaxRaftId() uint64 {
	if m != nil {
		return m.MaxRaftId
	}
	return 0
}

func (m *MembershipState) GetRemoved() []*Member {
	if m != nil {
		return m.Removed
	}
	return nil
}

func (m *MembershipState) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

func (m *MembershipState) GetLicense() *License {
	if m != nil {
		return m.License
	}
	return nil
}

type ConnectionState struct {
	Member     *Member          `protobuf:"bytes,1,opt,name=member,proto3" json:"member,omitempty"`
	State      *MembershipState `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
	MaxPending uint64           `protobuf:"varint,3,opt,name=max_pending,json=maxPending,proto3" json:"max_pending,omitempty"`
}

func (m *ConnectionState) Reset()         { *m = ConnectionState{} }
func (m *ConnectionState) String() string { return proto.CompactTextString(m) }
func (*ConnectionState) ProtoMessage()    {}
func (*ConnectionState) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{16}
}
func (m *ConnectionState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectionState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectionState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectionState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionState.Merge(m, src)
}
func (m *ConnectionState) XXX_Size() int {
	return m.Size()
}
func (m *ConnectionState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionState.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionState proto.InternalMessageInfo

func (m *ConnectionState) GetMember() *Member {
	if m != nil {
		return m.Member
	}
	return nil
}

func (m *ConnectionState) GetState() *MembershipState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *ConnectionState) GetMaxPending() uint64 {
	if m != nil {
		return m.MaxPending
	}
	return 0
}

type HealthInfo struct {
	Instance    string   `protobuf:"bytes,1,opt,name=instance,proto3" json:"instance,omitempty"`
	Address     string   `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	Status      string   `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	Group       string   `protobuf:"bytes,4,opt,name=group,proto3" json:"group,omitempty"`
	Version     string   `protobuf:"bytes,5,opt,name=version,proto3" json:"version,omitempty"`
	Uptime      int64    `protobuf:"varint,6,opt,name=uptime,proto3" json:"uptime,omitempty"`
	LastEcho    int64    `protobuf:"varint,7,opt,name=lastEcho,proto3" json:"lastEcho,omitempty"`
	Ongoing     []string `protobuf:"bytes,8,rep,name=ongoing,proto3" json:"ongoing,omitempty"`
	Indexing    []string `protobuf:"bytes,9,rep,name=indexing,proto3" json:"indexing,omitempty"`
	EeFeatures  []string `protobuf:"bytes,10,rep,name=ee_features,json=eeFeatures,proto3" json:"ee_features,omitempty"`
	MaxAssigned uint64   `protobuf:"varint,11,opt,name=max_assigned,json=maxAssigned,proto3" json:"max_assigned,omitempty"`
}

func (m *HealthInfo) Reset()         { *m = HealthInfo{} }
func (m *HealthInfo) String() string { return proto.CompactTextString(m) }
func (*HealthInfo) ProtoMessage()    {}
func (*HealthInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{17}
}
func (m *HealthInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HealthInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HealthInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthInfo.Merge(m, src)
}
func (m *HealthInfo) XXX_Size() int {
	return m.Size()
}
func (m *HealthInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthInfo.DiscardUnknown(m)
}

var xxx_messageInfo_HealthInfo proto.InternalMessageInfo

func (m *HealthInfo) GetInstance() string {
	if m != nil {
		return m.Instance
	}
	return ""
}

func (m *HealthInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *HealthInfo) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *HealthInfo) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *HealthInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *HealthInfo) GetUptime() int64 {
	if m != nil {
		return m.Uptime
	}
	return 0
}

func (m *HealthInfo) GetLastEcho() int64 {
	if m != nil {
		return m.LastEcho
	}
	return 0
}

func (m *HealthInfo) GetOngoing() []string {
	if m != nil {
		return m.Ongoing
	}
	return nil
}

func (m *HealthInfo) GetIndexing() []string {
	if m != nil {
		return m.Indexing
	}
	return nil
}

func (m *HealthInfo) GetEeFeatures() []string {
	if m != nil {
		return m.EeFeatures
	}
	return nil
}

func (m *HealthInfo) GetMaxAssigned() uint64 {
	if m != nil {
		return m.MaxAssigned
	}
	return 0
}

type Tablet struct {
	GroupId           uint32 `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"groupId,omitempty"`
	Predicate         string `protobuf:"bytes,2,opt,name=predicate,proto3" json:"predicate,omitempty"`
	Force             bool   `protobuf:"varint,3,opt,name=force,proto3" json:"force,omitempty"`
	OnDiskBytes       int64  `protobuf:"varint,7,opt,name=on_disk_bytes,json=onDiskBytes,proto3" json:"on_disk_bytes,omitempty"`
	Remove            bool   `protobuf:"varint,8,opt,name=remove,proto3" json:"remove,omitempty"`
	ReadOnly          bool   `protobuf:"varint,9,opt,name=read_only,json=readOnly,proto3" json:"readOnly,omitempty"`
	MoveTs            uint64 `protobuf:"varint,10,opt,name=move_ts,json=moveTs,proto3" json:"moveTs,omitempty"`
	UncompressedBytes int64  `protobuf:"varint,11,opt,name=uncompressed_bytes,json=uncompressedBytes,proto3" json:"uncompressed_bytes,omitempty"`
}

func (m *Tablet) Reset()         { *m = Tablet{} }
func (m *Tablet) String() string { return proto.CompactTextString(m) }
func (*Tablet) ProtoMessage()    {}
func (*Tablet) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{18}
}
func (m *Tablet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tablet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tablet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tablet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tablet.Merge(m, src)
}
func (m *Tablet) XXX_Size() int {
	return m.Size()
}
func (m *Tablet) XXX_DiscardUnknown() {
	xxx_messageInfo_Tablet.DiscardUnknown(m)
}

var xxx_messageInfo_Tablet proto.InternalMessageInfo

func (m *Tablet) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *Tablet) GetPredicate() string {
	if m != nil {
		return m.Predicate
	}
	return ""
}

func (m *Tablet) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

func (m *Tablet) GetOnDiskBytes() int64 {
	if m != nil {
		return m.OnDiskBytes
	}
	return 0
}

func (m *Tablet) GetRemove() bool {
	if m != nil {
		return m.Remove
	}
	return false
}

func (m *Tablet) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *Tablet) GetMoveTs() uint64 {
	if m != nil {
		return m.MoveTs
	}
	return 0
}

func (m *Tablet) GetUncompressedBytes() int64 {
	if m != nil {
		return m.UncompressedBytes
	}
	return 0
}

type DirectedEdge struct {
	Entity       uint64          `protobuf:"fixed64,1,opt,name=entity,proto3" json:"entity,omitempty"`
	Attr         string          `protobuf:"bytes,2,opt,name=attr,proto3" json:"attr,omitempty"`
	Value        []byte          `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	ValueType    Posting_ValType `protobuf:"varint,4,opt,name=value_type,json=valueType,proto3,enum=pb.Posting_ValType" json:"value_type,omitempty"`
	ValueId      uint64          `protobuf:"fixed64,5,opt,name=value_id,json=valueId,proto3" json:"value_id,omitempty"`
	Label        string          `protobuf:"bytes,6,opt,name=label,proto3" json:"label,omitempty"`
	Lang         string          `protobuf:"bytes,7,opt,name=lang,proto3" json:"lang,omitempty"`
	Op           DirectedEdge_Op `protobuf:"varint,8,opt,name=op,proto3,enum=pb.DirectedEdge_Op" json:"op,omitempty"`
	Facets       []*api.Facet    `protobuf:"bytes,9,rep,name=facets,proto3" json:"facets,omitempty"`
	AllowedPreds []string        `protobuf:"bytes,10,rep,name=allowedPreds,proto3" json:"allowedPreds,omitempty"`
}

func (m *DirectedEdge) Reset()         { *m = DirectedEdge{} }
func (m *DirectedEdge) String() string { return proto.CompactTextString(m) }
func (*DirectedEdge) ProtoMessage()    {}
func (*DirectedEdge) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{19}
}
func (m *DirectedEdge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectedEdge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DirectedEdge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DirectedEdge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectedEdge.Merge(m, src)
}
func (m *DirectedEdge) XXX_Size() int {
	return m.Size()
}
func (m *DirectedEdge) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectedEdge.DiscardUnknown(m)
}

var xxx_messageInfo_DirectedEdge proto.InternalMessageInfo

func (m *DirectedEdge) GetEntity() uint64 {
	if m != nil {
		return m.Entity
	}
	return 0
}

func (m *DirectedEdge) GetAttr() string {
	if m != nil {
		return m.Attr
	}
	return ""
}

func (m *DirectedEdge) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *DirectedEdge) GetValueType() Posting_ValType {
	if m != nil {
		return m.ValueType
	}
	return Posting_DEFAULT
}

func (m *DirectedEdge) GetValueId() uint64 {
	if m != nil {
		return m.ValueId
	}
	return 0
}

func (m *DirectedEdge) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *DirectedEdge) GetLang() string {
	if m != nil {
		return m.Lang
	}
	return ""
}

func (m *DirectedEdge) GetOp() DirectedEdge_Op {
	if m != nil {
		return m.Op
	}
	return DirectedEdge_SET
}

func (m *DirectedEdge) GetFacets() []*api.Facet {
	if m != nil {
		return m.Facets
	}
	return nil
}

func (m *DirectedEdge) GetAllowedPreds() []string {
	if m != nil {
		return m.AllowedPreds
	}
	return nil
}

type Mutations struct {
	GroupId   uint32           `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	StartTs   uint64           `protobuf:"varint,2,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	Edges     []*DirectedEdge  `protobuf:"bytes,3,rep,name=edges,proto3" json:"edges,omitempty"`
	Schema    []*SchemaUpdate  `protobuf:"bytes,4,rep,name=schema,proto3" json:"schema,omitempty"`
	Types     []*TypeUpdate    `protobuf:"bytes,6,rep,name=types,proto3" json:"types,omitempty"`
	DropOp    Mutations_DropOp `protobuf:"varint,7,opt,name=drop_op,json=dropOp,proto3,enum=pb.Mutations_DropOp" json:"drop_op,omitempty"`
	DropValue string           `protobuf:"bytes,8,opt,name=drop_value,json=dropValue,proto3" json:"drop_value,omitempty"`
	Metadata  *Metadata        `protobuf:"bytes,9,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *Mutations) Reset()         { *m = Mutations{} }
func (m *Mutations) String() string { return proto.CompactTextString(m) }
func (*Mutations) ProtoMessage()    {}
func (*Mutations) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{20}
}
func (m *Mutations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Mutations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Mutations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Mutations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Mutations.Merge(m, src)
}
func (m *Mutations) XXX_Size() int {
	return m.Size()
}
func (m *Mutations) XXX_DiscardUnknown() {
	xxx_messageInfo_Mutations.DiscardUnknown(m)
}

var xxx_messageInfo_Mutations proto.InternalMessageInfo

func (m *Mutations) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *Mutations) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *Mutations) GetEdges() []*DirectedEdge {
	if m != nil {
		return m.Edges
	}
	return nil
}

func (m *Mutations) GetSchema() []*SchemaUpdate {
	if m != nil {
		return m.Schema
	}
	return nil
}

func (m *Mutations) GetTypes() []*TypeUpdate {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *Mutations) GetDropOp() Mutations_DropOp {
	if m != nil {
		return m.DropOp
	}
	return Mutations_NONE
}

func (m *Mutations) GetDropValue() string {
	if m != nil {
		return m.DropValue
	}
	return ""
}

func (m *Mutations) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type Metadata struct {
	// Map of predicates to their hints.
	PredHints map[string]Metadata_HintType `protobuf:"bytes,1,rep,name=pred_hints,json=predHints,proto3" json:"pred_hints,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=pb.Metadata_HintType"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{21}
}
func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(m, src)
}
func (m *Metadata) XXX_Size() int {
	return m.Size()
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

func (m *Metadata) GetPredHints() map[string]Metadata_HintType {
	if m != nil {
		return m.PredHints
	}
	return nil
}

type Snapshot struct {
	Context *RaftContext `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Index   uint64       `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	ReadTs  uint64       `protobuf:"varint,3,opt,name=read_ts,json=readTs,proto3" json:"read_ts,omitempty"`
	// done is used to indicate that snapshot stream was a success.
	Done bool `protobuf:"varint,4,opt,name=done,proto3" json:"done,omitempty"`
	// since_ts stores the ts of the last snapshot to support diff snap updates.
	SinceTs uint64 `protobuf:"varint,5,opt,name=since_ts,json=sinceTs,proto3" json:"since_ts,omitempty"`
}

func (m *Snapshot) Reset()         { *m = Snapshot{} }
func (m *Snapshot) String() string { return proto.CompactTextString(m) }
func (*Snapshot) ProtoMessage()    {}
func (*Snapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{22}
}
func (m *Snapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Snapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot.Merge(m, src)
}
func (m *Snapshot) XXX_Size() int {
	return m.Size()
}
func (m *Snapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot proto.InternalMessageInfo

func (m *Snapshot) GetContext() *RaftContext {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *Snapshot) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Snapshot) GetReadTs() uint64 {
	if m != nil {
		return m.ReadTs
	}
	return 0
}

func (m *Snapshot) GetDone() bool {
	if m != nil {
		return m.Done
	}
	return false
}

func (m *Snapshot) GetSinceTs() uint64 {
	if m != nil {
		return m.SinceTs
	}
	return 0
}

type ZeroSnapshot struct {
	Index        uint64           `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	CheckpointTs uint64           `protobuf:"varint,2,opt,name=checkpoint_ts,json=checkpointTs,proto3" json:"checkpoint_ts,omitempty"`
	State        *MembershipState `protobuf:"bytes,5,opt,name=state,proto3" json:"state,omitempty"`
}

func (m *ZeroSnapshot) Reset()         { *m = ZeroSnapshot{} }
func (m *ZeroSnapshot) String() string { return proto.CompactTextString(m) }
func (*ZeroSnapshot) ProtoMessage()    {}
func (*ZeroSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{23}
}
func (m *ZeroSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroSnapshot.Merge(m, src)
}
func (m *ZeroSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *ZeroSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroSnapshot proto.InternalMessageInfo

func (m *ZeroSnapshot) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *ZeroSnapshot) GetCheckpointTs() uint64 {
	if m != nil {
		return m.CheckpointTs
	}
	return 0
}

func (m *ZeroSnapshot) GetState() *MembershipState {
	if m != nil {
		return m.State
	}
	return nil
}

type RestoreRequest struct {
	GroupId   uint32 `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	RestoreTs uint64 `protobuf:"varint,2,opt,name=restore_ts,json=restoreTs,proto3" json:"restore_ts,omitempty"`
	Location  string `protobuf:"bytes,3,opt,name=location,proto3" json:"location,omitempty"`
	BackupId  string `protobuf:"bytes,4,opt,name=backup_id,json=backupId,proto3" json:"backup_id,omitempty"`
	// Credentials when using a minio or S3 bucket as the backup location.
	AccessKey    string `protobuf:"bytes,5,opt,name=access_key,json=accessKey,proto3" json:"access_key,omitempty"`
	SecretKey    string `protobuf:"bytes,6,opt,name=secret_key,json=secretKey,proto3" json:"secret_key,omitempty"`
	SessionToken string `protobuf:"bytes,7,opt,name=session_token,json=sessionToken,proto3" json:"session_token,omitempty"`
	Anonymous    bool   `protobuf:"varint,8,opt,name=anonymous,proto3" json:"anonymous,omitempty"`
	// Info needed to process encrypted backups.
	EncryptionKeyFile string `protobuf:"bytes,9,opt,name=encryption_key_file,json=encryptionKeyFile,proto3" json:"encryption_key_file,omitempty"`
	// Vault options
	VaultAddr         string `protobuf:"bytes,10,opt,name=vault_addr,json=vaultAddr,proto3" json:"vault_addr,omitempty"`
	VaultRoleidFile   string `protobuf:"bytes,11,opt,name=vault_roleid_file,json=vaultRoleidFile,proto3" json:"vault_roleid_file,omitempty"`
	VaultSecretidFile string `protobuf:"bytes,12,opt,name=vault_secretid_file,json=vaultSecretidFile,proto3" json:"vault_secretid_file,omitempty"`
	VaultPath         string `protobuf:"bytes,13,opt,name=vault_path,json=vaultPath,proto3" json:"vault_path,omitempty"`
	VaultField        string `protobuf:"bytes,14,opt,name=vault_field,json=vaultField,proto3" json:"vault_field,omitempty"`
	VaultFormat       string `protobuf:"bytes,15,opt,name=vault_format,json=vaultFormat,proto3" json:"vault_format,omitempty"`
	BackupNum         uint64 `protobuf:"varint,16,opt,name=backup_num,json=backupNum,proto3" json:"backup_num,omitempty"`
}

func (m *RestoreRequest) Reset()         { *m = RestoreRequest{} }
func (m *RestoreRequest) String() string { return proto.CompactTextString(m) }
func (*RestoreRequest) ProtoMessage()    {}
func (*RestoreRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{24}
}
func (m *RestoreRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RestoreRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RestoreRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreRequest.Merge(m, src)
}
func (m *RestoreRequest) XXX_Size() int {
	return m.Size()
}
func (m *RestoreRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreRequest proto.InternalMessageInfo

func (m *RestoreRequest) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *RestoreRequest) GetRestoreTs() uint64 {
	if m != nil {
		return m.RestoreTs
	}
	return 0
}

func (m *RestoreRequest) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *RestoreRequest) GetBackupId() string {
	if m != nil {
		return m.BackupId
	}
	return ""
}

func (m *RestoreRequest) GetAccessKey() string {
	if m != nil {
		return m.AccessKey
	}
	return ""
}

func (m *RestoreRequest) GetSecretKey() string {
	if m != nil {
		return m.SecretKey
	}
	return ""
}

func (m *RestoreRequest) GetSessionToken() string {
	if m != nil {
		return m.SessionToken
	}
	return ""
}

func (m *RestoreRequest) GetAnonymous() bool {
	if m != nil {
		return m.Anonymous
	}
	return false
}

func (m *RestoreRequest) GetEncryptionKeyFile() string {
	if m != nil {
		return m.EncryptionKeyFile
	}
	return ""
}

func (m *RestoreRequest) GetVaultAddr() string {
	if m != nil {
		return m.VaultAddr
	}
	return ""
}

func (m *RestoreRequest) GetVaultRoleidFile() string {
	if m != nil {
		return m.VaultRoleidFile
	}
	return ""
}

func (m *RestoreRequest) GetVaultSecretidFile() string {
	if m != nil {
		return m.VaultSecretidFile
	}
	return ""
}

func (m *RestoreRequest) GetVaultPath() string {
	if m != nil {
		return m.VaultPath
	}
	return ""
}

func (m *RestoreRequest) GetVaultField() string {
	if m != nil {
		return m.VaultField
	}
	return ""
}

func (m *RestoreRequest) GetVaultFormat() string {
	if m != nil {
		return m.VaultFormat
	}
	return ""
}

func (m *RestoreRequest) GetBackupNum() uint64 {
	if m != nil {
		return m.BackupNum
	}
	return 0
}

type Proposal struct {
	Mutations        *Mutations       `protobuf:"bytes,2,opt,name=mutations,proto3" json:"mutations,omitempty"`
	Kv               []*pb.KV         `protobuf:"bytes,4,rep,name=kv,proto3" json:"kv,omitempty"`
	State            *MembershipState `protobuf:"bytes,5,opt,name=state,proto3" json:"state,omitempty"`
	CleanPredicate   string           `protobuf:"bytes,6,opt,name=clean_predicate,json=cleanPredicate,proto3" json:"clean_predicate,omitempty"`
	Delta            *OracleDelta     `protobuf:"bytes,8,opt,name=delta,proto3" json:"delta,omitempty"`
	Snapshot         *Snapshot        `protobuf:"bytes,9,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	Index            uint64           `protobuf:"varint,10,opt,name=index,proto3" json:"index,omitempty"`
	ExpectedChecksum uint64           `protobuf:"varint,11,opt,name=expected_checksum,json=expectedChecksum,proto3" json:"expected_checksum,omitempty"`
	Restore          *RestoreRequest  `protobuf:"bytes,12,opt,name=restore,proto3" json:"restore,omitempty"`
	CDCIndex         uint64           `protobuf:"varint,13,opt,name=CDCIndex,proto3" json:"CDCIndex,omitempty"`
}

func (m *Proposal) Reset()         { *m = Proposal{} }
func (m *Proposal) String() string { return proto.CompactTextString(m) }
func (*Proposal) ProtoMessage()    {}
func (*Proposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{25}
}
func (m *Proposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal.Merge(m, src)
}
func (m *Proposal) XXX_Size() int {
	return m.Size()
}
func (m *Proposal) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal proto.InternalMessageInfo

func (m *Proposal) GetMutations() *Mutations {
	if m != nil {
		return m.Mutations
	}
	return nil
}

func (m *Proposal) GetKv() []*pb.KV {
	if m != nil {
		return m.Kv
	}
	return nil
}

func (m *Proposal) GetState() *MembershipState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *Proposal) GetCleanPredicate() string {
	if m != nil {
		return m.CleanPredicate
	}
	return ""
}

func (m *Proposal) GetDelta() *OracleDelta {
	if m != nil {
		return m.Delta
	}
	return nil
}

func (m *Proposal) GetSnapshot() *Snapshot {
	if m != nil {
		return m.Snapshot
	}
	return nil
}

func (m *Proposal) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Proposal) GetExpectedChecksum() uint64 {
	if m != nil {
		return m.ExpectedChecksum
	}
	return 0
}

func (m *Proposal) GetRestore() *RestoreRequest {
	if m != nil {
		return m.Restore
	}
	return nil
}

func (m *Proposal) GetCDCIndex() uint64 {
	if m != nil {
		return m.CDCIndex
	}
	return 0
}

type KVS struct {
	Data []byte `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
	// done used to indicate if the stream of KVS is over.
	Done bool `protobuf:"varint,2,opt,name=done,proto3" json:"done,omitempty"`
	// predicates is the list of predicates known by the leader at the time of the snapshot.
	Predicates []string `protobuf:"bytes,3,rep,name=predicates,proto3" json:"predicates,omitempty"`
	// types is the list of types known by the leader at the time of the snapshot.
	Types []string `protobuf:"bytes,4,rep,name=types,proto3" json:"types,omitempty"`
}

func (m *KVS) Reset()         { *m = KVS{} }
func (m *KVS) String() string { return proto.CompactTextString(m) }
func (*KVS) ProtoMessage()    {}
func (*KVS) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{26}
}
func (m *KVS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVS.Merge(m, src)
}
func (m *KVS) XXX_Size() int {
	return m.Size()
}
func (m *KVS) XXX_DiscardUnknown() {
	xxx_messageInfo_KVS.DiscardUnknown(m)
}

var xxx_messageInfo_KVS proto.InternalMessageInfo

func (m *KVS) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *KVS) GetDone() bool {
	if m != nil {
		return m.Done
	}
	return false
}

func (m *KVS) GetPredicates() []string {
	if m != nil {
		return m.Predicates
	}
	return nil
}

func (m *KVS) GetTypes() []string {
	if m != nil {
		return m.Types
	}
	return nil
}

// Posting messages.
type Posting struct {
	Uid         uint64              `protobuf:"fixed64,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Value       []byte              `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	ValType     Posting_ValType     `protobuf:"varint,3,opt,name=val_type,json=valType,proto3,enum=pb.Posting_ValType" json:"val_type,omitempty"`
	PostingType Posting_PostingType `protobuf:"varint,4,opt,name=posting_type,json=postingType,proto3,enum=pb.Posting_PostingType" json:"posting_type,omitempty"`
	LangTag     []byte              `protobuf:"bytes,5,opt,name=lang_tag,json=langTag,proto3" json:"lang_tag,omitempty"`
	Label       string              `protobuf:"bytes,6,opt,name=label,proto3" json:"label,omitempty"`
	Facets      []*api.Facet        `protobuf:"bytes,9,rep,name=facets,proto3" json:"facets,omitempty"`
	// TODO: op is only used temporarily. See if we can remove it from here.
	Op       uint32 `protobuf:"varint,12,opt,name=op,proto3" json:"op,omitempty"`
	StartTs  uint64 `protobuf:"varint,13,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	CommitTs uint64 `protobuf:"varint,14,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
}

func (m *Posting) Reset()         { *m = Posting{} }
func (m *Posting) String() string { return proto.CompactTextString(m) }
func (*Posting) ProtoMessage()    {}
func (*Posting) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{27}
}
func (m *Posting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Posting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Posting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Posting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Posting.Merge(m, src)
}
func (m *Posting) XXX_Size() int {
	return m.Size()
}
func (m *Posting) XXX_DiscardUnknown() {
	xxx_messageInfo_Posting.DiscardUnknown(m)
}

var xxx_messageInfo_Posting proto.InternalMessageInfo

func (m *Posting) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *Posting) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Posting) GetValType() Posting_ValType {
	if m != nil {
		return m.ValType
	}
	return Posting_DEFAULT
}

func (m *Posting) GetPostingType() Posting_PostingType {
	if m != nil {
		return m.PostingType
	}
	return Posting_REF
}

func (m *Posting) GetLangTag() []byte {
	if m != nil {
		return m.LangTag
	}
	return nil
}

func (m *Posting) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *Posting) GetFacets() []*api.Facet {
	if m != nil {
		return m.Facets
	}
	return nil
}

func (m *Posting) GetOp() uint32 {
	if m != nil {
		return m.Op
	}
	return 0
}

func (m *Posting) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *Posting) GetCommitTs() uint64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

type UidBlock struct {
	Base uint64 `protobuf:"varint,1,opt,name=base,proto3" json:"base,omitempty"`
	// deltas contains the deltas encoded with Varints. We don't store deltas as a list of integers,
	// because when the PB is brought to memory, Go would always use 8-bytes per integer. Instead,
	// storing it as a byte slice is a lot cheaper in memory.
	Deltas []byte `protobuf:"bytes,2,opt,name=deltas,proto3" json:"deltas,omitempty"`
	// num_uids is the number of UIDs in the block. We are including this because we want to
	// switch encoding to groupvarint encoding. Current avaialble open source version implements
	// encoding and decoding for uint32. To use that, we create different blocks for different 32-bit
	// MSB base uids. That is, if the 32 MSBs are different, we will create a new block irrespective
	// of whether the block is filled with the block_size or not.
	// Default Blocksize is 256 so uint32 would be sufficient.
	NumUids uint32 `protobuf:"varint,3,opt,name=num_uids,json=numUids,proto3" json:"num_uids,omitempty"`
}

func (m *UidBlock) Reset()         { *m = UidBlock{} }
func (m *UidBlock) String() string { return proto.CompactTextString(m) }
func (*UidBlock) ProtoMessage()    {}
func (*UidBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{28}
}
func (m *UidBlock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UidBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UidBlock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UidBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UidBlock.Merge(m, src)
}
func (m *UidBlock) XXX_Size() int {
	return m.Size()
}
func (m *UidBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_UidBlock.DiscardUnknown(m)
}

var xxx_messageInfo_UidBlock proto.InternalMessageInfo

func (m *UidBlock) GetBase() uint64 {
	if m != nil {
		return m.Base
	}
	return 0
}

func (m *UidBlock) GetDeltas() []byte {
	if m != nil {
		return m.Deltas
	}
	return nil
}

func (m *UidBlock) GetNumUids() uint32 {
	if m != nil {
		return m.NumUids
	}
	return 0
}

type UidPack struct {
	BlockSize uint32      `protobuf:"varint,1,opt,name=block_size,json=blockSize,proto3" json:"block_size,omitempty"`
	Blocks    []*UidBlock `protobuf:"bytes,2,rep,name=blocks,proto3" json:"blocks,omitempty"`
	AllocRef  uint64      `protobuf:"varint,23,opt,name=alloc_ref,json=allocRef,proto3" json:"alloc_ref,omitempty"`
}

func (m *UidPack) Reset()         { *m = UidPack{} }
func (m *UidPack) String() string { return proto.CompactTextString(m) }
func (*UidPack) ProtoMessage()    {}
func (*UidPack) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{29}
}
func (m *UidPack) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UidPack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UidPack.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UidPack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UidPack.Merge(m, src)
}
func (m *UidPack) XXX_Size() int {
	return m.Size()
}
func (m *UidPack) XXX_DiscardUnknown() {
	xxx_messageInfo_UidPack.DiscardUnknown(m)
}

var xxx_messageInfo_UidPack proto.InternalMessageInfo

func (m *UidPack) GetBlockSize() uint32 {
	if m != nil {
		return m.BlockSize
	}
	return 0
}

func (m *UidPack) GetBlocks() []*UidBlock {
	if m != nil {
		return m.Blocks
	}
	return nil
}

func (m *UidPack) GetAllocRef() uint64 {
	if m != nil {
		return m.AllocRef
	}
	return 0
}

type PostingList struct {
	Pack     *UidPack   `protobuf:"bytes,1,opt,name=pack,proto3" json:"pack,omitempty"`
	Postings []*Posting `protobuf:"bytes,2,rep,name=postings,proto3" json:"postings,omitempty"`
	CommitTs uint64     `protobuf:"varint,3,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	Splits   []uint64   `protobuf:"varint,4,rep,packed,name=splits,proto3" json:"splits,omitempty"`
}

func (m *PostingList) Reset()         { *m = PostingList{} }
func (m *PostingList) String() string { return proto.CompactTextString(m) }
func (*PostingList) ProtoMessage()    {}
func (*PostingList) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{30}
}
func (m *PostingList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PostingList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PostingList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PostingList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PostingList.Merge(m, src)
}
func (m *PostingList) XXX_Size() int {
	return m.Size()
}
func (m *PostingList) XXX_DiscardUnknown() {
	xxx_messageInfo_PostingList.DiscardUnknown(m)
}

var xxx_messageInfo_PostingList proto.InternalMessageInfo

func (m *PostingList) GetPack() *UidPack {
	if m != nil {
		return m.Pack
	}
	return nil
}

func (m *PostingList) GetPostings() []*Posting {
	if m != nil {
		return m.Postings
	}
	return nil
}

func (m *PostingList) GetCommitTs() uint64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

func (m *PostingList) GetSplits() []uint64 {
	if m != nil {
		return m.Splits
	}
	return nil
}

type FacetParam struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Alias string `protobuf:"bytes,2,opt,name=alias,proto3" json:"alias,omitempty"`
}

func (m *FacetParam) Reset()         { *m = FacetParam{} }
func (m *FacetParam) String() string { return proto.CompactTextString(m) }
func (*FacetParam) ProtoMessage()    {}
func (*FacetParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{31}
}
func (m *FacetParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FacetParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FacetParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FacetParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FacetParam.Merge(m, src)
}
func (m *FacetParam) XXX_Size() int {
	return m.Size()
}
func (m *FacetParam) XXX_DiscardUnknown() {
	xxx_messageInfo_FacetParam.DiscardUnknown(m)
}

var xxx_messageInfo_FacetParam proto.InternalMessageInfo

func (m *FacetParam) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *FacetParam) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

type FacetParams struct {
	AllKeys bool          `protobuf:"varint,1,opt,name=all_keys,json=allKeys,proto3" json:"all_keys,omitempty"`
	Param   []*FacetParam `protobuf:"bytes,2,rep,name=param,proto3" json:"param,omitempty"`
}

func (m *FacetParams) Reset()         { *m = FacetParams{} }
func (m *FacetParams) String() string { return proto.CompactTextString(m) }
func (*FacetParams) ProtoMessage()    {}
func (*FacetParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{32}
}
func (m *FacetParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FacetParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FacetParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FacetParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FacetParams.Merge(m, src)
}
func (m *FacetParams) XXX_Size() int {
	return m.Size()
}
func (m *FacetParams) XXX_DiscardUnknown() {
	xxx_messageInfo_FacetParams.DiscardUnknown(m)
}

var xxx_messageInfo_FacetParams proto.InternalMessageInfo

func (m *FacetParams) GetAllKeys() bool {
	if m != nil {
		return m.AllKeys
	}
	return false
}

func (m *FacetParams) GetParam() []*FacetParam {
	if m != nil {
		return m.Param
	}
	return nil
}

type Facets struct {
	Facets []*api.Facet `protobuf:"bytes,1,rep,name=facets,proto3" json:"facets,omitempty"`
}

func (m *Facets) Reset()         { *m = Facets{} }
func (m *Facets) String() string { return proto.CompactTextString(m) }
func (*Facets) ProtoMessage()    {}
func (*Facets) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{33}
}
func (m *Facets) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Facets) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Facets.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Facets) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Facets.Merge(m, src)
}
func (m *Facets) XXX_Size() int {
	return m.Size()
}
func (m *Facets) XXX_DiscardUnknown() {
	xxx_messageInfo_Facets.DiscardUnknown(m)
}

var xxx_messageInfo_Facets proto.InternalMessageInfo

func (m *Facets) GetFacets() []*api.Facet {
	if m != nil {
		return m.Facets
	}
	return nil
}

type FacetsList struct {
	FacetsList []*Facets `protobuf:"bytes,1,rep,name=facets_list,json=facetsList,proto3" json:"facets_list,omitempty"`
}

func (m *FacetsList) Reset()         { *m = FacetsList{} }
func (m *FacetsList) String() string { return proto.CompactTextString(m) }
func (*FacetsList) ProtoMessage()    {}
func (*FacetsList) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{34}
}
func (m *FacetsList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FacetsList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FacetsList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FacetsList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FacetsList.Merge(m, src)
}
func (m *FacetsList) XXX_Size() int {
	return m.Size()
}
func (m *FacetsList) XXX_DiscardUnknown() {
	xxx_messageInfo_FacetsList.DiscardUnknown(m)
}

var xxx_messageInfo_FacetsList proto.InternalMessageInfo

func (m *FacetsList) GetFacetsList() []*Facets {
	if m != nil {
		return m.FacetsList
	}
	return nil
}

type Function struct {
	Name string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Key  string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Args []string `protobuf:"bytes,3,rep,name=args,proto3" json:"args,omitempty"`
}

func (m *Function) Reset()         { *m = Function{} }
func (m *Function) String() string { return proto.CompactTextString(m) }
func (*Function) ProtoMessage()    {}
func (*Function) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{35}
}
func (m *Function) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Function) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Function.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Function) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Function.Merge(m, src)
}
func (m *Function) XXX_Size() int {
	return m.Size()
}
func (m *Function) XXX_DiscardUnknown() {
	xxx_messageInfo_Function.DiscardUnknown(m)
}

var xxx_messageInfo_Function proto.InternalMessageInfo

func (m *Function) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Function) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Function) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

// Op and Children are internal nodes and Func on leaves.
type FilterTree struct {
	Op       string        `protobuf:"bytes,1,opt,name=op,proto3" json:"op,omitempty"`
	Children []*FilterTree `protobuf:"bytes,2,rep,name=children,proto3" json:"children,omitempty"`
	Func     *Function     `protobuf:"bytes,3,opt,name=func,proto3" json:"func,omitempty"`
}

func (m *FilterTree) Reset()         { *m = FilterTree{} }
func (m *FilterTree) String() string { return proto.CompactTextString(m) }
func (*FilterTree) ProtoMessage()    {}
func (*FilterTree) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{36}
}
func (m *FilterTree) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FilterTree) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FilterTree.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FilterTree) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FilterTree.Merge(m, src)
}
func (m *FilterTree) XXX_Size() int {
	return m.Size()
}
func (m *FilterTree) XXX_DiscardUnknown() {
	xxx_messageInfo_FilterTree.DiscardUnknown(m)
}

var xxx_messageInfo_FilterTree proto.InternalMessageInfo

func (m *FilterTree) GetOp() string {
	if m != nil {
		return m.Op
	}
	return ""
}

func (m *FilterTree) GetChildren() []*FilterTree {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *FilterTree) GetFunc() *Function {
	if m != nil {
		return m.Func
	}
	return nil
}

// Schema messages.
type SchemaRequest struct {
	GroupId    uint32   `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	Predicates []string `protobuf:"bytes,2,rep,name=predicates,proto3" json:"predicates,omitempty"`
	// fields can be on of type, index, reverse or tokenizer
	Fields []string `protobuf:"bytes,3,rep,name=fields,proto3" json:"fields,omitempty"`
	Types  []string `protobuf:"bytes,4,rep,name=types,proto3" json:"types,omitempty"`
}

func (m *SchemaRequest) Reset()         { *m = SchemaRequest{} }
func (m *SchemaRequest) String() string { return proto.CompactTextString(m) }
func (*SchemaRequest) ProtoMessage()    {}
func (*SchemaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{37}
}
func (m *SchemaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchemaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchemaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaRequest.Merge(m, src)
}
func (m *SchemaRequest) XXX_Size() int {
	return m.Size()
}
func (m *SchemaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaRequest proto.InternalMessageInfo

func (m *SchemaRequest) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *SchemaRequest) GetPredicates() []string {
	if m != nil {
		return m.Predicates
	}
	return nil
}

func (m *SchemaRequest) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *SchemaRequest) GetTypes() []string {
	if m != nil {
		return m.Types
	}
	return nil
}

type SchemaNode struct {
	Predicate  string   `protobuf:"bytes,1,opt,name=predicate,proto3" json:"predicate,omitempty"`
	Type       string   `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Index      bool     `protobuf:"varint,3,opt,name=index,proto3" json:"index,omitempty"`
	Tokenizer  []string `protobuf:"bytes,4,rep,name=tokenizer,proto3" json:"tokenizer,omitempty"`
	Reverse    bool     `protobuf:"varint,5,opt,name=reverse,proto3" json:"reverse,omitempty"`
	Count      bool     `protobuf:"varint,6,opt,name=count,proto3" json:"count,omitempty"`
	List       bool     `protobuf:"varint,7,opt,name=list,proto3" json:"list,omitempty"`
	Upsert     bool     `protobuf:"varint,8,opt,name=upsert,proto3" json:"upsert,omitempty"`
	Lang       bool     `protobuf:"varint,9,opt,name=lang,proto3" json:"lang,omitempty"`
	NoConflict bool     `protobuf:"varint,10,opt,name=no_conflict,json=noConflict,proto3" json:"no_conflict,omitempty"`
}

func (m *SchemaNode) Reset()         { *m = SchemaNode{} }
func (m *SchemaNode) String() string { return proto.CompactTextString(m) }
func (*SchemaNode) ProtoMessage()    {}
func (*SchemaNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{38}
}
func (m *SchemaNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchemaNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchemaNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaNode.Merge(m, src)
}
func (m *SchemaNode) XXX_Size() int {
	return m.Size()
}
func (m *SchemaNode) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaNode.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaNode proto.InternalMessageInfo

func (m *SchemaNode) GetPredicate() string {
	if m != nil {
		return m.Predicate
	}
	return ""
}

func (m *SchemaNode) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *SchemaNode) GetIndex() bool {
	if m != nil {
		return m.Index
	}
	return false
}

func (m *SchemaNode) GetTokenizer() []string {
	if m != nil {
		return m.Tokenizer
	}
	return nil
}

func (m *SchemaNode) GetReverse() bool {
	if m != nil {
		return m.Reverse
	}
	return false
}

func (m *SchemaNode) GetCount() bool {
	if m != nil {
		return m.Count
	}
	return false
}

func (m *SchemaNode) GetList() bool {
	if m != nil {
		return m.List
	}
	return false
}

func (m *SchemaNode) GetUpsert() bool {
	if m != nil {
		return m.Upsert
	}
	return false
}

func (m *SchemaNode) GetLang() bool {
	if m != nil {
		return m.Lang
	}
	return false
}

func (m *SchemaNode) GetNoConflict() bool {
	if m != nil {
		return m.NoConflict
	}
	return false
}

type SchemaResult struct {
	Schema []*SchemaNode `protobuf:"bytes,1,rep,name=schema,proto3" json:"schema,omitempty"` // Deprecated: Do not use.
}

func (m *SchemaResult) Reset()         { *m = SchemaResult{} }
func (m *SchemaResult) String() string { return proto.CompactTextString(m) }
func (*SchemaResult) ProtoMessage()    {}
func (*SchemaResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{39}
}
func (m *SchemaResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchemaResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchemaResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaResult.Merge(m, src)
}
func (m *SchemaResult) XXX_Size() int {
	return m.Size()
}
func (m *SchemaResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaResult.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaResult proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *SchemaResult) GetSchema() []*SchemaNode {
	if m != nil {
		return m.Schema
	}
	return nil
}

type SchemaUpdate struct {
	Predicate string                 `protobuf:"bytes,1,opt,name=predicate,proto3" json:"predicate,omitempty"`
	ValueType Posting_ValType        `protobuf:"varint,2,opt,name=value_type,json=valueType,proto3,enum=pb.Posting_ValType" json:"value_type,omitempty"`
	Directive SchemaUpdate_Directive `protobuf:"varint,3,opt,name=directive,proto3,enum=pb.SchemaUpdate_Directive" json:"directive,omitempty"`
	Tokenizer []string               `protobuf:"bytes,4,rep,name=tokenizer,proto3" json:"tokenizer,omitempty"`
	Count     bool                   `protobuf:"varint,5,opt,name=count,proto3" json:"count,omitempty"`
	List      bool                   `protobuf:"varint,6,opt,name=list,proto3" json:"list,omitempty"`
	Upsert    bool                   `protobuf:"varint,8,opt,name=upsert,proto3" json:"upsert,omitempty"`
	Lang      bool                   `protobuf:"varint,9,opt,name=lang,proto3" json:"lang,omitempty"`
	// Fields required for type system.
	NonNullable     bool `protobuf:"varint,10,opt,name=non_nullable,json=nonNullable,proto3" json:"non_nullable,omitempty"`
	NonNullableList bool `protobuf:"varint,11,opt,name=non_nullable_list,json=nonNullableList,proto3" json:"non_nullable_list,omitempty"`
	// If value_type is OBJECT, then this represents an object type with a
	// custom name. This field stores said name.
	ObjectTypeName string `protobuf:"bytes,12,opt,name=object_type_name,json=objectTypeName,proto3" json:"object_type_name,omitempty"`
	NoConflict     bool   `protobuf:"varint,13,opt,name=no_conflict,json=noConflict,proto3" json:"no_conflict,omitempty"`
}

func (m *SchemaUpdate) Reset()         { *m = SchemaUpdate{} }
func (m *SchemaUpdate) String() string { return proto.CompactTextString(m) }
func (*SchemaUpdate) ProtoMessage()    {}
func (*SchemaUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{40}
}
func (m *SchemaUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchemaUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchemaUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaUpdate.Merge(m, src)
}
func (m *SchemaUpdate) XXX_Size() int {
	return m.Size()
}
func (m *SchemaUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaUpdate proto.InternalMessageInfo

func (m *SchemaUpdate) GetPredicate() string {
	if m != nil {
		return m.Predicate
	}
	return ""
}

func (m *SchemaUpdate) GetValueType() Posting_ValType {
	if m != nil {
		return m.ValueType
	}
	return Posting_DEFAULT
}

func (m *SchemaUpdate) GetDirective() SchemaUpdate_Directive {
	if m != nil {
		return m.Directive
	}
	return SchemaUpdate_NONE
}

func (m *SchemaUpdate) GetTokenizer() []string {
	if m != nil {
		return m.Tokenizer
	}
	return nil
}

func (m *SchemaUpdate) GetCount() bool {
	if m != nil {
		return m.Count
	}
	return false
}

func (m *SchemaUpdate) GetList() bool {
	if m != nil {
		return m.List
	}
	return false
}

func (m *SchemaUpdate) GetUpsert() bool {
	if m != nil {
		return m.Upsert
	}
	return false
}

func (m *SchemaUpdate) GetLang() bool {
	if m != nil {
		return m.Lang
	}
	return false
}

func (m *SchemaUpdate) GetNonNullable() bool {
	if m != nil {
		return m.NonNullable
	}
	return false
}

func (m *SchemaUpdate) GetNonNullableList() bool {
	if m != nil {
		return m.NonNullableList
	}
	return false
}

func (m *SchemaUpdate) GetObjectTypeName() string {
	if m != nil {
		return m.ObjectTypeName
	}
	return ""
}

func (m *SchemaUpdate) GetNoConflict() bool {
	if m != nil {
		return m.NoConflict
	}
	return false
}

type TypeUpdate struct {
	TypeName string          `protobuf:"bytes,1,opt,name=type_name,json=typeName,proto3" json:"type_name,omitempty"`
	Fields   []*SchemaUpdate `protobuf:"bytes,2,rep,name=fields,proto3" json:"fields,omitempty"`
}

func (m *TypeUpdate) Reset()         { *m = TypeUpdate{} }
func (m *TypeUpdate) String() string { return proto.CompactTextString(m) }
func (*TypeUpdate) ProtoMessage()    {}
func (*TypeUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{41}
}
func (m *TypeUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypeUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TypeUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeUpdate.Merge(m, src)
}
func (m *TypeUpdate) XXX_Size() int {
	return m.Size()
}
func (m *TypeUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_TypeUpdate proto.InternalMessageInfo

func (m *TypeUpdate) GetTypeName() string {
	if m != nil {
		return m.TypeName
	}
	return ""
}

func (m *TypeUpdate) GetFields() []*SchemaUpdate {
	if m != nil {
		return m.Fields
	}
	return nil
}

type MapHeader struct {
	PartitionKeys [][]byte `protobuf:"bytes,1,rep,name=partition_keys,json=partitionKeys,proto3" json:"partition_keys,omitempty"`
}

func (m *MapHeader) Reset()         { *m = MapHeader{} }
func (m *MapHeader) String() string { return proto.CompactTextString(m) }
func (*MapHeader) ProtoMessage()    {}
func (*MapHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{42}
}
func (m *MapHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MapHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MapHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MapHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MapHeader.Merge(m, src)
}
func (m *MapHeader) XXX_Size() int {
	return m.Size()
}
func (m *MapHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_MapHeader.DiscardUnknown(m)
}

var xxx_messageInfo_MapHeader proto.InternalMessageInfo

func (m *MapHeader) GetPartitionKeys() [][]byte {
	if m != nil {
		return m.PartitionKeys
	}
	return nil
}

type MovePredicatePayload struct {
	Predicate        string `protobuf:"bytes,1,opt,name=predicate,proto3" json:"predicate,omitempty"`
	SourceGid        uint32 `protobuf:"varint,2,opt,name=source_gid,json=sourceGid,proto3" json:"source_gid,omitempty"`
	DestGid          uint32 `protobuf:"varint,3,opt,name=dest_gid,json=destGid,proto3" json:"dest_gid,omitempty"`
	TxnTs            uint64 `protobuf:"varint,4,opt,name=txn_ts,json=txnTs,proto3" json:"txn_ts,omitempty"`
	ExpectedChecksum uint64 `protobuf:"varint,5,opt,name=expected_checksum,json=expectedChecksum,proto3" json:"expected_checksum,omitempty"`
}

func (m *MovePredicatePayload) Reset()         { *m = MovePredicatePayload{} }
func (m *MovePredicatePayload) String() string { return proto.CompactTextString(m) }
func (*MovePredicatePayload) ProtoMessage()    {}
func (*MovePredicatePayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{43}
}
func (m *MovePredicatePayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MovePredicatePayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MovePredicatePayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MovePredicatePayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MovePredicatePayload.Merge(m, src)
}
func (m *MovePredicatePayload) XXX_Size() int {
	return m.Size()
}
func (m *MovePredicatePayload) XXX_DiscardUnknown() {
	xxx_messageInfo_MovePredicatePayload.DiscardUnknown(m)
}

var xxx_messageInfo_MovePredicatePayload proto.InternalMessageInfo

func (m *MovePredicatePayload) GetPredicate() string {
	if m != nil {
		return m.Predicate
	}
	return ""
}

func (m *MovePredicatePayload) GetSourceGid() uint32 {
	if m != nil {
		return m.SourceGid
	}
	return 0
}

func (m *MovePredicatePayload) GetDestGid() uint32 {
	if m != nil {
		return m.DestGid
	}
	return 0
}

func (m *MovePredicatePayload) GetTxnTs() uint64 {
	if m != nil {
		return m.TxnTs
	}
	return 0
}

func (m *MovePredicatePayload) GetExpectedChecksum() uint64 {
	if m != nil {
		return m.ExpectedChecksum
	}
	return 0
}

type TxnStatus struct {
	StartTs  uint64 `protobuf:"varint,1,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	CommitTs uint64 `protobuf:"varint,2,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
}

func (m *TxnStatus) Reset()         { *m = TxnStatus{} }
func (m *TxnStatus) String() string { return proto.CompactTextString(m) }
func (*TxnStatus) ProtoMessage()    {}
func (*TxnStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{44}
}
func (m *TxnStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnStatus.Merge(m, src)
}
func (m *TxnStatus) XXX_Size() int {
	return m.Size()
}
func (m *TxnStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnStatus.DiscardUnknown(m)
}

var xxx_messageInfo_TxnStatus proto.InternalMessageInfo

func (m *TxnStatus) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *TxnStatus) GetCommitTs() uint64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

type OracleDelta struct {
	Txns           []*TxnStatus      `protobuf:"bytes,1,rep,name=txns,proto3" json:"txns,omitempty"`
	MaxAssigned    uint64            `protobuf:"varint,2,opt,name=max_assigned,json=maxAssigned,proto3" json:"max_assigned,omitempty"`
	GroupChecksums map[uint32]uint64 `protobuf:"bytes,3,rep,name=group_checksums,json=groupChecksums,proto3" json:"group_checksums,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *OracleDelta) Reset()         { *m = OracleDelta{} }
func (m *OracleDelta) String() string { return proto.CompactTextString(m) }
func (*OracleDelta) ProtoMessage()    {}
func (*OracleDelta) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{45}
}
func (m *OracleDelta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleDelta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleDelta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleDelta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleDelta.Merge(m, src)
}
func (m *OracleDelta) XXX_Size() int {
	return m.Size()
}
func (m *OracleDelta) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleDelta.DiscardUnknown(m)
}

var xxx_messageInfo_OracleDelta proto.InternalMessageInfo

func (m *OracleDelta) GetTxns() []*TxnStatus {
	if m != nil {
		return m.Txns
	}
	return nil
}

func (m *OracleDelta) GetMaxAssigned() uint64 {
	if m != nil {
		return m.MaxAssigned
	}
	return 0
}

func (m *OracleDelta) GetGroupChecksums() map[uint32]uint64 {
	if m != nil {
		return m.GroupChecksums
	}
	return nil
}

type TxnTimestamps struct {
	Ts []uint64 `protobuf:"varint,1,rep,packed,name=ts,proto3" json:"ts,omitempty"`
}

func (m *TxnTimestamps) Reset()         { *m = TxnTimestamps{} }
func (m *TxnTimestamps) String() string { return proto.CompactTextString(m) }
func (*TxnTimestamps) ProtoMessage()    {}
func (*TxnTimestamps) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{46}
}
func (m *TxnTimestamps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnTimestamps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnTimestamps.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnTimestamps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnTimestamps.Merge(m, src)
}
func (m *TxnTimestamps) XXX_Size() int {
	return m.Size()
}
func (m *TxnTimestamps) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnTimestamps.DiscardUnknown(m)
}

var xxx_messageInfo_TxnTimestamps proto.InternalMessageInfo

func (m *TxnTimestamps) GetTs() []uint64 {
	if m != nil {
		return m.Ts
	}
	return nil
}

type PeerResponse struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *PeerResponse) Reset()         { *m = PeerResponse{} }
func (m *PeerResponse) String() string { return proto.CompactTextString(m) }
func (*PeerResponse) ProtoMessage()    {}
func (*PeerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{47}
}
func (m *PeerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerResponse.Merge(m, src)
}
func (m *PeerResponse) XXX_Size() int {
	return m.Size()
}
func (m *PeerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PeerResponse proto.InternalMessageInfo

func (m *PeerResponse) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type RaftBatch struct {
	Context *RaftContext `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Payload *api.Payload `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *RaftBatch) Reset()         { *m = RaftBatch{} }
func (m *RaftBatch) String() string { return proto.CompactTextString(m) }
func (*RaftBatch) ProtoMessage()    {}
func (*RaftBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{48}
}
func (m *RaftBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftBatch.Merge(m, src)
}
func (m *RaftBatch) XXX_Size() int {
	return m.Size()
}
func (m *RaftBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftBatch.DiscardUnknown(m)
}

var xxx_messageInfo_RaftBatch proto.InternalMessageInfo

func (m *RaftBatch) GetContext() *RaftContext {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *RaftBatch) GetPayload() *api.Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type SubscriptionRequest struct {
	Prefixes [][]byte `protobuf:"bytes,1,rep,name=prefixes,proto3" json:"prefixes,omitempty"`
}

func (m *SubscriptionRequest) Reset()         { *m = SubscriptionRequest{} }
func (m *SubscriptionRequest) String() string { return proto.CompactTextString(m) }
func (*SubscriptionRequest) ProtoMessage()    {}
func (*SubscriptionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{49}
}
func (m *SubscriptionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscriptionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscriptionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionRequest.Merge(m, src)
}
func (m *SubscriptionRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubscriptionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionRequest proto.InternalMessageInfo

func (m *SubscriptionRequest) GetPrefixes() [][]byte {
	if m != nil {
		return m.Prefixes
	}
	return nil
}

type SubscriptionResponse struct {
	Kvs *pb.KVList `protobuf:"bytes,1,opt,name=kvs,proto3" json:"kvs,omitempty"`
}

func (m *SubscriptionResponse) Reset()         { *m = SubscriptionResponse{} }
func (m *SubscriptionResponse) String() string { return proto.CompactTextString(m) }
func (*SubscriptionResponse) ProtoMessage()    {}
func (*SubscriptionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{50}
}
func (m *SubscriptionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscriptionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscriptionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionResponse.Merge(m, src)
}
func (m *SubscriptionResponse) XXX_Size() int {
	return m.Size()
}
func (m *SubscriptionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionResponse proto.InternalMessageInfo

func (m *SubscriptionResponse) GetKvs() *pb.KVList {
	if m != nil {
		return m.Kvs
	}
	return nil
}

type Num struct {
	Val       uint64       `protobuf:"varint,1,opt,name=val,proto3" json:"val,omitempty"`
	ReadOnly  bool         `protobuf:"varint,2,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	Forwarded bool         `protobuf:"varint,3,opt,name=forwarded,proto3" json:"forwarded,omitempty"`
	Type      NumLeaseType `protobuf:"varint,4,opt,name=type,proto3,enum=pb.NumLeaseType" json:"type,omitempty"`
}

func (m *Num) Reset()         { *m = Num{} }
func (m *Num) String() string { return proto.CompactTextString(m) }
func (*Num) ProtoMessage()    {}
func (*Num) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{51}
}
func (m *Num) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Num) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Num.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Num) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Num.Merge(m, src)
}
func (m *Num) XXX_Size() int {
	return m.Size()
}
func (m *Num) XXX_DiscardUnknown() {
	xxx_messageInfo_Num.DiscardUnknown(m)
}

var xxx_messageInfo_Num proto.InternalMessageInfo

func (m *Num) GetVal() uint64 {
	if m != nil {
		return m.Val
	}
	return 0
}

func (m *Num) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *Num) GetForwarded() bool {
	if m != nil {
		return m.Forwarded
	}
	return false
}

func (m *Num) GetType() NumLeaseType {
	if m != nil {
		return m.Type
	}
	return Num_NS_ID
}

type AssignedIds struct {
	StartId uint64 `protobuf:"varint,1,opt,name=startId,proto3" json:"startId,omitempty"`
	EndId   uint64 `protobuf:"varint,2,opt,name=endId,proto3" json:"endId,omitempty"`
	// The following is used for read only transactions.
	ReadOnly uint64 `protobuf:"varint,5,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
}

func (m *AssignedIds) Reset()         { *m = AssignedIds{} }
func (m *AssignedIds) String() string { return proto.CompactTextString(m) }
func (*AssignedIds) ProtoMessage()    {}
func (*AssignedIds) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{52}
}
func (m *AssignedIds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssignedIds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssignedIds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssignedIds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssignedIds.Merge(m, src)
}
func (m *AssignedIds) XXX_Size() int {
	return m.Size()
}
func (m *AssignedIds) XXX_DiscardUnknown() {
	xxx_messageInfo_AssignedIds.DiscardUnknown(m)
}

var xxx_messageInfo_AssignedIds proto.InternalMessageInfo

func (m *AssignedIds) GetStartId() uint64 {
	if m != nil {
		return m.StartId
	}
	return 0
}

func (m *AssignedIds) GetEndId() uint64 {
	if m != nil {
		return m.EndId
	}
	return 0
}

func (m *AssignedIds) GetReadOnly() uint64 {
	if m != nil {
		return m.ReadOnly
	}
	return 0
}

type SnapshotMeta struct {
	ClientTs uint64 `protobuf:"varint,1,opt,name=client_ts,json=clientTs,proto3" json:"client_ts,omitempty"`
	GroupId  uint32 `protobuf:"varint,2,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
}

func (m *SnapshotMeta) Reset()         { *m = SnapshotMeta{} }
func (m *SnapshotMeta) String() string { return proto.CompactTextString(m) }
func (*SnapshotMeta) ProtoMessage()    {}
func (*SnapshotMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{53}
}
func (m *SnapshotMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotMeta.Merge(m, src)
}
func (m *SnapshotMeta) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotMeta.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotMeta proto.InternalMessageInfo

func (m *SnapshotMeta) GetClientTs() uint64 {
	if m != nil {
		return m.ClientTs
	}
	return 0
}

func (m *SnapshotMeta) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

// Status describes a general status response.
// code: 0 = success, 0 != failure.
type Status struct {
	Code int32  `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg  string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *Status) Reset()         { *m = Status{} }
func (m *Status) String() string { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()    {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{54}
}
func (m *Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(m, src)
}
func (m *Status) XXX_Size() int {
	return m.Size()
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

func (m *Status) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Status) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type BackupRequest struct {
	ReadTs       uint64 `protobuf:"varint,1,opt,name=read_ts,json=readTs,proto3" json:"read_ts,omitempty"`
	SinceTs      uint64 `protobuf:"varint,2,opt,name=since_ts,json=sinceTs,proto3" json:"since_ts,omitempty"`
	GroupId      uint32 `protobuf:"varint,3,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	UnixTs       string `protobuf:"bytes,4,opt,name=unix_ts,json=unixTs,proto3" json:"unix_ts,omitempty"`
	Destination  string `protobuf:"bytes,5,opt,name=destination,proto3" json:"destination,omitempty"`
	AccessKey    string `protobuf:"bytes,6,opt,name=access_key,json=accessKey,proto3" json:"access_key,omitempty"`
	SecretKey    string `protobuf:"bytes,7,opt,name=secret_key,json=secretKey,proto3" json:"secret_key,omitempty"`
	SessionToken string `protobuf:"bytes,8,opt,name=session_token,json=sessionToken,proto3" json:"session_token,omitempty"`
	// True if no credentials should be used to access the S3 or minio bucket.
	// For example, when using a bucket with a public policy.
	Anonymous bool `protobuf:"varint,9,opt,name=anonymous,proto3" json:"anonymous,omitempty"`
	// The predicates to backup. All other predicates present in the group (e.g
	// stale data from a predicate move) will be ignored.
	Predicates []string `protobuf:"bytes,10,rep,name=predicates,proto3" json:"predicates,omitempty"`
}

func (m *BackupRequest) Reset()         { *m = BackupRequest{} }
func (m *BackupRequest) String() string { return proto.CompactTextString(m) }
func (*BackupRequest) ProtoMessage()    {}
func (*BackupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{55}
}
func (m *BackupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupRequest.Merge(m, src)
}
func (m *BackupRequest) XXX_Size() int {
	return m.Size()
}
func (m *BackupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BackupRequest proto.InternalMessageInfo

func (m *BackupRequest) GetReadTs() uint64 {
	if m != nil {
		return m.ReadTs
	}
	return 0
}

func (m *BackupRequest) GetSinceTs() uint64 {
	if m != nil {
		return m.SinceTs
	}
	return 0
}

func (m *BackupRequest) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *BackupRequest) GetUnixTs() string {
	if m != nil {
		return m.UnixTs
	}
	return ""
}

func (m *BackupRequest) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *BackupRequest) GetAccessKey() string {
	if m != nil {
		return m.AccessKey
	}
	return ""
}

func (m *BackupRequest) GetSecretKey() string {
	if m != nil {
		return m.SecretKey
	}
	return ""
}

func (m *BackupRequest) GetSessionToken() string {
	if m != nil {
		return m.SessionToken
	}
	return ""
}

func (m *BackupRequest) GetAnonymous() bool {
	if m != nil {
		return m.Anonymous
	}
	return false
}

func (m *BackupRequest) GetPredicates() []string {
	if m != nil {
		return m.Predicates
	}
	return nil
}

type BackupResponse struct {
	DropOperations []*DropOperation `protobuf:"bytes,1,rep,name=drop_operations,json=dropOperations,proto3" json:"drop_operations,omitempty"`
}

func (m *BackupResponse) Reset()         { *m = BackupResponse{} }
func (m *BackupResponse) String() string { return proto.CompactTextString(m) }
func (*BackupResponse) ProtoMessage()    {}
func (*BackupResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{56}
}
func (m *BackupResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupResponse.Merge(m, src)
}
func (m *BackupResponse) XXX_Size() int {
	return m.Size()
}
func (m *BackupResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BackupResponse proto.InternalMessageInfo

func (m *BackupResponse) GetDropOperations() []*DropOperation {
	if m != nil {
		return m.DropOperations
	}
	return nil
}

type DropOperation struct {
	DropOp DropOperation_DropOp `protobuf:"varint,1,opt,name=drop_op,json=dropOp,proto3,enum=pb.DropOperation_DropOp" json:"drop_op,omitempty"`
	// When drop_op is ATTR, drop_value will be the name of the ATTR; empty otherwise.
	DropValue string `protobuf:"bytes,2,opt,name=drop_value,json=dropValue,proto3" json:"drop_value,omitempty"`
}

func (m *DropOperation) Reset()         { *m = DropOperation{} }
func (m *DropOperation) String() string { return proto.CompactTextString(m) }
func (*DropOperation) ProtoMessage()    {}
func (*DropOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{57}
}
func (m *DropOperation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropOperation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropOperation.Merge(m, src)
}
func (m *DropOperation) XXX_Size() int {
	return m.Size()
}
func (m *DropOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_DropOperation.DiscardUnknown(m)
}

var xxx_messageInfo_DropOperation proto.InternalMessageInfo

func (m *DropOperation) GetDropOp() DropOperation_DropOp {
	if m != nil {
		return m.DropOp
	}
	return DropOperation_ALL
}

func (m *DropOperation) GetDropValue() string {
	if m != nil {
		return m.DropValue
	}
	return ""
}

type ExportRequest struct {
	GroupId     uint32 `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	ReadTs      uint64 `protobuf:"varint,2,opt,name=read_ts,json=readTs,proto3" json:"read_ts,omitempty"`
	UnixTs      int64  `protobuf:"varint,3,opt,name=unix_ts,json=unixTs,proto3" json:"unix_ts,omitempty"`
	Format      string `protobuf:"bytes,4,opt,name=format,proto3" json:"format,omitempty"`
	Destination string `protobuf:"bytes,5,opt,name=destination,proto3" json:"destination,omitempty"`
	// These credentials are used to access the S3 or minio bucket.
	AccessKey    string `protobuf:"bytes,6,opt,name=access_key,json=accessKey,proto3" json:"access_key,omitempty"`
	SecretKey    string `protobuf:"bytes,7,opt,name=secret_key,json=secretKey,proto3" json:"secret_key,omitempty"`
	SessionToken string `protobuf:"bytes,8,opt,name=session_token,json=sessionToken,proto3" json:"session_token,omitempty"`
	Anonymous    bool   `protobuf:"varint,9,opt,name=anonymous,proto3" json:"anonymous,omitempty"`
}

func (m *ExportRequest) Reset()         { *m = ExportRequest{} }
func (m *ExportRequest) String() string { return proto.CompactTextString(m) }
func (*ExportRequest) ProtoMessage()    {}
func (*ExportRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{58}
}
func (m *ExportRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExportRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExportRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportRequest.Merge(m, src)
}
func (m *ExportRequest) XXX_Size() int {
	return m.Size()
}
func (m *ExportRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExportRequest proto.InternalMessageInfo

func (m *ExportRequest) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *ExportRequest) GetReadTs() uint64 {
	if m != nil {
		return m.ReadTs
	}
	return 0
}

func (m *ExportRequest) GetUnixTs() int64 {
	if m != nil {
		return m.UnixTs
	}
	return 0
}

func (m *ExportRequest) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *ExportRequest) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *ExportRequest) GetAccessKey() string {
	if m != nil {
		return m.AccessKey
	}
	return ""
}

func (m *ExportRequest) GetSecretKey() string {
	if m != nil {
		return m.SecretKey
	}
	return ""
}

func (m *ExportRequest) GetSessionToken() string {
	if m != nil {
		return m.SessionToken
	}
	return ""
}

func (m *ExportRequest) GetAnonymous() bool {
	if m != nil {
		return m.Anonymous
	}
	return false
}

type ExportResponse struct {
	// 0 indicates a success, and a non-zero code indicates failure
	Code  int32    `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg   string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Files []string `protobuf:"bytes,3,rep,name=files,proto3" json:"files,omitempty"`
}

func (m *ExportResponse) Reset()         { *m = ExportResponse{} }
func (m *ExportResponse) String() string { return proto.CompactTextString(m) }
func (*ExportResponse) ProtoMessage()    {}
func (*ExportResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{59}
}
func (m *ExportResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExportResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExportResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportResponse.Merge(m, src)
}
func (m *ExportResponse) XXX_Size() int {
	return m.Size()
}
func (m *ExportResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExportResponse proto.InternalMessageInfo

func (m *ExportResponse) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ExportResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ExportResponse) GetFiles() []string {
	if m != nil {
		return m.Files
	}
	return nil
}

// A key stored in the format used for writing backups.
type BackupKey struct {
	Type     BackupKey_KeyType `protobuf:"varint,1,opt,name=type,proto3,enum=pb.BackupKey_KeyType" json:"type,omitempty"`
	Attr     string            `protobuf:"bytes,2,opt,name=attr,proto3" json:"attr,omitempty"`
	Uid      uint64            `protobuf:"varint,3,opt,name=uid,proto3" json:"uid,omitempty"`
	StartUid uint64            `protobuf:"varint,4,opt,name=start_uid,json=startUid,proto3" json:"start_uid,omitempty"`
	Term     string            `protobuf:"bytes,5,opt,name=term,proto3" json:"term,omitempty"`
	Count    uint32            `protobuf:"varint,6,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *BackupKey) Reset()         { *m = BackupKey{} }
func (m *BackupKey) String() string { return proto.CompactTextString(m) }
func (*BackupKey) ProtoMessage()    {}
func (*BackupKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{60}
}
func (m *BackupKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupKey.Merge(m, src)
}
func (m *BackupKey) XXX_Size() int {
	return m.Size()
}
func (m *BackupKey) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupKey.DiscardUnknown(m)
}

var xxx_messageInfo_BackupKey proto.InternalMessageInfo

func (m *BackupKey) GetType() BackupKey_KeyType {
	if m != nil {
		return m.Type
	}
	return BackupKey_UNKNOWN
}

func (m *BackupKey) GetAttr() string {
	if m != nil {
		return m.Attr
	}
	return ""
}

func (m *BackupKey) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *BackupKey) GetStartUid() uint64 {
	if m != nil {
		return m.StartUid
	}
	return 0
}

func (m *BackupKey) GetTerm() string {
	if m != nil {
		return m.Term
	}
	return ""
}

func (m *BackupKey) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// A posting list stored in the format used for writing backups.
type BackupPostingList struct {
	Uids     []uint64   `protobuf:"varint,1,rep,packed,name=uids,proto3" json:"uids,omitempty"`
	Postings []*Posting `protobuf:"bytes,2,rep,name=postings,proto3" json:"postings,omitempty"`
	CommitTs uint64     `protobuf:"varint,3,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	Splits   []uint64   `protobuf:"varint,4,rep,packed,name=splits,proto3" json:"splits,omitempty"`
	UidBytes []byte     `protobuf:"bytes,5,opt,name=uid_bytes,json=uidBytes,proto3" json:"uid_bytes,omitempty"`
}

func (m *BackupPostingList) Reset()         { *m = BackupPostingList{} }
func (m *BackupPostingList) String() string { return proto.CompactTextString(m) }
func (*BackupPostingList) ProtoMessage()    {}
func (*BackupPostingList) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{61}
}
func (m *BackupPostingList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupPostingList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupPostingList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupPostingList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupPostingList.Merge(m, src)
}
func (m *BackupPostingList) XXX_Size() int {
	return m.Size()
}
func (m *BackupPostingList) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupPostingList.DiscardUnknown(m)
}

var xxx_messageInfo_BackupPostingList proto.InternalMessageInfo

func (m *BackupPostingList) GetUids() []uint64 {
	if m != nil {
		return m.Uids
	}
	return nil
}

func (m *BackupPostingList) GetPostings() []*Posting {
	if m != nil {
		return m.Postings
	}
	return nil
}

func (m *BackupPostingList) GetCommitTs() uint64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

func (m *BackupPostingList) GetSplits() []uint64 {
	if m != nil {
		return m.Splits
	}
	return nil
}

func (m *BackupPostingList) GetUidBytes() []byte {
	if m != nil {
		return m.UidBytes
	}
	return nil
}

type UpdateGraphQLSchemaRequest struct {
	StartTs       uint64          `protobuf:"varint,1,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	GraphqlSchema string          `protobuf:"bytes,2,opt,name=graphql_schema,json=graphqlSchema,proto3" json:"graphql_schema,omitempty"`
	DgraphPreds   []*SchemaUpdate `protobuf:"bytes,3,rep,name=dgraph_preds,json=dgraphPreds,proto3" json:"dgraph_preds,omitempty"`
	DgraphTypes   []*TypeUpdate   `protobuf:"bytes,4,rep,name=dgraph_types,json=dgraphTypes,proto3" json:"dgraph_types,omitempty"`
}

func (m *UpdateGraphQLSchemaRequest) Reset()         { *m = UpdateGraphQLSchemaRequest{} }
func (m *UpdateGraphQLSchemaRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateGraphQLSchemaRequest) ProtoMessage()    {}
func (*UpdateGraphQLSchemaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{62}
}
func (m *UpdateGraphQLSchemaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGraphQLSchemaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGraphQLSchemaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGraphQLSchemaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGraphQLSchemaRequest.Merge(m, src)
}
func (m *UpdateGraphQLSchemaRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGraphQLSchemaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGraphQLSchemaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGraphQLSchemaRequest proto.InternalMessageInfo

func (m *UpdateGraphQLSchemaRequest) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *UpdateGraphQLSchemaRequest) GetGraphqlSchema() string {
	if m != nil {
		return m.GraphqlSchema
	}
	return ""
}

func (m *UpdateGraphQLSchemaRequest) GetDgraphPreds() []*SchemaUpdate {
	if m != nil {
		return m.DgraphPreds
	}
	return nil
}

func (m *UpdateGraphQLSchemaRequest) GetDgraphTypes() []*TypeUpdate {
	if m != nil {
		return m.DgraphTypes
	}
	return nil
}

type UpdateGraphQLSchemaResponse struct {
	Uid uint64 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
}

func (m *UpdateGraphQLSchemaResponse) Reset()         { *m = UpdateGraphQLSchemaResponse{} }
func (m *UpdateGraphQLSchemaResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateGraphQLSchemaResponse) ProtoMessage()    {}
func (*UpdateGraphQLSchemaResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{63}
}
func (m *UpdateGraphQLSchemaResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGraphQLSchemaResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGraphQLSchemaResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGraphQLSchemaResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGraphQLSchemaResponse.Merge(m, src)
}
func (m *UpdateGraphQLSchemaResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGraphQLSchemaResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGraphQLSchemaResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGraphQLSchemaResponse proto.InternalMessageInfo

func (m *UpdateGraphQLSchemaResponse) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

// BulkMeta stores metadata from the map phase of the bulk loader.
type BulkMeta struct {
	EdgeCount int64                    `protobuf:"varint,1,opt,name=edge_count,json=edgeCount,proto3" json:"edge_count,omitempty"`
	SchemaMap map[string]*SchemaUpdate `protobuf:"bytes,2,rep,name=schema_map,json=schemaMap,proto3" json:"schema_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *BulkMeta) Reset()         { *m = BulkMeta{} }
func (m *BulkMeta) String() string { return proto.CompactTextString(m) }
func (*BulkMeta) ProtoMessage()    {}
func (*BulkMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{64}
}
func (m *BulkMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BulkMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BulkMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BulkMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BulkMeta.Merge(m, src)
}
func (m *BulkMeta) XXX_Size() int {
	return m.Size()
}
func (m *BulkMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_BulkMeta.DiscardUnknown(m)
}

var xxx_messageInfo_BulkMeta proto.InternalMessageInfo

func (m *BulkMeta) GetEdgeCount() int64 {
	if m != nil {
		return m.EdgeCount
	}
	return 0
}

func (m *BulkMeta) GetSchemaMap() map[string]*SchemaUpdate {
	if m != nil {
		return m.SchemaMap
	}
	return nil
}

func init() {
	proto.RegisterEnum("pb.DirectedEdge_Op", DirectedEdge_Op_name, DirectedEdge_Op_value)
	proto.RegisterEnum("pb.Mutations_DropOp", Mutations_DropOp_name, Mutations_DropOp_value)
	proto.RegisterEnum("pb.Metadata_HintType", Metadata_HintType_name, Metadata_HintType_value)
	proto.RegisterEnum("pb.Posting_ValType", Posting_ValType_name, Posting_ValType_value)
	proto.RegisterEnum("pb.Posting_PostingType", Posting_PostingType_name, Posting_PostingType_value)
	proto.RegisterEnum("pb.SchemaUpdate_Directive", SchemaUpdate_Directive_name, SchemaUpdate_Directive_value)
	proto.RegisterEnum("pb.NumLeaseType", NumLeaseType_name, NumLeaseType_value)
	proto.RegisterEnum("pb.DropOperation_DropOp", DropOperation_DropOp_name, DropOperation_DropOp_value)
	proto.RegisterEnum("pb.BackupKey_KeyType", BackupKey_KeyType_name, BackupKey_KeyType_value)
	proto.RegisterType((*List)(nil), "pb.List")
	proto.RegisterType((*TaskValue)(nil), "pb.TaskValue")
	proto.RegisterType((*SrcFunction)(nil), "pb.SrcFunction")
	proto.RegisterType((*Query)(nil), "pb.Query")
	proto.RegisterType((*ValueList)(nil), "pb.ValueList")
	proto.RegisterType((*LangList)(nil), "pb.LangList")
	proto.RegisterType((*Result)(nil), "pb.Result")
	proto.RegisterType((*Order)(nil), "pb.Order")
	proto.RegisterType((*SortMessage)(nil), "pb.SortMessage")
	proto.RegisterType((*SortResult)(nil), "pb.SortResult")
	proto.RegisterType((*RaftContext)(nil), "pb.RaftContext")
	proto.RegisterType((*Member)(nil), "pb.Member")
	proto.RegisterType((*Group)(nil), "pb.Group")
	proto.RegisterMapType((map[uint64]*Member)(nil), "pb.Group.MembersEntry")
	proto.RegisterMapType((map[string]*Tablet)(nil), "pb.Group.TabletsEntry")
	proto.RegisterType((*License)(nil), "pb.License")
	proto.RegisterType((*ZeroProposal)(nil), "pb.ZeroProposal")
	proto.RegisterMapType((map[uint32]uint64)(nil), "pb.ZeroProposal.SnapshotTsEntry")
	proto.RegisterType((*MembershipState)(nil), "pb.MembershipState")
	proto.RegisterMapType((map[uint32]*Group)(nil), "pb.MembershipState.GroupsEntry")
	proto.RegisterMapType((map[uint64]*Member)(nil), "pb.MembershipState.ZerosEntry")
	proto.RegisterType((*ConnectionState)(nil), "pb.ConnectionState")
	proto.RegisterType((*HealthInfo)(nil), "pb.HealthInfo")
	proto.RegisterType((*Tablet)(nil), "pb.Tablet")
	proto.RegisterType((*DirectedEdge)(nil), "pb.DirectedEdge")
	proto.RegisterType((*Mutations)(nil), "pb.Mutations")
	proto.RegisterType((*Metadata)(nil), "pb.Metadata")
	proto.RegisterMapType((map[string]Metadata_HintType)(nil), "pb.Metadata.PredHintsEntry")
	proto.RegisterType((*Snapshot)(nil), "pb.Snapshot")
	proto.RegisterType((*ZeroSnapshot)(nil), "pb.ZeroSnapshot")
	proto.RegisterType((*RestoreRequest)(nil), "pb.RestoreRequest")
	proto.RegisterType((*Proposal)(nil), "pb.Proposal")
	proto.RegisterType((*KVS)(nil), "pb.KVS")
	proto.RegisterType((*Posting)(nil), "pb.Posting")
	proto.RegisterType((*UidBlock)(nil), "pb.UidBlock")
	proto.RegisterType((*UidPack)(nil), "pb.UidPack")
	proto.RegisterType((*PostingList)(nil), "pb.PostingList")
	proto.RegisterType((*FacetParam)(nil), "pb.FacetParam")
	proto.RegisterType((*FacetParams)(nil), "pb.FacetParams")
	proto.RegisterType((*Facets)(nil), "pb.Facets")
	proto.RegisterType((*FacetsList)(nil), "pb.FacetsList")
	proto.RegisterType((*Function)(nil), "pb.Function")
	proto.RegisterType((*FilterTree)(nil), "pb.FilterTree")
	proto.RegisterType((*SchemaRequest)(nil), "pb.SchemaRequest")
	proto.RegisterType((*SchemaNode)(nil), "pb.SchemaNode")
	proto.RegisterType((*SchemaResult)(nil), "pb.SchemaResult")
	proto.RegisterType((*SchemaUpdate)(nil), "pb.SchemaUpdate")
	proto.RegisterType((*TypeUpdate)(nil), "pb.TypeUpdate")
	proto.RegisterType((*MapHeader)(nil), "pb.MapHeader")
	proto.RegisterType((*MovePredicatePayload)(nil), "pb.MovePredicatePayload")
	proto.RegisterType((*TxnStatus)(nil), "pb.TxnStatus")
	proto.RegisterType((*OracleDelta)(nil), "pb.OracleDelta")
	proto.RegisterMapType((map[uint32]uint64)(nil), "pb.OracleDelta.GroupChecksumsEntry")
	proto.RegisterType((*TxnTimestamps)(nil), "pb.TxnTimestamps")
	proto.RegisterType((*PeerResponse)(nil), "pb.PeerResponse")
	proto.RegisterType((*RaftBatch)(nil), "pb.RaftBatch")
	proto.RegisterType((*SubscriptionRequest)(nil), "pb.SubscriptionRequest")
	proto.RegisterType((*SubscriptionResponse)(nil), "pb.SubscriptionResponse")
	proto.RegisterType((*Num)(nil), "pb.Num")
	proto.RegisterType((*AssignedIds)(nil), "pb.AssignedIds")
	proto.RegisterType((*SnapshotMeta)(nil), "pb.SnapshotMeta")
	proto.RegisterType((*Status)(nil), "pb.Status")
	proto.RegisterType((*BackupRequest)(nil), "pb.BackupRequest")
	proto.RegisterType((*BackupResponse)(nil), "pb.BackupResponse")
	proto.RegisterType((*DropOperation)(nil), "pb.DropOperation")
	proto.RegisterType((*ExportRequest)(nil), "pb.ExportRequest")
	proto.RegisterType((*ExportResponse)(nil), "pb.ExportResponse")
	proto.RegisterType((*BackupKey)(nil), "pb.BackupKey")
	proto.RegisterType((*BackupPostingList)(nil), "pb.BackupPostingList")
	proto.RegisterType((*UpdateGraphQLSchemaRequest)(nil), "pb.UpdateGraphQLSchemaRequest")
	proto.RegisterType((*UpdateGraphQLSchemaResponse)(nil), "pb.UpdateGraphQLSchemaResponse")
	proto.RegisterType((*BulkMeta)(nil), "pb.BulkMeta")
	proto.RegisterMapType((map[string]*SchemaUpdate)(nil), "pb.BulkMeta.SchemaMapEntry")
}

func init() { proto.RegisterFile("pb.proto", fileDescriptor_f80abaa17e25ccc8) }

var fileDescriptor_f80abaa17e25ccc8 = []byte{
	// 5029 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x7b, 0x4b, 0x6c, 0x24, 0x69,
	0x52, 0xb0, 0xb3, 0xde, 0x19, 0xf5, 0xe8, 0xea, 0xaf, 0x7b, 0x7b, 0x6a, 0xab, 0x67, 0xda, 0x9e,
	0x9c, 0xe9, 0x19, 0xef, 0xf4, 0xb4, 0xbb, 0xc7, 0xbd, 0xbf, 0xfe, 0x9d, 0x59, 0x21, 0xe1, 0x47,
	0xb9, 0xc7, 0xd3, 0x6e, 0xdb, 0x9b, 0x55, 0xee, 0x7d, 0x1c, 0x28, 0xa5, 0x2b, 0x3f, 0xdb, 0xb9,
	0xce, 0xca, 0xcc, 0xcd, 0xcc, 0xf2, 0xda, 0x73, 0x43, 0x48, 0x2c, 0x07, 0x40, 0x48, 0x1c, 0xe0,
	0x04, 0x12, 0x07, 0x8e, 0x48, 0x20, 0x21, 0x21, 0x24, 0x6e, 0x08, 0x21, 0x0e, 0x68, 0x0f, 0x1c,
	0xb8, 0x30, 0x42, 0xb3, 0x9c, 0xfa, 0x86, 0x90, 0x90, 0xb8, 0xa1, 0x88, 0xf8, 0xf2, 0x65, 0x97,
	0xbb, 0x67, 0x16, 0x71, 0xe0, 0x54, 0x5f, 0x44, 0x7c, 0xcf, 0xf8, 0xe2, 0x8b, 0x67, 0x16, 0x34,
	0x82, 0xc3, 0x95, 0x20, 0xf4, 0x63, 0x5f, 0x94, 0x82, 0xc3, 0xbe, 0x6e, 0x05, 0x0e, 0x83, 0xfd,
	0x0f, 0x8e, 0x9d, 0xf8, 0x64, 0x76, 0xb8, 0x32, 0xf1, 0xa7, 0x8f, 0xec, 0xe3, 0xd0, 0x0a, 0x4e,
	0x1e, 0x3a, 0xfe, 0xa3, 0x43, 0xcb, 0x3e, 0x96, 0xe1, 0xa3, 0xb3, 0x27, 0x8f, 0x82, 0xc3, 0x47,
	0xc9, 0xd0, 0xfe, 0xc3, 0x5c, 0xdf, 0x63, 0xff, 0xd8, 0x7f, 0x44, 0xe8, 0xc3, 0xd9, 0x11, 0x41,
	0x04, 0x50, 0x8b, 0xbb, 0x1b, 0x7d, 0xa8, 0xec, 0x38, 0x51, 0x2c, 0x04, 0x54, 0x66, 0x8e, 0x1d,
	0xf5, 0xb4, 0xa5, 0xf2, 0x72, 0xcd, 0xa4, 0xb6, 0xf1, 0x1c, 0xf4, 0x91, 0x15, 0x9d, 0xbe, 0xb0,
	0xdc, 0x99, 0x14, 0x5d, 0x28, 0x9f, 0x59, 0x6e, 0x4f, 0x5b, 0xd2, 0x96, 0x5b, 0x26, 0x36, 0xc5,
	0x0a, 0x34, 0xce, 0x2c, 0x77, 0x1c, 0x5f, 0x04, 0xb2, 0x57, 0x5a, 0xd2, 0x96, 0x3b, 0xab, 0xb7,
	0x56, 0x82, 0xc3, 0x95, 0x7d, 0x3f, 0x8a, 0x1d, 0xef, 0x78, 0xe5, 0x85, 0xe5, 0x8e, 0x2e, 0x02,
	0x69, 0xd6, 0xcf, 0xb8, 0x61, 0xec, 0x41, 0x73, 0x18, 0x4e, 0xb6, 0x66, 0xde, 0x24, 0x76, 0x7c,
	0x0f, 0x57, 0xf4, 0xac, 0xa9, 0xa4, 0x19, 0x75, 0x93, 0xda, 0x88, 0xb3, 0xc2, 0xe3, 0xa8, 0x57,
	0x5e, 0x2a, 0x23, 0x0e, 0xdb, 0xa2, 0x07, 0x75, 0x27, 0xda, 0xf0, 0x67, 0x5e, 0xdc, 0xab, 0x2c,
	0x69, 0xcb, 0x0d, 0x33, 0x01, 0x8d, 0x3f, 0x2e, 0x43, 0xf5, 0x7b, 0x33, 0x19, 0x5e, 0xd0, 0xb8,
	0x38, 0x0e, 0x93, 0xb9, 0xb0, 0x2d, 0x6e, 0x43, 0xd5, 0xb5, 0xbc, 0xe3, 0xa8, 0x57, 0xa2, 0xc9,
	0x18, 0x10, 0x77, 0x41, 0xb7, 0x8e, 0x62, 0x19, 0x8e, 0x67, 0x8e, 0xdd, 0x2b, 0x2f, 0x69, 0xcb,
	0x35, 0xb3, 0x41, 0x88, 0x03, 0xc7, 0x16, 0xdf, 0x84, 0x86, 0xed, 0x8f, 0x27, 0xf9, 0xb5, 0x6c,
	0x9f, 0xd6, 0x12, 0xef, 0x40, 0x63, 0xe6, 0xd8, 0x63, 0xd7, 0x89, 0xe2, 0x5e, 0x75, 0x49, 0x5b,
	0x6e, 0xae, 0x36, 0xf0, 0xb0, 0xc8, 0x3b, 0xb3, 0x3e, 0x73, 0x6c, 0x62, 0xe2, 0x07, 0xd0, 0x88,
	0xc2, 0xc9, 0xf8, 0x68, 0xe6, 0x4d, 0x7a, 0x35, 0xea, 0x74, 0x03, 0x3b, 0xe5, 0x4e, 0x6d, 0xd6,
	0x23, 0x06, 0xf0, 0x58, 0xa1, 0x3c, 0x93, 0x61, 0x24, 0x7b, 0x75, 0x5e, 0x4a, 0x81, 0xe2, 0x31,
	0x34, 0x8f, 0xac, 0x89, 0x8c, 0xc7, 0x81, 0x15, 0x5a, 0xd3, 0x5e, 0x23, 0x9b, 0x68, 0x0b, 0xd1,
	0xfb, 0x88, 0x8d, 0x4c, 0x38, 0x4a, 0x01, 0xf1, 0x04, 0xda, 0x04, 0x45, 0xe3, 0x23, 0xc7, 0x8d,
	0x65, 0xd8, 0xd3, 0x69, 0x4c, 0x87, 0xc6, 0x10, 0x66, 0x14, 0x4a, 0x69, 0xb6, 0xb8, 0x13, 0x63,
	0xc4, 0x5b, 0x00, 0xf2, 0x3c, 0xb0, 0x3c, 0x7b, 0x6c, 0xb9, 0x6e, 0x0f, 0x68, 0x0f, 0x3a, 0x63,
	0xd6, 0x5c, 0x57, 0xbc, 0x81, 0xfb, 0xb3, 0xec, 0x71, 0x1c, 0xf5, 0xda, 0x4b, 0xda, 0x72, 0xc5,
	0xac, 0x21, 0x38, 0x8a, 0x90, 0xaf, 0x13, 0x6b, 0x72, 0x22, 0x7b, 0x9d, 0x25, 0x6d, 0xb9, 0x6a,
	0x32, 0x80, 0xd8, 0x23, 0x27, 0x8c, 0xe2, 0xde, 0x0d, 0xc6, 0x12, 0x60, 0xac, 0x82, 0x4e, 0xd2,
	0x43, 0xdc, 0xb9, 0x0f, 0xb5, 0x33, 0x04, 0x58, 0xc8, 0x9a, 0xab, 0x6d, 0xdc, 0x5e, 0x2a, 0x60,
	0xa6, 0x22, 0x1a, 0xf7, 0xa0, 0xb1, 0x63, 0x79, 0xc7, 0x89, 0x54, 0xe2, 0xb5, 0xd1, 0x00, 0xdd,
	0xa4, 0xb6, 0xf1, 0x87, 0x25, 0xa8, 0x99, 0x32, 0x9a, 0xb9, 0xb1, 0x78, 0x1f, 0x00, 0x2f, 0x65,
	0x6a, 0xc5, 0xa1, 0x73, 0xae, 0x66, 0xcd, 0xae, 0x45, 0x9f, 0x39, 0xf6, 0x73, 0x22, 0x89, 0xc7,
	0xd0, 0xa2, 0xd9, 0x93, 0xae, 0xa5, 0x6c, 0x03, 0xe9, 0xfe, 0xcc, 0x26, 0x75, 0x51, 0x23, 0xee,
	0x40, 0x8d, 0xe4, 0x80, 0x65, 0xb1, 0x6d, 0x2a, 0x48, 0xdc, 0x87, 0x8e, 0xe3, 0xc5, 0x78, 0x4f,
	0x93, 0x78, 0x6c, 0xcb, 0x28, 0x11, 0x94, 0x76, 0x8a, 0xdd, 0x94, 0x51, 0x2c, 0x3e, 0x02, 0x66,
	0x76, 0xb2, 0x60, 0x95, 0x16, 0xec, 0xa4, 0x97, 0x18, 0xf1, 0x8a, 0xd4, 0x47, 0xad, 0xf8, 0x10,
	0x9a, 0x78, 0xbe, 0x64, 0x44, 0x8d, 0x46, 0xb4, 0xe8, 0x34, 0x8a, 0x1d, 0x26, 0x60, 0x07, 0xd5,
	0x1d, 0x59, 0x83, 0xc2, 0xc8, 0xc2, 0x43, 0x6d, 0x63, 0x00, 0xd5, 0xbd, 0xd0, 0x96, 0xe1, 0xdc,
	0xf7, 0x20, 0xa0, 0x62, 0xcb, 0x68, 0x42, 0x4f, 0xb5, 0x61, 0x52, 0x3b, 0x7b, 0x23, 0xe5, 0xdc,
	0x1b, 0x31, 0xfe, 0x48, 0x83, 0xe6, 0xd0, 0x0f, 0xe3, 0xe7, 0x32, 0x8a, 0xac, 0x63, 0x29, 0x16,
	0xa1, 0xea, 0xe3, 0xb4, 0x8a, 0xc3, 0x3a, 0xee, 0x89, 0xd6, 0x31, 0x19, 0x7f, 0xe9, 0x1e, 0x4a,
	0xd7, 0xdf, 0x03, 0xca, 0x0e, 0xbd, 0xae, 0xb2, 0x92, 0x1d, 0x7a, 0x5b, 0x77, 0xa0, 0xe6, 0x1f,
	0x1d, 0x45, 0x92, 0x79, 0x59, 0x35, 0x15, 0x74, 0xad, 0x08, 0x1a, 0xff, 0x0f, 0x00, 0xf7, 0xf7,
	0x35, 0xa5, 0xc0, 0xf8, 0x99, 0x06, 0x4d, 0xd3, 0x3a, 0x8a, 0x37, 0x7c, 0x2f, 0x96, 0xe7, 0xb1,
	0xe8, 0x40, 0xc9, 0xb1, 0x89, 0x47, 0x35, 0xb3, 0xe4, 0xd8, 0xb8, 0xbb, 0xe3, 0xd0, 0x9f, 0x05,
	0xc4, 0xa2, 0xb6, 0xc9, 0x00, 0xf1, 0xd2, 0xb6, 0x43, 0xda, 0x32, 0xf2, 0xd2, 0xb6, 0x43, 0xb1,
	0x08, 0xcd, 0xc8, 0xb3, 0x82, 0xe8, 0xc4, 0x8f, 0x71, 0x77, 0x15, 0xda, 0x1d, 0x24, 0xa8, 0x51,
	0x84, 0x8f, 0xcb, 0x89, 0xc6, 0xae, 0xb4, 0x42, 0x4f, 0x86, 0xa4, 0x30, 0x1a, 0xa6, 0xee, 0x44,
	0x3b, 0x8c, 0x30, 0x7e, 0x56, 0x86, 0xda, 0x73, 0x39, 0x3d, 0x94, 0xe1, 0x95, 0x4d, 0x3c, 0x86,
	0x06, 0xad, 0x3b, 0x76, 0x6c, 0xde, 0xc7, 0xfa, 0x37, 0x5e, 0x7e, 0xb1, 0x78, 0x93, 0x70, 0xdb,
	0xf6, 0x87, 0xfe, 0xd4, 0x89, 0xe5, 0x34, 0x88, 0x2f, 0xcc, 0xba, 0x42, 0xcd, 0xdd, 0xe0, 0x1d,
	0xa8, 0xb9, 0xd2, 0xc2, 0x3b, 0x63, 0xf1, 0x54, 0x90, 0x78, 0x08, 0x75, 0x6b, 0x3a, 0xb6, 0xa5,
	0x65, 0xf3, 0xa6, 0xd6, 0x6f, 0xbf, 0xfc, 0x62, 0xb1, 0x6b, 0x4d, 0x37, 0xa5, 0x95, 0x9f, 0xbb,
	0xc6, 0x18, 0xf1, 0x31, 0xca, 0x64, 0x14, 0x8f, 0x67, 0x81, 0x6d, 0xc5, 0x92, 0x74, 0x5a, 0x65,
	0xbd, 0xf7, 0xf2, 0x8b, 0xc5, 0xdb, 0x88, 0x3e, 0x20, 0x6c, 0x6e, 0x18, 0x64, 0x58, 0xd4, 0x6f,
	0xc9, 0xf1, 0x95, 0x7e, 0x53, 0xa0, 0xd8, 0x86, 0x9b, 0x13, 0x77, 0x16, 0xa1, 0x12, 0x76, 0xbc,
	0x23, 0x7f, 0xec, 0x7b, 0xee, 0x05, 0x5d, 0x70, 0x63, 0xfd, 0xad, 0x97, 0x5f, 0x2c, 0x7e, 0x53,
	0x11, 0xb7, 0xbd, 0x23, 0x7f, 0xcf, 0x73, 0x2f, 0x72, 0xf3, 0xdf, 0xb8, 0x44, 0x12, 0xbf, 0x0a,
	0x9d, 0x23, 0x3f, 0x9c, 0xc8, 0x71, 0xca, 0xb2, 0x0e, 0xcd, 0xd3, 0x7f, 0xf9, 0xc5, 0xe2, 0x1d,
	0xa2, 0x3c, 0xbd, 0xc2, 0xb7, 0x56, 0x1e, 0x6f, 0xfc, 0x4b, 0x09, 0xaa, 0xd4, 0x16, 0x8f, 0xa1,
	0x3e, 0xa5, 0x2b, 0x49, 0xf4, 0xd3, 0x1d, 0x94, 0x21, 0xa2, 0xad, 0xf0, 0x5d, 0x45, 0x03, 0x2f,
	0x0e, 0x2f, 0xcc, 0xa4, 0x1b, 0x8e, 0x88, 0xad, 0x43, 0x57, 0xc6, 0x91, 0x92, 0xf9, 0xdc, 0x88,
	0x11, 0x13, 0xd4, 0x08, 0xd5, 0xed, 0xb2, 0xdc, 0x94, 0xaf, 0xc8, 0x4d, 0x1f, 0x1a, 0x93, 0x13,
	0x39, 0x39, 0x8d, 0x66, 0x53, 0x25, 0x55, 0x29, 0x2c, 0xde, 0x81, 0x36, 0xb5, 0x03, 0xdf, 0xf1,
	0x68, 0x78, 0x95, 0x3a, 0xb4, 0x32, 0xe4, 0x28, 0xea, 0x6f, 0x41, 0x2b, 0xbf, 0x59, 0x34, 0xdb,
	0xa7, 0xf2, 0x82, 0xe4, 0xab, 0x62, 0x62, 0x53, 0x2c, 0x41, 0x95, 0x14, 0x1d, 0x49, 0x57, 0x73,
	0x15, 0x70, 0xcf, 0x3c, 0xc4, 0x64, 0xc2, 0x27, 0xa5, 0xef, 0x68, 0x38, 0x4f, 0xfe, 0x08, 0xf9,
	0x79, 0xf4, 0xeb, 0xe7, 0xe1, 0x21, 0xb9, 0x79, 0x0c, 0x1f, 0xea, 0x3b, 0xce, 0x44, 0x7a, 0x11,
	0x19, 0xf7, 0x59, 0x24, 0x53, 0xa5, 0x84, 0x6d, 0x3c, 0xef, 0xd4, 0x3a, 0xdf, 0xf5, 0x6d, 0x19,
	0xd1, 0x3c, 0x15, 0x33, 0x85, 0x91, 0x26, 0xcf, 0x03, 0x27, 0xbc, 0x18, 0x31, 0xa7, 0xca, 0x66,
	0x0a, 0xa3, 0x74, 0x49, 0x0f, 0x17, 0xb3, 0x13, 0x43, 0xad, 0x40, 0xe3, 0x9f, 0xca, 0xd0, 0xfa,
	0x91, 0x0c, 0xfd, 0xfd, 0xd0, 0x0f, 0xfc, 0xc8, 0x72, 0xc5, 0x5a, 0x91, 0xe7, 0x7c, 0xb7, 0x4b,
	0xb8, 0xdb, 0x7c, 0xb7, 0x95, 0x61, 0x7a, 0x09, 0x7c, 0x67, 0xf9, 0x5b, 0x31, 0xa0, 0xc6, 0x77,
	0x3e, 0x87, 0x67, 0x8a, 0x82, 0x7d, 0xf8, 0x96, 0x69, 0xaf, 0x45, 0x7e, 0x28, 0x0a, 0xbe, 0xca,
	0xa9, 0x75, 0x7e, 0xb0, 0xbd, 0xa9, 0xee, 0x56, 0x41, 0x8a, 0x0b, 0xa3, 0x73, 0x6f, 0x94, 0x5c,
	0x6a, 0x0a, 0xe3, 0x49, 0x91, 0x23, 0xd1, 0xf6, 0x66, 0xaf, 0x45, 0xa4, 0x04, 0x14, 0x6f, 0x82,
	0x3e, 0xb5, 0xce, 0x51, 0xa1, 0x6d, 0xdb, 0xfc, 0x34, 0xcd, 0x0c, 0x21, 0xde, 0x86, 0x72, 0x7c,
	0xee, 0xd1, 0xdb, 0x43, 0xef, 0x01, 0x9d, 0xc9, 0xd1, 0xb9, 0xa7, 0x54, 0x9f, 0x89, 0x34, 0xbc,
	0xd3, 0x89, 0x63, 0x93, 0xb3, 0xa0, 0x9b, 0xd8, 0x14, 0xf7, 0xa1, 0xee, 0xf2, 0x6d, 0x91, 0x43,
	0xd0, 0x5c, 0x6d, 0xb2, 0x1e, 0x25, 0x94, 0x99, 0xd0, 0xc4, 0x87, 0xd0, 0x48, 0xb8, 0xd3, 0x6b,
	0x52, 0xbf, 0x6e, 0xc2, 0xcf, 0x84, 0x8d, 0x66, 0xda, 0xa3, 0xff, 0x2b, 0x70, 0xe3, 0x12, 0x73,
	0xf3, 0xd2, 0xd4, 0x66, 0x69, 0xba, 0x9d, 0x97, 0xa6, 0x4a, 0x4e, 0x82, 0x3e, 0xab, 0x34, 0x1a,
	0x5d, 0xdd, 0xf8, 0xf7, 0x32, 0xdc, 0x50, 0x82, 0x7d, 0xe2, 0x04, 0xc3, 0x58, 0xa9, 0x18, 0x32,
	0x20, 0x4a, 0xa6, 0x2a, 0x66, 0x02, 0x8a, 0xff, 0x0f, 0x35, 0xd2, 0x08, 0xc9, 0xc3, 0x5c, 0xcc,
	0x2e, 0x2c, 0x1d, 0xce, 0x0f, 0x55, 0xdd, 0xb6, 0xea, 0x2e, 0xbe, 0x0d, 0xd5, 0xcf, 0x65, 0xe8,
	0xb3, 0x41, 0x6c, 0xae, 0xde, 0x9b, 0x37, 0x0e, 0x8f, 0xa9, 0x86, 0x71, 0xe7, 0xff, 0xe9, 0xbd,
	0xc2, 0xd7, 0xb9, 0xd7, 0x77, 0xd1, 0x28, 0x4e, 0xfd, 0x33, 0x69, 0xf7, 0xea, 0xb4, 0xc7, 0xbc,
	0x30, 0x26, 0xa4, 0xe4, 0x6a, 0x1b, 0x73, 0xaf, 0x56, 0xbf, 0xfe, 0x6a, 0xfb, 0x9b, 0xd0, 0xcc,
	0xf1, 0x65, 0xce, 0x45, 0x2d, 0x16, 0x9f, 0xbd, 0x9e, 0xaa, 0xbc, 0xbc, 0xf6, 0xd8, 0x04, 0xc8,
	0xb8, 0xf4, 0xcb, 0xea, 0x20, 0xe3, 0xd7, 0x35, 0xb8, 0xb1, 0xe1, 0x7b, 0x9e, 0x24, 0xd7, 0x99,
	0xef, 0x3c, 0x7b, 0x8a, 0xda, 0xb5, 0x4f, 0xf1, 0x5b, 0x50, 0x8d, 0xb0, 0xb3, 0x9a, 0xfd, 0xd6,
	0x9c, 0x4b, 0x34, 0xb9, 0x07, 0x2a, 0xe4, 0xa9, 0x75, 0x3e, 0x0e, 0xa4, 0x67, 0x3b, 0xde, 0x71,
	0xa2, 0x90, 0xa7, 0xd6, 0xf9, 0x3e, 0x63, 0x8c, 0xbf, 0x2a, 0x01, 0x7c, 0x2a, 0x2d, 0x37, 0x3e,
	0x41, 0xa3, 0x83, 0x37, 0xea, 0x78, 0x51, 0x6c, 0x79, 0x93, 0x24, 0x70, 0x49, 0x61, 0xbc, 0x51,
	0xb4, 0xbd, 0x32, 0x62, 0x55, 0xa6, 0x9b, 0x09, 0x88, 0xf2, 0x81, 0xcb, 0xcd, 0x22, 0x65, 0xa3,
	0x15, 0x94, 0x39, 0x1c, 0x15, 0x42, 0x2b, 0x87, 0xa3, 0x07, 0x75, 0x0c, 0x04, 0x1c, 0xdf, 0x23,
	0xa1, 0xd1, 0xcd, 0x04, 0xc4, 0x79, 0x66, 0x41, 0xec, 0x4c, 0xd9, 0x12, 0x97, 0x4d, 0x05, 0xe1,
	0xae, 0xd0, 0xf2, 0x0e, 0x26, 0x27, 0x3e, 0x3d, 0xf8, 0xb2, 0x99, 0xc2, 0x38, 0x9b, 0xef, 0x1d,
	0xfb, 0x78, 0xba, 0x06, 0x39, 0x79, 0x09, 0xc8, 0x67, 0xb1, 0xe5, 0x39, 0x92, 0x74, 0x22, 0xa5,
	0x30, 0xf2, 0x45, 0xca, 0xf1, 0x91, 0xb4, 0xe2, 0x59, 0x28, 0xa3, 0x1e, 0x10, 0x19, 0xa4, 0xdc,
	0x52, 0x18, 0xf1, 0x36, 0xb4, 0x90, 0x71, 0x56, 0x14, 0x39, 0xc7, 0x9e, 0xb4, 0x49, 0x0d, 0x54,
	0x4c, 0x64, 0xe6, 0x9a, 0x42, 0x19, 0x7f, 0x53, 0x82, 0x1a, 0x2b, 0xc0, 0x82, 0x53, 0xa3, 0x7d,
	0x25, 0xa7, 0xe6, 0x4d, 0xd0, 0x83, 0x50, 0xda, 0xce, 0x24, 0xb9, 0x47, 0xdd, 0xcc, 0x10, 0x14,
	0x6d, 0xa0, 0x15, 0x27, 0x7e, 0x36, 0x4c, 0x06, 0x84, 0x01, 0x6d, 0xdf, 0x1b, 0xdb, 0x4e, 0x74,
	0x3a, 0x3e, 0xbc, 0x88, 0x65, 0xa4, 0x78, 0xd1, 0xf4, 0xbd, 0x4d, 0x27, 0x3a, 0x5d, 0x47, 0x14,
	0xb2, 0x90, 0xdf, 0x08, 0xbd, 0x8d, 0x86, 0xa9, 0x20, 0xf1, 0x04, 0x74, 0xf2, 0x35, 0xc9, 0x19,
	0xd1, 0xc9, 0x89, 0xb8, 0xf3, 0xf2, 0x8b, 0x45, 0x81, 0xc8, 0x4b, 0x5e, 0x48, 0x23, 0xc1, 0xa1,
	0x37, 0x85, 0x83, 0xd1, 0xac, 0xd0, 0x1b, 0x66, 0x6f, 0x0a, 0x51, 0xa3, 0x28, 0xef, 0x4d, 0x31,
	0x46, 0x3c, 0x04, 0x31, 0xf3, 0x26, 0xfe, 0x34, 0x40, 0xa1, 0x90, 0xb6, 0xda, 0x64, 0x93, 0x36,
	0x79, 0x33, 0x4f, 0xa1, 0xad, 0x1a, 0xff, 0x58, 0x82, 0xd6, 0xa6, 0x13, 0xca, 0x49, 0x2c, 0xed,
	0x81, 0x7d, 0x2c, 0x71, 0xef, 0xd2, 0x8b, 0x9d, 0xf8, 0x42, 0xb9, 0x8b, 0x0a, 0x4a, 0xbd, 0xfd,
	0x52, 0x31, 0xfa, 0xe5, 0x17, 0x56, 0xa6, 0x80, 0x9d, 0x01, 0xb1, 0x0a, 0xc0, 0x71, 0x10, 0x05,
	0xed, 0x95, 0xeb, 0x83, 0x76, 0x9d, 0xba, 0x61, 0x13, 0x83, 0x62, 0x1e, 0xe3, 0xb0, 0xcf, 0x58,
	0xa3, 0x88, 0x7e, 0x26, 0xb7, 0x6d, 0x0e, 0x1f, 0x0e, 0xa5, 0x4b, 0xe2, 0x48, 0xe1, 0xc3, 0xa1,
	0x74, 0xd3, 0xa0, 0xad, 0xce, 0xdb, 0xc1, 0xb6, 0x78, 0x07, 0x4a, 0x7e, 0x40, 0x2c, 0x57, 0x0b,
	0xe6, 0x0f, 0xb6, 0xb2, 0x17, 0x98, 0x25, 0x3f, 0xc0, 0xb7, 0xcd, 0x11, 0x2a, 0x89, 0x23, 0xbe,
	0x6d, 0xb4, 0x5a, 0x14, 0x2f, 0x99, 0x8a, 0x22, 0x0c, 0x68, 0x59, 0xae, 0xeb, 0xff, 0x54, 0xda,
	0xfb, 0xa1, 0xb4, 0x13, 0xc9, 0x2c, 0xe0, 0x8c, 0x3b, 0x50, 0xda, 0x0b, 0x44, 0x1d, 0xca, 0xc3,
	0xc1, 0xa8, 0xbb, 0x80, 0x8d, 0xcd, 0xc1, 0x4e, 0x57, 0x33, 0xbe, 0x2c, 0x81, 0xfe, 0x7c, 0x16,
	0x5b, 0xa8, 0x4d, 0x22, 0x3c, 0x57, 0x51, 0x26, 0x33, 0xe1, 0xfb, 0x26, 0x34, 0xa2, 0xd8, 0x0a,
	0xc9, 0x5f, 0x60, 0x7b, 0x54, 0x27, 0x78, 0x14, 0x89, 0xf7, 0xa0, 0x2a, 0xed, 0x63, 0x99, 0x18,
	0x88, 0xee, 0xe5, 0xb3, 0x98, 0x4c, 0x16, 0xcb, 0x50, 0x8b, 0x26, 0x27, 0x72, 0x6a, 0xf5, 0x2a,
	0x59, 0xc7, 0x21, 0x61, 0xd8, 0x41, 0x36, 0x15, 0x5d, 0xbc, 0x0b, 0x55, 0xbc, 0x8d, 0x48, 0x45,
	0x7c, 0x14, 0x23, 0x22, 0xe3, 0x55, 0x37, 0x26, 0xa2, 0xa8, 0xd9, 0xa1, 0x1f, 0x8c, 0xfd, 0x80,
	0xf8, 0xda, 0x59, 0xbd, 0x4d, 0x5a, 0x2d, 0x39, 0xcd, 0xca, 0x66, 0xe8, 0x07, 0x7b, 0x81, 0x59,
	0xb3, 0xe9, 0x17, 0xe3, 0x0f, 0xea, 0xce, 0x32, 0xc0, 0x66, 0x40, 0x47, 0x0c, 0x27, 0x73, 0x96,
	0xa1, 0x31, 0x95, 0xb1, 0x65, 0x5b, 0xb1, 0xa5, 0xac, 0x41, 0x8b, 0x95, 0x24, 0xe3, 0xcc, 0x94,
	0x6a, 0x3c, 0x82, 0x1a, 0x4f, 0x2d, 0x1a, 0x50, 0xd9, 0xdd, 0xdb, 0x1d, 0x30, 0x43, 0xd7, 0x76,
	0x76, 0xba, 0x1a, 0xa2, 0x36, 0xd7, 0x46, 0x6b, 0xdd, 0x12, 0xb6, 0x46, 0x3f, 0xdc, 0x1f, 0x74,
	0xcb, 0xc6, 0x3f, 0x68, 0xd0, 0x48, 0xe6, 0x11, 0x9f, 0x00, 0xe0, 0xa3, 0x1d, 0x9f, 0x38, 0x5e,
	0xea, 0x7a, 0xdd, 0xcd, 0xaf, 0xb4, 0x82, 0x37, 0xf6, 0x29, 0x52, 0xd9, 0xa0, 0xd2, 0x1b, 0x27,
	0xb8, 0x3f, 0x84, 0x4e, 0x91, 0x38, 0xc7, 0x07, 0x7d, 0x90, 0xb7, 0x23, 0x9d, 0xd5, 0x6f, 0x14,
	0xa6, 0xc6, 0x91, 0x24, 0xcc, 0x39, 0x93, 0xf2, 0x10, 0x1a, 0x09, 0x5a, 0x34, 0xa1, 0xbe, 0x39,
	0xd8, 0x5a, 0x3b, 0xd8, 0x41, 0x21, 0x01, 0xa8, 0x0d, 0xb7, 0x77, 0x9f, 0xee, 0x0c, 0xf8, 0x58,
	0x3b, 0xdb, 0xc3, 0x51, 0xb7, 0x64, 0xfc, 0xbe, 0x06, 0x8d, 0xc4, 0x77, 0x11, 0xdf, 0x42, 0x77,
	0x83, 0xdc, 0x27, 0x65, 0x7b, 0x28, 0x27, 0x93, 0x0b, 0x28, 0xcd, 0x84, 0x8e, 0x0f, 0x83, 0x54,
	0x69, 0xe2, 0xcd, 0x10, 0x90, 0x8f, 0x67, 0xcb, 0x85, 0x94, 0x0a, 0x86, 0xe6, 0xbe, 0x27, 0x95,
	0x2b, 0x4b, 0x6d, 0x92, 0x41, 0xc7, 0x9b, 0xc8, 0xcc, 0xd1, 0xaf, 0x13, 0x3c, 0x8a, 0x8c, 0x98,
	0x3d, 0xdc, 0x74, 0x63, 0xe9, 0x6a, 0x5a, 0x7e, 0xb5, 0x2b, 0xe1, 0x42, 0xe9, 0x6a, 0xb8, 0x90,
	0x99, 0xca, 0xea, 0xeb, 0x4c, 0xa5, 0xf1, 0xe7, 0x15, 0xe8, 0x98, 0x32, 0x8a, 0xfd, 0x50, 0x9a,
	0xf2, 0x27, 0x33, 0x19, 0xc5, 0xaf, 0x7a, 0x42, 0x6f, 0x01, 0x84, 0xdc, 0x39, 0x5b, 0x5a, 0x57,
	0x18, 0x8e, 0x73, 0x5c, 0x7f, 0x42, 0xb2, 0xab, 0x6c, 0x62, 0x0a, 0x8b, 0xbb, 0xa0, 0x1f, 0x5a,
	0x93, 0x53, 0x9e, 0x96, 0x2d, 0x63, 0x83, 0x11, 0x3c, 0xaf, 0x35, 0x99, 0xc8, 0x28, 0x1a, 0xa3,
	0x28, 0xb0, 0x7d, 0xd4, 0x19, 0xf3, 0x4c, 0x5e, 0x20, 0x39, 0x92, 0x93, 0x50, 0xc6, 0x44, 0x66,
	0xb5, 0xa4, 0x33, 0x06, 0xc9, 0xef, 0x40, 0x3b, 0x92, 0x11, 0xda, 0xd2, 0x71, 0xec, 0x9f, 0x4a,
	0x4f, 0xe9, 0xa8, 0x96, 0x42, 0x8e, 0x10, 0x87, 0xa6, 0xc7, 0xf2, 0x7c, 0xef, 0x62, 0xea, 0xcf,
	0x22, 0x65, 0x25, 0x32, 0x84, 0x58, 0x81, 0x5b, 0xd2, 0x9b, 0x84, 0x17, 0x01, 0xee, 0x15, 0x57,
	0x19, 0x1f, 0x39, 0xae, 0x54, 0x4e, 0xf4, 0xcd, 0x8c, 0xf4, 0x4c, 0x5e, 0x6c, 0x39, 0xae, 0xc4,
	0x1d, 0x9d, 0x59, 0x33, 0x37, 0x1e, 0x53, 0x8c, 0x0e, 0xbc, 0x23, 0xc2, 0xac, 0x61, 0xa0, 0xfe,
	0x01, 0xdc, 0x64, 0x72, 0xe8, 0xbb, 0xd2, 0xb1, 0x79, 0xb2, 0x26, 0xf5, 0xba, 0x41, 0x04, 0x93,
	0xf0, 0x34, 0xd5, 0x0a, 0xdc, 0xe2, 0xbe, 0x7c, 0xa0, 0xa4, 0x77, 0x8b, 0x97, 0x26, 0xd2, 0x50,
	0x51, 0x8a, 0x4b, 0x07, 0x56, 0x7c, 0x42, 0x11, 0x76, 0xb2, 0xf4, 0xbe, 0x15, 0x9f, 0xa0, 0x8d,
	0x67, 0xf2, 0x91, 0x23, 0x5d, 0x8e, 0x9c, 0x75, 0x93, 0x47, 0x6c, 0x21, 0x06, 0x6d, 0xbc, 0xea,
	0xe0, 0x87, 0x53, 0x8b, 0x53, 0x7b, 0xba, 0xc9, 0x83, 0xb6, 0x08, 0x85, 0x4b, 0xa8, 0xbb, 0xf2,
	0x66, 0xd3, 0x5e, 0x97, 0xaf, 0x99, 0x31, 0xbb, 0xb3, 0xa9, 0xf1, 0xbb, 0x65, 0x68, 0xa4, 0x81,
	0xd8, 0x03, 0xd0, 0xa7, 0x89, 0xbe, 0x52, 0xae, 0x59, 0xbb, 0xa0, 0xc4, 0xcc, 0x8c, 0x2e, 0xde,
	0x82, 0xd2, 0xe9, 0x99, 0xd2, 0x9d, 0xed, 0x15, 0x4e, 0x75, 0x07, 0x87, 0x4f, 0x56, 0x9e, 0xbd,
	0x30, 0x4b, 0xa7, 0x67, 0x5f, 0x43, 0x6e, 0xc5, 0xfb, 0x70, 0x63, 0xe2, 0x4a, 0xcb, 0x1b, 0x67,
	0xfe, 0x04, 0xcb, 0x45, 0x87, 0xd0, 0xfb, 0xa9, 0x53, 0x71, 0x1f, 0xaa, 0xb6, 0x74, 0x63, 0x2b,
	0x9f, 0x71, 0xdd, 0x0b, 0xad, 0x89, 0x2b, 0x37, 0x11, 0x6d, 0x32, 0x15, 0x75, 0x67, 0x1a, 0xfc,
	0xe4, 0x74, 0xe7, 0xd5, 0xc0, 0x27, 0x7b, 0x97, 0x90, 0x7f, 0x97, 0x0f, 0xe0, 0xa6, 0x3c, 0x0f,
	0xc8, 0x60, 0x8c, 0xd3, 0x58, 0x9f, 0xdd, 0xa7, 0x6e, 0x42, 0xd8, 0x48, 0x62, 0xfe, 0x0f, 0x51,
	0x65, 0xd0, 0xa3, 0xa1, 0x6b, 0x6e, 0xae, 0x0a, 0xd2, 0x39, 0x85, 0x67, 0x68, 0x26, 0x5d, 0xf0,
	0x55, 0x6d, 0x6c, 0x6e, 0x6c, 0xd3, 0x9a, 0x9c, 0x31, 0x4b, 0xe1, 0xcf, 0x2a, 0x8d, 0x7a, 0xb7,
	0x61, 0x4c, 0xa0, 0xfc, 0xec, 0xc5, 0x90, 0x14, 0x0e, 0xea, 0xfe, 0x2a, 0x39, 0x07, 0xd4, 0x4e,
	0x95, 0x50, 0x29, 0xa7, 0x84, 0xee, 0xb1, 0xfe, 0x26, 0xfe, 0x24, 0x49, 0xc2, 0x1c, 0x06, 0x4f,
	0xc8, 0xb6, 0xab, 0xc2, 0xf9, 0x43, 0x02, 0x8c, 0xff, 0x2c, 0x43, 0x5d, 0x39, 0x14, 0xa8, 0xb3,
	0x67, 0x69, 0x7e, 0x0b, 0x9b, 0xc5, 0x48, 0x2f, 0xf5, 0x4c, 0xf2, 0xc5, 0x84, 0xf2, 0xeb, 0x8b,
	0x09, 0xe2, 0x13, 0x68, 0x05, 0x4c, 0xcb, 0xfb, 0x32, 0x6f, 0xe4, 0xc7, 0xa8, 0x5f, 0x1a, 0xd7,
	0x0c, 0x32, 0x00, 0xd5, 0x16, 0x65, 0x5a, 0x63, 0xeb, 0x58, 0x71, 0xa0, 0x8e, 0xf0, 0xc8, 0x3a,
	0xbe, 0xc6, 0xa3, 0xf9, 0x2a, 0x8e, 0x49, 0x87, 0x3c, 0x9c, 0x16, 0x69, 0x41, 0x74, 0x66, 0xf2,
	0x3e, 0x44, 0xbb, 0xe8, 0x43, 0xdc, 0x05, 0x7d, 0xe2, 0x4f, 0xa7, 0x0e, 0xd1, 0x3a, 0x2a, 0xcb,
	0x43, 0x88, 0x51, 0x64, 0xfc, 0xa6, 0x06, 0x75, 0x75, 0xda, 0x2b, 0x16, 0x6a, 0x7d, 0x7b, 0x77,
	0xcd, 0xfc, 0x61, 0x57, 0x43, 0x0b, 0xbc, 0xbd, 0x3b, 0xea, 0x96, 0x84, 0x0e, 0xd5, 0xad, 0x9d,
	0xbd, 0xb5, 0x51, 0xb7, 0x8c, 0x56, 0x6b, 0x7d, 0x6f, 0x6f, 0xa7, 0x5b, 0x11, 0x2d, 0x68, 0x6c,
	0xae, 0x8d, 0x06, 0xa3, 0xed, 0xe7, 0x83, 0x6e, 0x15, 0xfb, 0x3e, 0x1d, 0xec, 0x75, 0x6b, 0xd8,
	0x38, 0xd8, 0xde, 0xec, 0xd6, 0x91, 0xbe, 0xbf, 0x36, 0x1c, 0x7e, 0x7f, 0xcf, 0xdc, 0xec, 0x36,
	0xc8, 0xf2, 0x8d, 0xcc, 0xed, 0xdd, 0xa7, 0x5d, 0x1d, 0xdb, 0x7b, 0xeb, 0x9f, 0x0d, 0x36, 0x46,
	0x5d, 0x30, 0x3e, 0x82, 0x66, 0x8e, 0x83, 0x38, 0xda, 0x1c, 0x6c, 0x75, 0x17, 0x70, 0xc9, 0x17,
	0x6b, 0x3b, 0x07, 0x68, 0x28, 0x3b, 0x00, 0xd4, 0x1c, 0xef, 0xac, 0xed, 0x3e, 0xed, 0x96, 0x8c,
	0xef, 0x41, 0xe3, 0xc0, 0xb1, 0xd7, 0x5d, 0x7f, 0x72, 0x8a, 0xe2, 0x74, 0x68, 0x45, 0x52, 0xd9,
	0x24, 0x6a, 0xa3, 0x03, 0x4b, 0x6f, 0x28, 0x52, 0x77, 0xaf, 0x20, 0xe4, 0x95, 0x37, 0x9b, 0x8e,
	0xa9, 0x00, 0x55, 0x66, 0x3b, 0xe2, 0xcd, 0xa6, 0x07, 0x8e, 0x1d, 0x19, 0xa7, 0x50, 0x3f, 0x70,
	0xec, 0x7d, 0x6b, 0x72, 0x4a, 0xba, 0x06, 0xa7, 0x1e, 0x47, 0xce, 0xe7, 0x52, 0xd9, 0x1b, 0x9d,
	0x30, 0x43, 0xe7, 0x73, 0x29, 0xde, 0x85, 0x1a, 0x01, 0x49, 0xcc, 0x4f, 0xaf, 0x32, 0xd9, 0x8e,
	0xa9, 0x68, 0x54, 0xff, 0x71, 0x5d, 0x7f, 0x32, 0x0e, 0xe5, 0x51, 0xef, 0x0d, 0xe6, 0x3d, 0x21,
	0x4c, 0x79, 0x64, 0xfc, 0xb6, 0x96, 0x9e, 0x99, 0xca, 0x0f, 0x8b, 0x50, 0x09, 0xac, 0xc9, 0xa9,
	0x32, 0xf7, 0x4d, 0x35, 0x21, 0x6e, 0xc6, 0x24, 0x82, 0x78, 0x1f, 0x1a, 0x4a, 0xb0, 0x92, 0x55,
	0x9b, 0x39, 0x09, 0x34, 0x53, 0x62, 0xf1, 0xca, 0xcb, 0xc5, 0x2b, 0xa7, 0xf0, 0x30, 0x70, 0x9d,
	0x98, 0x9f, 0x51, 0xc5, 0x54, 0x90, 0xf1, 0x6d, 0x80, 0xac, 0xe2, 0x33, 0xc7, 0xfb, 0xb9, 0x0d,
	0x55, 0xcb, 0x75, 0xac, 0x24, 0xdc, 0x64, 0xc0, 0xd8, 0x85, 0x66, 0xae, 0x4e, 0x84, 0xbc, 0xb5,
	0x5c, 0x17, 0x0d, 0x55, 0x44, 0x63, 0x1b, 0x66, 0xdd, 0x72, 0xdd, 0x67, 0xf2, 0x22, 0x42, 0xcf,
	0x93, 0x4b, 0x4c, 0xa5, 0x4b, 0xd5, 0x09, 0x1a, 0x6a, 0x32, 0xd1, 0xf8, 0x10, 0x6a, 0x5b, 0x89,
	0xef, 0x9d, 0x3c, 0x03, 0xed, 0xba, 0x67, 0x60, 0x7c, 0xac, 0xf6, 0x4c, 0x05, 0x0e, 0xf1, 0x40,
	0x95, 0xb2, 0x22, 0x2e, 0x9c, 0x69, 0x59, 0xc2, 0x82, 0x3b, 0xa9, 0x2a, 0x16, 0x75, 0x36, 0x36,
	0xa1, 0xf1, 0xca, 0xe2, 0xa0, 0x62, 0x40, 0x29, 0x63, 0xc0, 0x9c, 0x72, 0xa1, 0xf1, 0x63, 0x80,
	0xac, 0xe4, 0xa5, 0x5e, 0x25, 0xcf, 0x82, 0xaf, 0xf2, 0x03, 0x68, 0x4c, 0x4e, 0x1c, 0xd7, 0x0e,
	0xa5, 0x57, 0x38, 0x75, 0x56, 0x24, 0x4b, 0xe9, 0x62, 0x09, 0x2a, 0x54, 0xc9, 0x2b, 0x67, 0x4a,
	0x3e, 0x2d, 0xe3, 0x11, 0xc5, 0x38, 0x87, 0x36, 0xbb, 0xf4, 0x5f, 0xc1, 0x21, 0x2a, 0xaa, 0xd2,
	0xd2, 0x15, 0x55, 0x7a, 0x07, 0x6a, 0x64, 0x87, 0x93, 0xd3, 0x28, 0xe8, 0x1a, 0x15, 0xfb, 0x1b,
	0x25, 0x00, 0x5e, 0x7a, 0xd7, 0xb7, 0x65, 0x31, 0x5a, 0xd6, 0x2e, 0x47, 0xcb, 0x02, 0x2a, 0x69,
	0x91, 0x56, 0x37, 0xa9, 0x9d, 0xd9, 0x26, 0x15, 0x41, 0xb3, 0x6d, 0x7a, 0x13, 0x74, 0xf2, 0x8b,
	0x9c, 0xcf, 0xa9, 0x72, 0x80, 0x0b, 0x66, 0x88, 0x7c, 0xc9, 0xb2, 0x5a, 0x2c, 0x59, 0xa6, 0x75,
	0x9d, 0x1a, 0xcf, 0xc6, 0x75, 0x9d, 0x39, 0x25, 0x2a, 0x4e, 0x61, 0x44, 0x32, 0x8c, 0x93, 0xf8,
	0x9b, 0xa1, 0x34, 0x68, 0xd4, 0x55, 0x5f, 0x8b, 0x93, 0x10, 0x9e, 0x3f, 0x9e, 0xf8, 0xde, 0x91,
	0xeb, 0x4c, 0x62, 0x55, 0xa2, 0x04, 0xcf, 0xdf, 0x50, 0x18, 0xe3, 0x13, 0x68, 0x25, 0xfc, 0xa7,
	0x4a, 0xd0, 0x07, 0x69, 0xd0, 0xa5, 0x65, 0x77, 0x9b, 0xb1, 0x69, 0xbd, 0xd4, 0xd3, 0x92, 0xb0,
	0xcb, 0xf8, 0x8f, 0x72, 0x32, 0x58, 0x15, 0x2c, 0x5e, 0xcd, 0xc3, 0x62, 0xe4, 0x5c, 0xfa, 0x4a,
	0x91, 0xf3, 0x77, 0x40, 0xb7, 0x29, 0x34, 0x74, 0xce, 0x12, 0xa3, 0xd6, 0xbf, 0x1c, 0x06, 0xaa,
	0xe0, 0xd1, 0x39, 0x93, 0x66, 0xd6, 0xf9, 0x35, 0xf7, 0x90, 0x72, 0xbb, 0x3a, 0x8f, 0xdb, 0xb5,
	0x5f, 0x92, 0xdb, 0x6f, 0x43, 0xcb, 0xf3, 0xbd, 0xb1, 0x37, 0x73, 0x5d, 0xeb, 0xd0, 0x95, 0x8a,
	0xdd, 0x4d, 0xcf, 0xf7, 0x76, 0x15, 0x0a, 0x9d, 0xd5, 0x7c, 0x17, 0x7e, 0xd4, 0x4d, 0xea, 0x77,
	0x23, 0xd7, 0x8f, 0x9e, 0xfe, 0x32, 0x74, 0xfd, 0xc3, 0x1f, 0xcb, 0x49, 0x4c, 0x1c, 0x1b, 0xd3,
	0x6b, 0x66, 0x4f, 0xb5, 0xc3, 0x78, 0x64, 0xd1, 0x2e, 0xbe, 0xeb, 0x4b, 0xd7, 0xdc, 0xbe, 0x72,
	0xcd, 0x1f, 0x83, 0x9e, 0x72, 0x29, 0x17, 0x86, 0xea, 0x50, 0xdd, 0xde, 0xdd, 0x1c, 0xfc, 0xa0,
	0xab, 0xa1, 0xa1, 0x34, 0x07, 0x2f, 0x06, 0xe6, 0x70, 0xd0, 0x2d, 0xa1, 0x11, 0xdb, 0x1c, 0xec,
	0x0c, 0x46, 0x83, 0x6e, 0x99, 0xbd, 0x1e, 0xaa, 0x1b, 0xb8, 0xce, 0xc4, 0x89, 0x8d, 0x21, 0x40,
	0x16, 0x5b, 0xa3, 0x56, 0xce, 0x36, 0xa7, 0xd2, 0x79, 0x71, 0xb2, 0xad, 0xe5, 0xf4, 0x41, 0x96,
	0xae, 0x8b, 0xe0, 0x99, 0x6e, 0xac, 0x82, 0xfe, 0xdc, 0x0a, 0x3e, 0xe5, 0x0a, 0xdb, 0x7d, 0xe8,
	0x04, 0x56, 0x18, 0x3b, 0x49, 0x78, 0xc0, 0xca, 0xb2, 0x65, 0xb6, 0x53, 0x2c, 0xea, 0x5e, 0xe3,
	0x2f, 0x34, 0xb8, 0xfd, 0xdc, 0x3f, 0x93, 0xa9, 0xfb, 0xb9, 0x6f, 0x5d, 0xb8, 0xbe, 0x65, 0xbf,
	0x46, 0x0c, 0x31, 0xbe, 0xf1, 0x67, 0x54, 0xf1, 0x4a, 0xea, 0x83, 0xa6, 0xce, 0x98, 0xa7, 0xea,
	0x03, 0x06, 0x19, 0xc5, 0x44, 0x54, 0x86, 0x14, 0x61, 0x24, 0x7d, 0x03, 0x6a, 0xf1, 0xb9, 0x97,
	0x55, 0x2b, 0xab, 0x31, 0xa5, 0xa1, 0xe7, 0x7a, 0xa3, 0xd5, 0xf9, 0xde, 0xa8, 0xb1, 0x01, 0xfa,
	0xe8, 0x9c, 0x12, 0xb1, 0xb3, 0xa8, 0xe0, 0xe0, 0x68, 0xaf, 0x70, 0x70, 0x4a, 0x97, 0x1c, 0x9c,
	0x7f, 0xd3, 0xa0, 0x99, 0x73, 0xab, 0xc5, 0xdb, 0x50, 0x89, 0xcf, 0xbd, 0xe2, 0x47, 0x01, 0xc9,
	0x22, 0x26, 0x91, 0xae, 0x24, 0x1b, 0x4b, 0x57, 0x92, 0x8d, 0x62, 0x07, 0x6e, 0xb0, 0xe6, 0x4d,
	0x0e, 0x91, 0x64, 0x68, 0xde, 0xb9, 0xe4, 0xc6, 0x73, 0xb2, 0x3a, 0x39, 0x92, 0x4a, 0x3b, 0x74,
	0x8e, 0x0b, 0xc8, 0xfe, 0x1a, 0xdc, 0x9a, 0xd3, 0xed, 0xeb, 0x94, 0x2d, 0x8c, 0x45, 0x68, 0x8f,
	0xce, 0xbd, 0x91, 0x33, 0x95, 0x51, 0x6c, 0x4d, 0x03, 0x72, 0x10, 0x95, 0xe5, 0xac, 0x98, 0xa5,
	0x38, 0x32, 0xde, 0x83, 0xd6, 0xbe, 0x94, 0xa1, 0x29, 0xa3, 0xc0, 0xf7, 0xd8, 0x39, 0x52, 0x49,
	0x62, 0x36, 0xd3, 0x0a, 0x32, 0x7e, 0x0d, 0x74, 0xd3, 0x3a, 0x8a, 0xd7, 0xad, 0x78, 0x72, 0xf2,
	0x75, 0x72, 0x10, 0xef, 0x41, 0x3d, 0x60, 0x99, 0x52, 0xc1, 0x56, 0x8b, 0xcc, 0xb5, 0x92, 0x33,
	0x33, 0x21, 0x1a, 0x1f, 0xc1, 0xad, 0xe1, 0xec, 0x30, 0x9a, 0x84, 0x0e, 0xc5, 0xad, 0x89, 0x29,
	0xeb, 0x43, 0x23, 0x08, 0xe5, 0x91, 0x73, 0x2e, 0x13, 0x09, 0x4e, 0x61, 0xe3, 0xbb, 0x70, 0xbb,
	0x38, 0x44, 0x1d, 0xe1, 0x1d, 0x28, 0x9f, 0x9e, 0x45, 0x6a, 0x67, 0x37, 0x0b, 0x51, 0x1b, 0xd5,
	0xe2, 0x91, 0x6a, 0xfc, 0xa9, 0x06, 0xe5, 0xdd, 0xd9, 0x34, 0xff, 0x41, 0x51, 0x85, 0x3f, 0x28,
	0xba, 0x9b, 0xcf, 0xc1, 0x72, 0x18, 0x92, 0xe5, 0x5a, 0xdf, 0x04, 0xfd, 0xc8, 0x0f, 0x7f, 0x6a,
	0x85, 0xb6, 0xb4, 0x95, 0xd1, 0xca, 0x10, 0xe2, 0xbe, 0x32, 0x71, 0x1c, 0x06, 0xdc, 0x44, 0xa6,
	0xec, 0xce, 0xa6, 0x2b, 0xae, 0xb4, 0x22, 0xd2, 0xc5, 0x6c, 0xf5, 0x8c, 0x07, 0xa0, 0xa7, 0x28,
	0xd4, 0x1f, 0xbb, 0xc3, 0xf1, 0xf6, 0x26, 0x67, 0xb4, 0xd0, 0x35, 0xd6, 0x50, 0x77, 0x8c, 0x7e,
	0xb0, 0x3b, 0x1e, 0x0d, 0xbb, 0x25, 0xe3, 0x47, 0xd0, 0x4c, 0xc4, 0x6b, 0xdb, 0xa6, 0x82, 0x0d,
	0xc9, 0xf7, 0xb6, 0x5d, 0x10, 0x77, 0x4e, 0x83, 0x4a, 0xcf, 0xde, 0x4e, 0xe4, 0x92, 0x81, 0xe2,
	0x69, 0x54, 0xf5, 0x27, 0x39, 0x8d, 0xb1, 0x05, 0xad, 0x24, 0x60, 0x7c, 0x2e, 0x63, 0x8b, 0x5e,
	0x8c, 0xeb, 0x48, 0x2f, 0xf7, 0x9a, 0x1a, 0x8c, 0x18, 0x15, 0x33, 0x95, 0xa5, 0x82, 0x57, 0x61,
	0xac, 0x40, 0x4d, 0x3d, 0x47, 0x01, 0x95, 0x89, 0x6f, 0xb3, 0xca, 0xa8, 0x9a, 0xd4, 0x46, 0x16,
	0x4f, 0xa3, 0xe3, 0xc4, 0x63, 0x9a, 0x46, 0xc7, 0xc6, 0x5f, 0x97, 0xa0, 0xbd, 0x4e, 0xe1, 0x79,
	0x72, 0xcf, 0xb9, 0xa4, 0x94, 0x56, 0x48, 0x4a, 0xe5, 0x13, 0x50, 0xa5, 0x42, 0x02, 0xaa, 0xb0,
	0xa1, 0x72, 0xd1, 0xcd, 0x79, 0x03, 0xea, 0x33, 0xcf, 0x39, 0x4f, 0xf4, 0x8c, 0x6e, 0xd6, 0x10,
	0x1c, 0x45, 0x62, 0x09, 0x9a, 0xa8, 0x8a, 0x1c, 0x8f, 0x93, 0x3e, 0x9c, 0xb9, 0xc9, 0xa3, 0x2e,
	0xa5, 0x76, 0x6a, 0xaf, 0x4e, 0xed, 0xd4, 0x5f, 0x9b, 0xda, 0x69, 0xbc, 0x2e, 0xb5, 0xa3, 0x5f,
	0x4e, 0xed, 0x14, 0x5d, 0x34, 0xb8, 0xec, 0xa2, 0x19, 0x3b, 0xd0, 0x49, 0x78, 0xa7, 0x04, 0xfe,
	0x13, 0xb8, 0xa1, 0xb2, 0xb2, 0x32, 0x54, 0x89, 0x0d, 0x56, 0x63, 0x24, 0x81, 0x9c, 0x38, 0x55,
	0x14, 0xb3, 0x63, 0xe7, 0xc1, 0xc8, 0xf8, 0x2d, 0x0d, 0xda, 0x85, 0x1e, 0xe2, 0xa3, 0x2c, 0xc7,
	0xab, 0x91, 0x1c, 0xf7, 0xae, 0xcc, 0xf2, 0xea, 0x3c, 0x6f, 0xe9, 0x52, 0x9e, 0xd7, 0xb8, 0x9f,
	0x66, 0x6f, 0x55, 0xce, 0x76, 0x21, 0xcd, 0xd9, 0x52, 0x9a, 0x73, 0x6d, 0x34, 0x32, 0xbb, 0x25,
	0xe3, 0x0f, 0x4a, 0xd0, 0x1e, 0x9c, 0x07, 0xf4, 0x49, 0xcd, 0x6b, 0x1d, 0xd9, 0x9c, 0xc0, 0x94,
	0x0a, 0x02, 0x93, 0xbb, 0xfa, 0xb2, 0x2a, 0x4f, 0xf1, 0xd5, 0xa3, 0x6b, 0xcb, 0x19, 0x24, 0x25,
	0x12, 0x0c, 0xfd, 0x1f, 0x10, 0x09, 0xbc, 0xf2, 0x84, 0x31, 0xea, 0xca, 0xbf, 0xd2, 0x3b, 0xe3,
	0xcf, 0xe1, 0xdc, 0x34, 0x67, 0xc2, 0x80, 0xf1, 0x3b, 0x25, 0xd0, 0x59, 0x82, 0x70, 0x7b, 0xdf,
	0x52, 0x3a, 0x4b, 0xcb, 0x72, 0xd7, 0x29, 0x71, 0xe5, 0x99, 0xbc, 0xc8, 0xf4, 0xd6, 0xdc, 0x0a,
	0x8f, 0xca, 0xac, 0x70, 0x30, 0x49, 0x99, 0x95, 0xbb, 0xa0, 0xb3, 0x45, 0x9e, 0xa9, 0xc4, 0x69,
	0xc5, 0x64, 0x13, 0x7d, 0xe0, 0xd0, 0x57, 0x42, 0xb1, 0x0c, 0xa7, 0x8a, 0xcb, 0xd4, 0x2e, 0xba,
	0xed, 0x6d, 0xe5, 0x48, 0x1a, 0x27, 0x50, 0x57, 0xab, 0xa3, 0x5f, 0x75, 0xb0, 0xfb, 0x6c, 0x77,
	0xef, 0xfb, 0xbb, 0x05, 0xc9, 0x49, 0x3d, 0xaf, 0x52, 0xde, 0xf3, 0x2a, 0x23, 0x7e, 0x63, 0xef,
	0x60, 0x77, 0xd4, 0xad, 0x88, 0x36, 0xe8, 0xd4, 0x1c, 0x9b, 0x83, 0x17, 0xdd, 0x2a, 0x25, 0x19,
	0x36, 0x3e, 0x1d, 0x3c, 0x5f, 0xeb, 0xd6, 0xd2, 0x5a, 0x41, 0xdd, 0xf8, 0x13, 0x0d, 0x6e, 0xf2,
	0x91, 0xf3, 0x51, 0x77, 0xfe, 0x53, 0xd4, 0x0a, 0x7f, 0x8a, 0xfa, 0xbf, 0x1b, 0x68, 0xe3, 0xa0,
	0x99, 0x93, 0xd4, 0xe3, 0x38, 0x23, 0xd4, 0x98, 0x39, 0xaa, 0x0c, 0xf7, 0x77, 0x1a, 0xf4, 0xd9,
	0xe1, 0x7b, 0x1a, 0x5a, 0xc1, 0xc9, 0xf7, 0x76, 0xae, 0x84, 0x7c, 0xd7, 0xb9, 0x41, 0xf7, 0xa1,
	0x43, 0x1f, 0xeb, 0xfe, 0xc4, 0x1d, 0xab, 0xb0, 0x84, 0xef, 0xaf, 0xad, 0xb0, 0x3c, 0x91, 0x78,
	0x02, 0x2d, 0xfe, 0xa8, 0x97, 0x32, 0x94, 0x85, 0xca, 0x52, 0xc1, 0xdd, 0x6c, 0x72, 0x2f, 0xaa,
	0x71, 0x89, 0x8f, 0xd2, 0x41, 0x59, 0x74, 0x78, 0xb5, 0x78, 0xa4, 0x86, 0x8c, 0x28, 0x66, 0x7c,
	0x04, 0x77, 0xe7, 0x9e, 0x43, 0x09, 0x76, 0x2e, 0x53, 0xc7, 0xf2, 0x64, 0xfc, 0xa5, 0x06, 0x8d,
	0xf5, 0x99, 0x7b, 0x4a, 0x16, 0xea, 0x2d, 0x00, 0x69, 0x1f, 0x4b, 0xf5, 0x75, 0xac, 0x46, 0x0f,
	0x5c, 0x47, 0x0c, 0x7f, 0x1f, 0xfb, 0x09, 0x00, 0x9f, 0x71, 0x3c, 0xb5, 0x02, 0x75, 0x45, 0x54,
	0xe9, 0x49, 0x26, 0x50, 0x67, 0x79, 0x6e, 0x05, 0xaa, 0xd2, 0x13, 0x25, 0x70, 0x7f, 0x17, 0x3a,
	0x45, 0xe2, 0x9c, 0x5c, 0xc7, 0x7b, 0xc5, 0x2f, 0x06, 0xae, 0x72, 0x27, 0x73, 0xbd, 0x56, 0xff,
	0x56, 0x83, 0x0a, 0xba, 0x44, 0xe2, 0x21, 0xe8, 0x9f, 0x4a, 0x2b, 0x8c, 0x0f, 0xa5, 0x15, 0x8b,
	0x82, 0xfb, 0xd3, 0x27, 0x4e, 0x65, 0x85, 0x7d, 0x63, 0xe1, 0xb1, 0x26, 0x56, 0xf8, 0xf3, 0xc0,
	0xe4, 0xb3, 0xc7, 0x76, 0xe2, 0x5a, 0x91, 0xeb, 0xd5, 0x2f, 0x8c, 0x37, 0x16, 0x96, 0xa9, 0xff,
	0x67, 0xbe, 0xe3, 0x6d, 0xf0, 0x47, 0x69, 0xe2, 0xb2, 0x2b, 0x76, 0x79, 0x84, 0x78, 0x08, 0xb5,
	0xed, 0x08, 0x7d, 0xbe, 0xab, 0x5d, 0xe9, 0x3c, 0x79, 0x77, 0xd0, 0x58, 0x58, 0xfd, 0xb3, 0x32,
	0x54, 0x7e, 0x24, 0x43, 0x5f, 0x7c, 0x08, 0x75, 0xf5, 0x19, 0x84, 0xc8, 0x7d, 0xee, 0xd0, 0xa7,
	0xf0, 0xf3, 0xd2, 0xf7, 0x11, 0xb4, 0x4a, 0x97, 0x59, 0x92, 0xe5, 0xc3, 0x45, 0xf6, 0x95, 0xc6,
	0x95, 0x4d, 0x7d, 0x0c, 0xdd, 0x61, 0x1c, 0x4a, 0x6b, 0x9a, 0xeb, 0x5e, 0x64, 0xd5, 0xbc, 0xe4,
	0x3a, 0xf1, 0xeb, 0x01, 0xd4, 0xd8, 0xb1, 0xbe, 0x34, 0xe0, 0x72, 0xe6, 0x9c, 0x3a, 0xbf, 0x0f,
	0xcd, 0xe1, 0x89, 0x3f, 0x73, 0xed, 0xa1, 0x0c, 0xcf, 0xa4, 0xc8, 0x7d, 0x1e, 0xd5, 0xcf, 0xb5,
	0x8d, 0x05, 0xf1, 0x3e, 0xe8, 0xec, 0x76, 0xa1, 0xd3, 0x55, 0x57, 0x9e, 0x1c, 0xcf, 0x99, 0x73,
	0xc7, 0x8c, 0x05, 0xb1, 0x0c, 0x90, 0x73, 0xaf, 0x5f, 0xd5, 0xf3, 0x09, 0xb4, 0x37, 0x48, 0x07,
	0xec, 0x85, 0x6b, 0x87, 0x7e, 0x18, 0x8b, 0xcb, 0xdf, 0x43, 0xf5, 0x2f, 0x23, 0x8c, 0x05, 0xf1,
	0x18, 0x1a, 0xa3, 0xf0, 0x82, 0xfb, 0xdf, 0x54, 0x51, 0x49, 0xb6, 0xde, 0x9c, 0x43, 0xae, 0xfe,
	0x57, 0x05, 0x6a, 0xdf, 0xf7, 0xc3, 0x53, 0x19, 0x8a, 0x0f, 0xa0, 0x46, 0x65, 0x0d, 0x25, 0x45,
	0x69, 0x89, 0x63, 0xde, 0x42, 0xef, 0x82, 0x4e, 0x3c, 0x19, 0x59, 0xd1, 0x29, 0xdf, 0x14, 0x7d,
	0xd4, 0xce, 0x6c, 0xe1, 0xcc, 0x06, 0x5d, 0x6b, 0x87, 0xef, 0x29, 0x2d, 0xfb, 0x15, 0xca, 0x0e,
	0x7d, 0x3a, 0xff, 0xb3, 0x17, 0x43, 0x94, 0xcc, 0xc7, 0x1a, 0x1a, 0x97, 0x21, 0x9f, 0x14, 0x3b,
	0x65, 0x1f, 0xf3, 0xb2, 0xe0, 0x67, 0x5f, 0xcf, 0x1a, 0x0b, 0xe2, 0x11, 0xd4, 0x94, 0x26, 0xba,
	0x99, 0xbd, 0x2a, 0xa5, 0xde, 0xfa, 0xdd, 0x3c, 0x4a, 0x0d, 0xf8, 0x08, 0x6a, 0xac, 0xb5, 0x79,
	0x40, 0xc1, 0x9f, 0xec, 0x8b, 0x3c, 0x2a, 0x91, 0x65, 0xf1, 0x00, 0xea, 0xaa, 0x68, 0x21, 0xe6,
	0x54, 0x30, 0xf8, 0xa8, 0xec, 0xc8, 0xf2, 0xfc, 0x6c, 0x74, 0x79, 0xfe, 0x82, 0x67, 0xc2, 0xf3,
	0x17, 0x6d, 0x32, 0x0b, 0xbd, 0x29, 0x27, 0xd2, 0xc9, 0x05, 0xd4, 0x22, 0xe1, 0xc8, 0x9c, 0x97,
	0xfb, 0x31, 0xb4, 0x0b, 0xc1, 0xb7, 0x20, 0x4f, 0x6b, 0x5e, 0x3c, 0x7e, 0xe5, 0xbd, 0x7c, 0x17,
	0x74, 0x15, 0xfb, 0x1c, 0x4a, 0x41, 0xf5, 0x86, 0x39, 0xd1, 0x53, 0xff, 0x6a, 0xf0, 0x43, 0x8f,
	0xe0, 0x07, 0x70, 0x6b, 0x8e, 0x0a, 0x16, 0xf4, 0x99, 0xd9, 0xf5, 0x36, 0xa6, 0xbf, 0x78, 0x2d,
	0x3d, 0x61, 0xc0, 0x7a, 0xef, 0xef, 0xbf, 0xbc, 0xa7, 0xfd, 0xfc, 0xcb, 0x7b, 0xda, 0xbf, 0x7e,
	0x79, 0x4f, 0xfb, 0xbd, 0x5f, 0xdc, 0x5b, 0xf8, 0xf9, 0x2f, 0xee, 0x2d, 0xfc, 0xf3, 0x2f, 0xee,
	0x2d, 0x1c, 0xd6, 0xe8, 0x8f, 0x1e, 0x4f, 0xfe, 0x3b, 0x00, 0x00, 0xff, 0xff, 0x42, 0x95, 0x1f,
	0xb9, 0x5e, 0x32, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RaftClient is the client API for Raft service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RaftClient interface {
	Heartbeat(ctx context.Context, in *api.Payload, opts ...grpc.CallOption) (Raft_HeartbeatClient, error)
	RaftMessage(ctx context.Context, opts ...grpc.CallOption) (Raft_RaftMessageClient, error)
	JoinCluster(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (*api.Payload, error)
	IsPeer(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (*PeerResponse, error)
}

type raftClient struct {
	cc *grpc.ClientConn
}

func NewRaftClient(cc *grpc.ClientConn) RaftClient {
	return &raftClient{cc}
}

func (c *raftClient) Heartbeat(ctx context.Context, in *api.Payload, opts ...grpc.CallOption) (Raft_HeartbeatClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Raft_serviceDesc.Streams[0], "/pb.Raft/Heartbeat", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftHeartbeatClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Raft_HeartbeatClient interface {
	Recv() (*HealthInfo, error)
	grpc.ClientStream
}

type raftHeartbeatClient struct {
	grpc.ClientStream
}

func (x *raftHeartbeatClient) Recv() (*HealthInfo, error) {
	m := new(HealthInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *raftClient) RaftMessage(ctx context.Context, opts ...grpc.CallOption) (Raft_RaftMessageClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Raft_serviceDesc.Streams[1], "/pb.Raft/RaftMessage", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftRaftMessageClient{stream}
	return x, nil
}

type Raft_RaftMessageClient interface {
	Send(*RaftBatch) error
	CloseAndRecv() (*api.Payload, error)
	grpc.ClientStream
}

type raftRaftMessageClient struct {
	grpc.ClientStream
}

func (x *raftRaftMessageClient) Send(m *RaftBatch) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftRaftMessageClient) CloseAndRecv() (*api.Payload, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(api.Payload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *raftClient) JoinCluster(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (*api.Payload, error) {
	out := new(api.Payload)
	err := c.cc.Invoke(ctx, "/pb.Raft/JoinCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftClient) IsPeer(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (*PeerResponse, error) {
	out := new(PeerResponse)
	err := c.cc.Invoke(ctx, "/pb.Raft/IsPeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RaftServer is the server API for Raft service.
type RaftServer interface {
	Heartbeat(*api.Payload, Raft_HeartbeatServer) error
	RaftMessage(Raft_RaftMessageServer) error
	JoinCluster(context.Context, *RaftContext) (*api.Payload, error)
	IsPeer(context.Context, *RaftContext) (*PeerResponse, error)
}

// UnimplementedRaftServer can be embedded to have forward compatible implementations.
type UnimplementedRaftServer struct {
}

func (*UnimplementedRaftServer) Heartbeat(req *api.Payload, srv Raft_HeartbeatServer) error {
	return status.Errorf(codes.Unimplemented, "method Heartbeat not implemented")
}
func (*UnimplementedRaftServer) RaftMessage(srv Raft_RaftMessageServer) error {
	return status.Errorf(codes.Unimplemented, "method RaftMessage not implemented")
}
func (*UnimplementedRaftServer) JoinCluster(ctx context.Context, req *RaftContext) (*api.Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinCluster not implemented")
}
func (*UnimplementedRaftServer) IsPeer(ctx context.Context, req *RaftContext) (*PeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsPeer not implemented")
}

func RegisterRaftServer(s *grpc.Server, srv RaftServer) {
	s.RegisterService(&_Raft_serviceDesc, srv)
}

func _Raft_Heartbeat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.Payload)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RaftServer).Heartbeat(m, &raftHeartbeatServer{stream})
}

type Raft_HeartbeatServer interface {
	Send(*HealthInfo) error
	grpc.ServerStream
}

type raftHeartbeatServer struct {
	grpc.ServerStream
}

func (x *raftHeartbeatServer) Send(m *HealthInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _Raft_RaftMessage_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftServer).RaftMessage(&raftRaftMessageServer{stream})
}

type Raft_RaftMessageServer interface {
	SendAndClose(*api.Payload) error
	Recv() (*RaftBatch, error)
	grpc.ServerStream
}

type raftRaftMessageServer struct {
	grpc.ServerStream
}

func (x *raftRaftMessageServer) SendAndClose(m *api.Payload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftRaftMessageServer) Recv() (*RaftBatch, error) {
	m := new(RaftBatch)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Raft_JoinCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaftContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServer).JoinCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Raft/JoinCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServer).JoinCluster(ctx, req.(*RaftContext))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raft_IsPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaftContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServer).IsPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Raft/IsPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServer).IsPeer(ctx, req.(*RaftContext))
	}
	return interceptor(ctx, in, info, handler)
}

var _Raft_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Raft",
	HandlerType: (*RaftServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "JoinCluster",
			Handler:    _Raft_JoinCluster_Handler,
		},
		{
			MethodName: "IsPeer",
			Handler:    _Raft_IsPeer_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Heartbeat",
			Handler:       _Raft_Heartbeat_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RaftMessage",
			Handler:       _Raft_RaftMessage_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "pb.proto",
}

// ZeroClient is the client API for Zero service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ZeroClient interface {
	// These 3 endpoints are for handling membership.
	Connect(ctx context.Context, in *Member, opts ...grpc.CallOption) (*ConnectionState, error)
	UpdateMembership(ctx context.Context, in *Group, opts ...grpc.CallOption) (*api.Payload, error)
	StreamMembership(ctx context.Context, in *api.Payload, opts ...grpc.CallOption) (Zero_StreamMembershipClient, error)
	Oracle(ctx context.Context, in *api.Payload, opts ...grpc.CallOption) (Zero_OracleClient, error)
	ShouldServe(ctx context.Context, in *Tablet, opts ...grpc.CallOption) (*Tablet, error)
	AssignIds(ctx context.Context, in *Num, opts ...grpc.CallOption) (*AssignedIds, error)
	Timestamps(ctx context.Context, in *Num, opts ...grpc.CallOption) (*AssignedIds, error)
	CommitOrAbort(ctx context.Context, in *api.TxnContext, opts ...grpc.CallOption) (*api.TxnContext, error)
	TryAbort(ctx context.Context, in *TxnTimestamps, opts ...grpc.CallOption) (*OracleDelta, error)
}

type zeroClient struct {
	cc *grpc.ClientConn
}

func NewZeroClient(cc *grpc.ClientConn) ZeroClient {
	return &zeroClient{cc}
}

func (c *zeroClient) Connect(ctx context.Context, in *Member, opts ...grpc.CallOption) (*ConnectionState, error) {
	out := new(ConnectionState)
	err := c.cc.Invoke(ctx, "/pb.Zero/Connect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) UpdateMembership(ctx context.Context, in *Group, opts ...grpc.CallOption) (*api.Payload, error) {
	out := new(api.Payload)
	err := c.cc.Invoke(ctx, "/pb.Zero/UpdateMembership", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) StreamMembership(ctx context.Context, in *api.Payload, opts ...grpc.CallOption) (Zero_StreamMembershipClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Zero_serviceDesc.Streams[0], "/pb.Zero/StreamMembership", opts...)
	if err != nil {
		return nil, err
	}
	x := &zeroStreamMembershipClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Zero_StreamMembershipClient interface {
	Recv() (*MembershipState, error)
	grpc.ClientStream
}

type zeroStreamMembershipClient struct {
	grpc.ClientStream
}

func (x *zeroStreamMembershipClient) Recv() (*MembershipState, error) {
	m := new(MembershipState)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *zeroClient) Oracle(ctx context.Context, in *api.Payload, opts ...grpc.CallOption) (Zero_OracleClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Zero_serviceDesc.Streams[1], "/pb.Zero/Oracle", opts...)
	if err != nil {
		return nil, err
	}
	x := &zeroOracleClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Zero_OracleClient interface {
	Recv() (*OracleDelta, error)
	grpc.ClientStream
}

type zeroOracleClient struct {
	grpc.ClientStream
}

func (x *zeroOracleClient) Recv() (*OracleDelta, error) {
	m := new(OracleDelta)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *zeroClient) ShouldServe(ctx context.Context, in *Tablet, opts ...grpc.CallOption) (*Tablet, error) {
	out := new(Tablet)
	err := c.cc.Invoke(ctx, "/pb.Zero/ShouldServe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) AssignIds(ctx context.Context, in *Num, opts ...grpc.CallOption) (*AssignedIds, error) {
	out := new(AssignedIds)
	err := c.cc.Invoke(ctx, "/pb.Zero/AssignIds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) Timestamps(ctx context.Context, in *Num, opts ...grpc.CallOption) (*AssignedIds, error) {
	out := new(AssignedIds)
	err := c.cc.Invoke(ctx, "/pb.Zero/Timestamps", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) CommitOrAbort(ctx context.Context, in *api.TxnContext, opts ...grpc.CallOption) (*api.TxnContext, error) {
	out := new(api.TxnContext)
	err := c.cc.Invoke(ctx, "/pb.Zero/CommitOrAbort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) TryAbort(ctx context.Context, in *TxnTimestamps, opts ...grpc.CallOption) (*OracleDelta, error) {
	out := new(OracleDelta)
	err := c.cc.Invoke(ctx, "/pb.Zero/TryAbort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ZeroServer is the server API for Zero service.
type ZeroServer interface {
	// These 3 endpoints are for handling membership.
	Connect(context.Context, *Member) (*ConnectionState, error)
	UpdateMembership(context.Context, *Group) (*api.Payload, error)
	StreamMembership(*api.Payload, Zero_StreamMembershipServer) error
	Oracle(*api.Payload, Zero_OracleServer) error
	ShouldServe(context.Context, *Tablet) (*Tablet, error)
	AssignIds(context.Context, *Num) (*AssignedIds, error)
	Timestamps(context.Context, *Num) (*AssignedIds, error)
	CommitOrAbort(context.Context, *api.TxnContext) (*api.TxnContext, error)
	TryAbort(context.Context, *TxnTimestamps) (*OracleDelta, error)
}

// UnimplementedZeroServer can be embedded to have forward compatible implementations.
type UnimplementedZeroServer struct {
}

func (*UnimplementedZeroServer) Connect(ctx context.Context, req *Member) (*ConnectionState, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (*UnimplementedZeroServer) UpdateMembership(ctx context.Context, req *Group) (*api.Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMembership not implemented")
}
func (*UnimplementedZeroServer) StreamMembership(req *api.Payload, srv Zero_StreamMembershipServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamMembership not implemented")
}
func (*UnimplementedZeroServer) Oracle(req *api.Payload, srv Zero_OracleServer) error {
	return status.Errorf(codes.Unimplemented, "method Oracle not implemented")
}
func (*UnimplementedZeroServer) ShouldServe(ctx context.Context, req *Tablet) (*Tablet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShouldServe not implemented")
}
func (*UnimplementedZeroServer) AssignIds(ctx context.Context, req *Num) (*AssignedIds, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssignIds not implemented")
}
func (*UnimplementedZeroServer) Timestamps(ctx context.Context, req *Num) (*AssignedIds, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Timestamps not implemented")
}
func (*UnimplementedZeroServer) CommitOrAbort(ctx context.Context, req *api.TxnContext) (*api.TxnContext, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitOrAbort not implemented")
}
func (*UnimplementedZeroServer) TryAbort(ctx context.Context, req *TxnTimestamps) (*OracleDelta, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TryAbort not implemented")
}

func RegisterZeroServer(s *grpc.Server, srv ZeroServer) {
	s.RegisterService(&_Zero_serviceDesc, srv)
}

func _Zero_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Member)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Zero/Connect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).Connect(ctx, req.(*Member))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_UpdateMembership_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Group)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).UpdateMembership(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Zero/UpdateMembership",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).UpdateMembership(ctx, req.(*Group))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_StreamMembership_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.Payload)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ZeroServer).StreamMembership(m, &zeroStreamMembershipServer{stream})
}

type Zero_StreamMembershipServer interface {
	Send(*MembershipState) error
	grpc.ServerStream
}

type zeroStreamMembershipServer struct {
	grpc.ServerStream
}

func (x *zeroStreamMembershipServer) Send(m *MembershipState) error {
	return x.ServerStream.SendMsg(m)
}

func _Zero_Oracle_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.Payload)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ZeroServer).Oracle(m, &zeroOracleServer{stream})
}

type Zero_OracleServer interface {
	Send(*OracleDelta) error
	grpc.ServerStream
}

type zeroOracleServer struct {
	grpc.ServerStream
}

func (x *zeroOracleServer) Send(m *OracleDelta) error {
	return x.ServerStream.SendMsg(m)
}

func _Zero_ShouldServe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Tablet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).ShouldServe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Zero/ShouldServe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).ShouldServe(ctx, req.(*Tablet))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_AssignIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Num)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).AssignIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Zero/AssignIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).AssignIds(ctx, req.(*Num))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_Timestamps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Num)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).Timestamps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Zero/Timestamps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).Timestamps(ctx, req.(*Num))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_CommitOrAbort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.TxnContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).CommitOrAbort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Zero/CommitOrAbort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).CommitOrAbort(ctx, req.(*api.TxnContext))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_TryAbort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxnTimestamps)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).TryAbort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Zero/TryAbort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).TryAbort(ctx, req.(*TxnTimestamps))
	}
	return interceptor(ctx, in, info, handler)
}

var _Zero_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Zero",
	HandlerType: (*ZeroServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Connect",
			Handler:    _Zero_Connect_Handler,
		},
		{
			MethodName: "UpdateMembership",
			Handler:    _Zero_UpdateMembership_Handler,
		},
		{
			MethodName: "ShouldServe",
			Handler:    _Zero_ShouldServe_Handler,
		},
		{
			MethodName: "AssignIds",
			Handler:    _Zero_AssignIds_Handler,
		},
		{
			MethodName: "Timestamps",
			Handler:    _Zero_Timestamps_Handler,
		},
		{
			MethodName: "CommitOrAbort",
			Handler:    _Zero_CommitOrAbort_Handler,
		},
		{
			MethodName: "TryAbort",
			Handler:    _Zero_TryAbort_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamMembership",
			Handler:       _Zero_StreamMembership_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Oracle",
			Handler:       _Zero_Oracle_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pb.proto",
}

// WorkerClient is the client API for Worker service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WorkerClient interface {
	// Data serving RPCs.
	Mutate(ctx context.Context, in *Mutations, opts ...grpc.CallOption) (*api.TxnContext, error)
	ServeTask(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Result, error)
	StreamSnapshot(ctx context.Context, opts ...grpc.CallOption) (Worker_StreamSnapshotClient, error)
	Sort(ctx context.Context, in *SortMessage, opts ...grpc.CallOption) (*SortResult, error)
	Schema(ctx context.Context, in *SchemaRequest, opts ...grpc.CallOption) (*SchemaResult, error)
	Backup(ctx context.Context, in *BackupRequest, opts ...grpc.CallOption) (*BackupResponse, error)
	Restore(ctx context.Context, in *RestoreRequest, opts ...grpc.CallOption) (*Status, error)
	Export(ctx context.Context, in *ExportRequest, opts ...grpc.CallOption) (*ExportResponse, error)
	ReceivePredicate(ctx context.Context, opts ...grpc.CallOption) (Worker_ReceivePredicateClient, error)
	MovePredicate(ctx context.Context, in *MovePredicatePayload, opts ...grpc.CallOption) (*api.Payload, error)
	Subscribe(ctx context.Context, in *SubscriptionRequest, opts ...grpc.CallOption) (Worker_SubscribeClient, error)
	UpdateGraphQLSchema(ctx context.Context, in *UpdateGraphQLSchemaRequest, opts ...grpc.CallOption) (*UpdateGraphQLSchemaResponse, error)
}

type workerClient struct {
	cc *grpc.ClientConn
}

func NewWorkerClient(cc *grpc.ClientConn) WorkerClient {
	return &workerClient{cc}
}

func (c *workerClient) Mutate(ctx context.Context, in *Mutations, opts ...grpc.CallOption) (*api.TxnContext, error) {
	out := new(api.TxnContext)
	err := c.cc.Invoke(ctx, "/pb.Worker/Mutate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) ServeTask(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/pb.Worker/ServeTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) StreamSnapshot(ctx context.Context, opts ...grpc.CallOption) (Worker_StreamSnapshotClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Worker_serviceDesc.Streams[0], "/pb.Worker/StreamSnapshot", opts...)
	if err != nil {
		return nil, err
	}
	x := &workerStreamSnapshotClient{stream}
	return x, nil
}

type Worker_StreamSnapshotClient interface {
	Send(*Snapshot) error
	Recv() (*KVS, error)
	grpc.ClientStream
}

type workerStreamSnapshotClient struct {
	grpc.ClientStream
}

func (x *workerStreamSnapshotClient) Send(m *Snapshot) error {
	return x.ClientStream.SendMsg(m)
}

func (x *workerStreamSnapshotClient) Recv() (*KVS, error) {
	m := new(KVS)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workerClient) Sort(ctx context.Context, in *SortMessage, opts ...grpc.CallOption) (*SortResult, error) {
	out := new(SortResult)
	err := c.cc.Invoke(ctx, "/pb.Worker/Sort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) Schema(ctx context.Context, in *SchemaRequest, opts ...grpc.CallOption) (*SchemaResult, error) {
	out := new(SchemaResult)
	err := c.cc.Invoke(ctx, "/pb.Worker/Schema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) Backup(ctx context.Context, in *BackupRequest, opts ...grpc.CallOption) (*BackupResponse, error) {
	out := new(BackupResponse)
	err := c.cc.Invoke(ctx, "/pb.Worker/Backup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) Restore(ctx context.Context, in *RestoreRequest, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/pb.Worker/Restore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) Export(ctx context.Context, in *ExportRequest, opts ...grpc.CallOption) (*ExportResponse, error) {
	out := new(ExportResponse)
	err := c.cc.Invoke(ctx, "/pb.Worker/Export", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) ReceivePredicate(ctx context.Context, opts ...grpc.CallOption) (Worker_ReceivePredicateClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Worker_serviceDesc.Streams[1], "/pb.Worker/ReceivePredicate", opts...)
	if err != nil {
		return nil, err
	}
	x := &workerReceivePredicateClient{stream}
	return x, nil
}

type Worker_ReceivePredicateClient interface {
	Send(*KVS) error
	CloseAndRecv() (*api.Payload, error)
	grpc.ClientStream
}

type workerReceivePredicateClient struct {
	grpc.ClientStream
}

func (x *workerReceivePredicateClient) Send(m *KVS) error {
	return x.ClientStream.SendMsg(m)
}

func (x *workerReceivePredicateClient) CloseAndRecv() (*api.Payload, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(api.Payload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workerClient) MovePredicate(ctx context.Context, in *MovePredicatePayload, opts ...grpc.CallOption) (*api.Payload, error) {
	out := new(api.Payload)
	err := c.cc.Invoke(ctx, "/pb.Worker/MovePredicate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) Subscribe(ctx context.Context, in *SubscriptionRequest, opts ...grpc.CallOption) (Worker_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Worker_serviceDesc.Streams[2], "/pb.Worker/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &workerSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Worker_SubscribeClient interface {
	Recv() (*pb.KVList, error)
	grpc.ClientStream
}

type workerSubscribeClient struct {
	grpc.ClientStream
}

func (x *workerSubscribeClient) Recv() (*pb.KVList, error) {
	m := new(pb.KVList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workerClient) UpdateGraphQLSchema(ctx context.Context, in *UpdateGraphQLSchemaRequest, opts ...grpc.CallOption) (*UpdateGraphQLSchemaResponse, error) {
	out := new(UpdateGraphQLSchemaResponse)
	err := c.cc.Invoke(ctx, "/pb.Worker/UpdateGraphQLSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkerServer is the server API for Worker service.
type WorkerServer interface {
	// Data serving RPCs.
	Mutate(context.Context, *Mutations) (*api.TxnContext, error)
	ServeTask(context.Context, *Query) (*Result, error)
	StreamSnapshot(Worker_StreamSnapshotServer) error
	Sort(context.Context, *SortMessage) (*SortResult, error)
	Schema(context.Context, *SchemaRequest) (*SchemaResult, error)
	Backup(context.Context, *BackupRequest) (*BackupResponse, error)
	Restore(context.Context, *RestoreRequest) (*Status, error)
	Export(context.Context, *ExportRequest) (*ExportResponse, error)
	ReceivePredicate(Worker_ReceivePredicateServer) error
	MovePredicate(context.Context, *MovePredicatePayload) (*api.Payload, error)
	Subscribe(*SubscriptionRequest, Worker_SubscribeServer) error
	UpdateGraphQLSchema(context.Context, *UpdateGraphQLSchemaRequest) (*UpdateGraphQLSchemaResponse, error)
}

// UnimplementedWorkerServer can be embedded to have forward compatible implementations.
type UnimplementedWorkerServer struct {
}

func (*UnimplementedWorkerServer) Mutate(ctx context.Context, req *Mutations) (*api.TxnContext, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Mutate not implemented")
}
func (*UnimplementedWorkerServer) ServeTask(ctx context.Context, req *Query) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServeTask not implemented")
}
func (*UnimplementedWorkerServer) StreamSnapshot(srv Worker_StreamSnapshotServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamSnapshot not implemented")
}
func (*UnimplementedWorkerServer) Sort(ctx context.Context, req *SortMessage) (*SortResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sort not implemented")
}
func (*UnimplementedWorkerServer) Schema(ctx context.Context, req *SchemaRequest) (*SchemaResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Schema not implemented")
}
func (*UnimplementedWorkerServer) Backup(ctx context.Context, req *BackupRequest) (*BackupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Backup not implemented")
}
func (*UnimplementedWorkerServer) Restore(ctx context.Context, req *RestoreRequest) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Restore not implemented")
}
func (*UnimplementedWorkerServer) Export(ctx context.Context, req *ExportRequest) (*ExportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Export not implemented")
}
func (*UnimplementedWorkerServer) ReceivePredicate(srv Worker_ReceivePredicateServer) error {
	return status.Errorf(codes.Unimplemented, "method ReceivePredicate not implemented")
}
func (*UnimplementedWorkerServer) MovePredicate(ctx context.Context, req *MovePredicatePayload) (*api.Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MovePredicate not implemented")
}
func (*UnimplementedWorkerServer) Subscribe(req *SubscriptionRequest, srv Worker_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (*UnimplementedWorkerServer) UpdateGraphQLSchema(ctx context.Context, req *UpdateGraphQLSchemaRequest) (*UpdateGraphQLSchemaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGraphQLSchema not implemented")
}

func RegisterWorkerServer(s *grpc.Server, srv WorkerServer) {
	s.RegisterService(&_Worker_serviceDesc, srv)
}

func _Worker_Mutate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Mutations)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Mutate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/Mutate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Mutate(ctx, req.(*Mutations))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_ServeTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).ServeTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/ServeTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).ServeTask(ctx, req.(*Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_StreamSnapshot_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WorkerServer).StreamSnapshot(&workerStreamSnapshotServer{stream})
}

type Worker_StreamSnapshotServer interface {
	Send(*KVS) error
	Recv() (*Snapshot, error)
	grpc.ServerStream
}

type workerStreamSnapshotServer struct {
	grpc.ServerStream
}

func (x *workerStreamSnapshotServer) Send(m *KVS) error {
	return x.ServerStream.SendMsg(m)
}

func (x *workerStreamSnapshotServer) Recv() (*Snapshot, error) {
	m := new(Snapshot)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Worker_Sort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SortMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Sort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/Sort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Sort(ctx, req.(*SortMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_Schema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Schema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/Schema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Schema(ctx, req.(*SchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_Backup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BackupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Backup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/Backup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Backup(ctx, req.(*BackupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_Restore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Restore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/Restore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Restore(ctx, req.(*RestoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_Export_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Export(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/Export",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Export(ctx, req.(*ExportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_ReceivePredicate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WorkerServer).ReceivePredicate(&workerReceivePredicateServer{stream})
}

type Worker_ReceivePredicateServer interface {
	SendAndClose(*api.Payload) error
	Recv() (*KVS, error)
	grpc.ServerStream
}

type workerReceivePredicateServer struct {
	grpc.ServerStream
}

func (x *workerReceivePredicateServer) SendAndClose(m *api.Payload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *workerReceivePredicateServer) Recv() (*KVS, error) {
	m := new(KVS)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Worker_MovePredicate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MovePredicatePayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).MovePredicate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/MovePredicate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).MovePredicate(ctx, req.(*MovePredicatePayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscriptionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WorkerServer).Subscribe(m, &workerSubscribeServer{stream})
}

type Worker_SubscribeServer interface {
	Send(*pb.KVList) error
	grpc.ServerStream
}

type workerSubscribeServer struct {
	grpc.ServerStream
}

func (x *workerSubscribeServer) Send(m *pb.KVList) error {
	return x.ServerStream.SendMsg(m)
}

func _Worker_UpdateGraphQLSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGraphQLSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).UpdateGraphQLSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Worker/UpdateGraphQLSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).UpdateGraphQLSchema(ctx, req.(*UpdateGraphQLSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Worker_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Worker",
	HandlerType: (*WorkerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Mutate",
			Handler:    _Worker_Mutate_Handler,
		},
		{
			MethodName: "ServeTask",
			Handler:    _Worker_ServeTask_Handler,
		},
		{
			MethodName: "Sort",
			Handler:    _Worker_Sort_Handler,
		},
		{
			MethodName: "Schema",
			Handler:    _Worker_Schema_Handler,
		},
		{
			MethodName: "Backup",
			Handler:    _Worker_Backup_Handler,
		},
		{
			MethodName: "Restore",
			Handler:    _Worker_Restore_Handler,
		},
		{
			MethodName: "Export",
			Handler:    _Worker_Export_Handler,
		},
		{
			MethodName: "MovePredicate",
			Handler:    _Worker_MovePredicate_Handler,
		},
		{
			MethodName: "UpdateGraphQLSchema",
			Handler:    _Worker_UpdateGraphQLSchema_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamSnapshot",
			Handler:       _Worker_StreamSnapshot_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "ReceivePredicate",
			Handler:       _Worker_ReceivePredicate_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _Worker_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pb.proto",
}

func (m *List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *List) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *List) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Uids) > 0 {
		for iNdEx := len(m.Uids) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Uids[iNdEx]))
		}
		i = encodeVarintPb(dAtA, i, uint64(len(m.Uids)*8))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TaskValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValType != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ValType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Val) > 0 {
		i -= len(m.Val)
		copy(dAtA[i:], m.Val)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Val)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SrcFunction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SrcFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SrcFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsCount {
		i--
		if m.IsCount {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Args[iNdEx])
			copy(dAtA[i:], m.Args[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Args[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Query) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Query) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Query) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.First != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.First))
		i--
		dAtA[i] = 0x78
	}
	if m.Cache != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Cache))
		i--
		dAtA[i] = 0x70
	}
	if m.ReadTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ReadTs))
		i--
		dAtA[i] = 0x68
	}
	if m.ExpandAll {
		i--
		if m.ExpandAll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.FacetsFilter != nil {
		{
			size, err := m.FacetsFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.FacetParam != nil {
		{
			size, err := m.FacetParam.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Reverse {
		i--
		if m.Reverse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.SrcFunc != nil {
		{
			size, err := m.SrcFunc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.UidList != nil {
		{
			size, err := m.UidList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DoCount {
		i--
		if m.DoCount {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.AfterUid != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.AfterUid))
		i--
		dAtA[i] = 0x19
	}
	if len(m.Langs) > 0 {
		for iNdEx := len(m.Langs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Langs[iNdEx])
			copy(dAtA[i:], m.Langs[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Langs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Attr) > 0 {
		i -= len(m.Attr)
		copy(dAtA[i:], m.Attr)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Attr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValueList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValueList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LangList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LangList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LangList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Lang) > 0 {
		for iNdEx := len(m.Lang) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Lang[iNdEx])
			copy(dAtA[i:], m.Lang[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Lang[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Result) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Result) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.List {
		i--
		if m.List {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.LangMatrix) > 0 {
		for iNdEx := len(m.LangMatrix) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LangMatrix[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.FacetMatrix) > 0 {
		for iNdEx := len(m.FacetMatrix) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FacetMatrix[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.IntersectDest {
		i--
		if m.IntersectDest {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Counts) > 0 {
		dAtA6 := make([]byte, len(m.Counts)*10)
		var j5 int
		for _, num := range m.Counts {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintPb(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ValueMatrix) > 0 {
		for iNdEx := len(m.ValueMatrix) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValueMatrix[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.UidMatrix) > 0 {
		for iNdEx := len(m.UidMatrix) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UidMatrix[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Langs) > 0 {
		for iNdEx := len(m.Langs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Langs[iNdEx])
			copy(dAtA[i:], m.Langs[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Langs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Desc {
		i--
		if m.Desc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Attr) > 0 {
		i -= len(m.Attr)
		copy(dAtA[i:], m.Attr)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Attr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SortMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SortMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SortMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReadTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ReadTs))
		i--
		dAtA[i] = 0x68
	}
	if m.Offset != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x20
	}
	if m.Count != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x18
	}
	if len(m.UidMatrix) > 0 {
		for iNdEx := len(m.UidMatrix) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UidMatrix[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Order) > 0 {
		for iNdEx := len(m.Order) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Order[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SortResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SortResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SortResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UidMatrix) > 0 {
		for iNdEx := len(m.UidMatrix) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UidMatrix[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RaftContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsLearner {
		i--
		if m.IsLearner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.SnapshotTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.SnapshotTs))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Group != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Id))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Member) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Member) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForceGroupId {
		i--
		if m.ForceGroupId {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.ClusterInfoOnly {
		i--
		if m.ClusterInfoOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.Learner {
		i--
		if m.Learner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.LastUpdate != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.LastUpdate))
		i--
		dAtA[i] = 0x30
	}
	if m.AmDead {
		i--
		if m.AmDead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Leader {
		i--
		if m.Leader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Id))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Group) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Group) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Group) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CheckpointTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.CheckpointTs))
		i--
		dAtA[i] = 0x28
	}
	if m.Checksum != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Checksum))
		i--
		dAtA[i] = 0x20
	}
	if m.SnapshotTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.SnapshotTs))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Tablets) > 0 {
		for k := range m.Tablets {
			v := m.Tablets[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPb(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPb(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Members) > 0 {
		for k := range m.Members {
			v := m.Members[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPb(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintPb(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintPb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *License) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *License) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *License) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ExpiryTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ExpiryTs))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxNodes != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.MaxNodes))
		i--
		dAtA[i] = 0x10
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintPb(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZeroProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxNsID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.MaxNsID))
		i--
		dAtA[i] = 0x60
	}
	if m.Snapshot != nil {
		{
			size, err := m.Snapshot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.License != nil {
		{
			size, err := m.License.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Txn != nil {
		{
			size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.MaxRaftId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.MaxRaftId))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxTxnTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.MaxTxnTs))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxUID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.MaxUID))
		i--
		dAtA[i] = 0x20
	}
	if m.Tablet != nil {
		{
			size, err := m.Tablet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Member != nil {
		{
			size, err := m.Member.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.SnapshotTs) > 0 {
		for k := range m.SnapshotTs {
			v := m.SnapshotTs[k]
			baseI := i
			i = encodeVarintPb(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintPb(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintPb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MembershipState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MembershipState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MembershipState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxNsID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.MaxNsID))
		i--
		dAtA[i] = 0x50
	}
	if m.License != nil {
		{
			size, err := m.License.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Removed) > 0 {
		for iNdEx := len(m.Removed) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Removed[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.MaxRaftId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.MaxRaftId))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxTxnTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.MaxTxnTs))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxUID != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.MaxUID))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Zeros) > 0 {
		for k := range m.Zeros {
			v := m.Zeros[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPb(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintPb(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintPb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Groups) > 0 {
		for k := range m.Groups {
			v := m.Groups[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPb(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintPb(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintPb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Counter != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Counter))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConnectionState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConnectionState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxPending != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.MaxPending))
		i--
		dAtA[i] = 0x18
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Member != nil {
		{
			size, err := m.Member.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HealthInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HealthInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxAssigned != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.MaxAssigned))
		i--
		dAtA[i] = 0x58
	}
	if len(m.EeFeatures) > 0 {
		for iNdEx := len(m.EeFeatures) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EeFeatures[iNdEx])
			copy(dAtA[i:], m.EeFeatures[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.EeFeatures[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Indexing) > 0 {
		for iNdEx := len(m.Indexing) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Indexing[iNdEx])
			copy(dAtA[i:], m.Indexing[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Indexing[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Ongoing) > 0 {
		for iNdEx := len(m.Ongoing) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Ongoing[iNdEx])
			copy(dAtA[i:], m.Ongoing[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Ongoing[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.LastEcho != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.LastEcho))
		i--
		dAtA[i] = 0x38
	}
	if m.Uptime != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Uptime))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Group) > 0 {
		i -= len(m.Group)
		copy(dAtA[i:], m.Group)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Group)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Instance) > 0 {
		i -= len(m.Instance)
		copy(dAtA[i:], m.Instance)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Instance)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tablet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tablet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tablet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UncompressedBytes != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.UncompressedBytes))
		i--
		dAtA[i] = 0x58
	}
	if m.MoveTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.MoveTs))
		i--
		dAtA[i] = 0x50
	}
	if m.ReadOnly {
		i--
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Remove {
		i--
		if m.Remove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.OnDiskBytes != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.OnDiskBytes))
		i--
		dAtA[i] = 0x38
	}
	if m.Force {
		i--
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Predicate) > 0 {
		i -= len(m.Predicate)
		copy(dAtA[i:], m.Predicate)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Predicate)))
		i--
		dAtA[i] = 0x12
	}
	if m.GroupId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DirectedEdge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectedEdge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectedEdge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AllowedPreds) > 0 {
		for iNdEx := len(m.AllowedPreds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedPreds[iNdEx])
			copy(dAtA[i:], m.AllowedPreds[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.AllowedPreds[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Facets) > 0 {
		for iNdEx := len(m.Facets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Facets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Op != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Lang) > 0 {
		i -= len(m.Lang)
		copy(dAtA[i:], m.Lang)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Lang)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x32
	}
	if m.ValueId != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ValueId))
		i--
		dAtA[i] = 0x29
	}
	if m.ValueType != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ValueType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Attr) > 0 {
		i -= len(m.Attr)
		copy(dAtA[i:], m.Attr)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Attr)))
		i--
		dAtA[i] = 0x12
	}
	if m.Entity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Entity))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Mutations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mutations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Mutations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DropValue) > 0 {
		i -= len(m.DropValue)
		copy(dAtA[i:], m.DropValue)
		i = encodeVarintPb(dAtA, i, uint64(len(m.DropValue)))
		i--
		dAtA[i] = 0x42
	}
	if m.DropOp != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.DropOp))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Schema) > 0 {
		for iNdEx := len(m.Schema) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Schema[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Edges) > 0 {
		for iNdEx := len(m.Edges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Edges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.StartTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.StartTs))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PredHints) > 0 {
		for k := range m.PredHints {
			v := m.PredHints[k]
			baseI := i
			i = encodeVarintPb(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPb(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Snapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Snapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SinceTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.SinceTs))
		i--
		dAtA[i] = 0x28
	}
	if m.Done {
		i--
		if m.Done {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ReadTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ReadTs))
		i--
		dAtA[i] = 0x18
	}
	if m.Index != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if m.Context != nil {
		{
			size, err := m.Context.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZeroSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.CheckpointTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.CheckpointTs))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RestoreRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestoreRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BackupNum != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.BackupNum))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.VaultFormat) > 0 {
		i -= len(m.VaultFormat)
		copy(dAtA[i:], m.VaultFormat)
		i = encodeVarintPb(dAtA, i, uint64(len(m.VaultFormat)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.VaultField) > 0 {
		i -= len(m.VaultField)
		copy(dAtA[i:], m.VaultField)
		i = encodeVarintPb(dAtA, i, uint64(len(m.VaultField)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.VaultPath) > 0 {
		i -= len(m.VaultPath)
		copy(dAtA[i:], m.VaultPath)
		i = encodeVarintPb(dAtA, i, uint64(len(m.VaultPath)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.VaultSecretidFile) > 0 {
		i -= len(m.VaultSecretidFile)
		copy(dAtA[i:], m.VaultSecretidFile)
		i = encodeVarintPb(dAtA, i, uint64(len(m.VaultSecretidFile)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.VaultRoleidFile) > 0 {
		i -= len(m.VaultRoleidFile)
		copy(dAtA[i:], m.VaultRoleidFile)
		i = encodeVarintPb(dAtA, i, uint64(len(m.VaultRoleidFile)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.VaultAddr) > 0 {
		i -= len(m.VaultAddr)
		copy(dAtA[i:], m.VaultAddr)
		i = encodeVarintPb(dAtA, i, uint64(len(m.VaultAddr)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.EncryptionKeyFile) > 0 {
		i -= len(m.EncryptionKeyFile)
		copy(dAtA[i:], m.EncryptionKeyFile)
		i = encodeVarintPb(dAtA, i, uint64(len(m.EncryptionKeyFile)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Anonymous {
		i--
		if m.Anonymous {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.SessionToken) > 0 {
		i -= len(m.SessionToken)
		copy(dAtA[i:], m.SessionToken)
		i = encodeVarintPb(dAtA, i, uint64(len(m.SessionToken)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SecretKey) > 0 {
		i -= len(m.SecretKey)
		copy(dAtA[i:], m.SecretKey)
		i = encodeVarintPb(dAtA, i, uint64(len(m.SecretKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AccessKey) > 0 {
		i -= len(m.AccessKey)
		copy(dAtA[i:], m.AccessKey)
		i = encodeVarintPb(dAtA, i, uint64(len(m.AccessKey)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BackupId) > 0 {
		i -= len(m.BackupId)
		copy(dAtA[i:], m.BackupId)
		i = encodeVarintPb(dAtA, i, uint64(len(m.BackupId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RestoreTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.RestoreTs))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Proposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CDCIndex != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.CDCIndex))
		i--
		dAtA[i] = 0x68
	}
	if m.Restore != nil {
		{
			size, err := m.Restore.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.ExpectedChecksum != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ExpectedChecksum))
		i--
		dAtA[i] = 0x58
	}
	if m.Index != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x50
	}
	if m.Snapshot != nil {
		{
			size, err := m.Snapshot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Delta != nil {
		{
			size, err := m.Delta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.CleanPredicate) > 0 {
		i -= len(m.CleanPredicate)
		copy(dAtA[i:], m.CleanPredicate)
		i = encodeVarintPb(dAtA, i, uint64(len(m.CleanPredicate)))
		i--
		dAtA[i] = 0x32
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Kv) > 0 {
		for iNdEx := len(m.Kv) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Kv[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Mutations != nil {
		{
			size, err := m.Mutations.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *KVS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Types[iNdEx])
			copy(dAtA[i:], m.Types[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Types[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Predicates) > 0 {
		for iNdEx := len(m.Predicates) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Predicates[iNdEx])
			copy(dAtA[i:], m.Predicates[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Predicates[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Done {
		i--
		if m.Done {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *Posting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Posting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Posting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CommitTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.CommitTs))
		i--
		dAtA[i] = 0x70
	}
	if m.StartTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.StartTs))
		i--
		dAtA[i] = 0x68
	}
	if m.Op != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Facets) > 0 {
		for iNdEx := len(m.Facets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Facets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.LangTag) > 0 {
		i -= len(m.LangTag)
		copy(dAtA[i:], m.LangTag)
		i = encodeVarintPb(dAtA, i, uint64(len(m.LangTag)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PostingType != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.PostingType))
		i--
		dAtA[i] = 0x20
	}
	if m.ValType != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ValType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Uid != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Uid))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *UidBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UidBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UidBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumUids != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.NumUids))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Deltas) > 0 {
		i -= len(m.Deltas)
		copy(dAtA[i:], m.Deltas)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Deltas)))
		i--
		dAtA[i] = 0x12
	}
	if m.Base != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Base))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UidPack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UidPack) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UidPack) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllocRef != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.AllocRef))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.Blocks) > 0 {
		for iNdEx := len(m.Blocks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Blocks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BlockSize != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.BlockSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PostingList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PostingList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PostingList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Splits) > 0 {
		dAtA28 := make([]byte, len(m.Splits)*10)
		var j27 int
		for _, num := range m.Splits {
			for num >= 1<<7 {
				dAtA28[j27] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j27++
			}
			dAtA28[j27] = uint8(num)
			j27++
		}
		i -= j27
		copy(dAtA[i:], dAtA28[:j27])
		i = encodeVarintPb(dAtA, i, uint64(j27))
		i--
		dAtA[i] = 0x22
	}
	if m.CommitTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.CommitTs))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Postings) > 0 {
		for iNdEx := len(m.Postings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Postings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Pack != nil {
		{
			size, err := m.Pack.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FacetParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FacetParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FacetParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Alias) > 0 {
		i -= len(m.Alias)
		copy(dAtA[i:], m.Alias)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Alias)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FacetParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FacetParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FacetParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Param) > 0 {
		for iNdEx := len(m.Param) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Param[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.AllKeys {
		i--
		if m.AllKeys {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Facets) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Facets) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Facets) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Facets) > 0 {
		for iNdEx := len(m.Facets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Facets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FacetsList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FacetsList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FacetsList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FacetsList) > 0 {
		for iNdEx := len(m.FacetsList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FacetsList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Function) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Function) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Function) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Args[iNdEx])
			copy(dAtA[i:], m.Args[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Args[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FilterTree) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterTree) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FilterTree) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Func != nil {
		{
			size, err := m.Func.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Op) > 0 {
		i -= len(m.Op)
		copy(dAtA[i:], m.Op)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Op)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SchemaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Types[iNdEx])
			copy(dAtA[i:], m.Types[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Types[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Predicates) > 0 {
		for iNdEx := len(m.Predicates) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Predicates[iNdEx])
			copy(dAtA[i:], m.Predicates[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Predicates[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.GroupId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SchemaNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NoConflict {
		i--
		if m.NoConflict {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Lang {
		i--
		if m.Lang {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Upsert {
		i--
		if m.Upsert {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.List {
		i--
		if m.List {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Count {
		i--
		if m.Count {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Reverse {
		i--
		if m.Reverse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Tokenizer) > 0 {
		for iNdEx := len(m.Tokenizer) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tokenizer[iNdEx])
			copy(dAtA[i:], m.Tokenizer[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Tokenizer[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Index {
		i--
		if m.Index {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Predicate) > 0 {
		i -= len(m.Predicate)
		copy(dAtA[i:], m.Predicate)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Predicate)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SchemaResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Schema) > 0 {
		for iNdEx := len(m.Schema) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Schema[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SchemaUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NoConflict {
		i--
		if m.NoConflict {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.ObjectTypeName) > 0 {
		i -= len(m.ObjectTypeName)
		copy(dAtA[i:], m.ObjectTypeName)
		i = encodeVarintPb(dAtA, i, uint64(len(m.ObjectTypeName)))
		i--
		dAtA[i] = 0x62
	}
	if m.NonNullableList {
		i--
		if m.NonNullableList {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.NonNullable {
		i--
		if m.NonNullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Lang {
		i--
		if m.Lang {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Upsert {
		i--
		if m.Upsert {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.List {
		i--
		if m.List {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Count {
		i--
		if m.Count {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Tokenizer) > 0 {
		for iNdEx := len(m.Tokenizer) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tokenizer[iNdEx])
			copy(dAtA[i:], m.Tokenizer[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Tokenizer[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Directive != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Directive))
		i--
		dAtA[i] = 0x18
	}
	if m.ValueType != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ValueType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Predicate) > 0 {
		i -= len(m.Predicate)
		copy(dAtA[i:], m.Predicate)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Predicate)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TypeUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypeUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.TypeName) > 0 {
		i -= len(m.TypeName)
		copy(dAtA[i:], m.TypeName)
		i = encodeVarintPb(dAtA, i, uint64(len(m.TypeName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MapHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MapHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MapHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PartitionKeys) > 0 {
		for iNdEx := len(m.PartitionKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionKeys[iNdEx])
			copy(dAtA[i:], m.PartitionKeys[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.PartitionKeys[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MovePredicatePayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MovePredicatePayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MovePredicatePayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpectedChecksum != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ExpectedChecksum))
		i--
		dAtA[i] = 0x28
	}
	if m.TxnTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.TxnTs))
		i--
		dAtA[i] = 0x20
	}
	if m.DestGid != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.DestGid))
		i--
		dAtA[i] = 0x18
	}
	if m.SourceGid != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.SourceGid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Predicate) > 0 {
		i -= len(m.Predicate)
		copy(dAtA[i:], m.Predicate)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Predicate)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxnStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CommitTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.CommitTs))
		i--
		dAtA[i] = 0x10
	}
	if m.StartTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.StartTs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OracleDelta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleDelta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleDelta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GroupChecksums) > 0 {
		for k := range m.GroupChecksums {
			v := m.GroupChecksums[k]
			baseI := i
			i = encodeVarintPb(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintPb(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintPb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.MaxAssigned != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.MaxAssigned))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Txns) > 0 {
		for iNdEx := len(m.Txns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Txns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TxnTimestamps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnTimestamps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnTimestamps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ts) > 0 {
		dAtA32 := make([]byte, len(m.Ts)*10)
		var j31 int
		for _, num := range m.Ts {
			for num >= 1<<7 {
				dAtA32[j31] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j31++
			}
			dAtA32[j31] = uint8(num)
			j31++
		}
		i -= j31
		copy(dAtA[i:], dAtA32[:j31])
		i = encodeVarintPb(dAtA, i, uint64(j31))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PeerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RaftBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Context != nil {
		{
			size, err := m.Context.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubscriptionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Prefixes) > 0 {
		for iNdEx := len(m.Prefixes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Prefixes[iNdEx])
			copy(dAtA[i:], m.Prefixes[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Prefixes[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SubscriptionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kvs != nil {
		{
			size, err := m.Kvs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Num) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Num) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Num) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.Forwarded {
		i--
		if m.Forwarded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ReadOnly {
		i--
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Val != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Val))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AssignedIds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssignedIds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssignedIds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReadOnly != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ReadOnly))
		i--
		dAtA[i] = 0x28
	}
	if m.EndId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.EndId))
		i--
		dAtA[i] = 0x10
	}
	if m.StartId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.StartId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x10
	}
	if m.ClientTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ClientTs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BackupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackupRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Predicates) > 0 {
		for iNdEx := len(m.Predicates) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Predicates[iNdEx])
			copy(dAtA[i:], m.Predicates[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Predicates[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if m.Anonymous {
		i--
		if m.Anonymous {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.SessionToken) > 0 {
		i -= len(m.SessionToken)
		copy(dAtA[i:], m.SessionToken)
		i = encodeVarintPb(dAtA, i, uint64(len(m.SessionToken)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SecretKey) > 0 {
		i -= len(m.SecretKey)
		copy(dAtA[i:], m.SecretKey)
		i = encodeVarintPb(dAtA, i, uint64(len(m.SecretKey)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AccessKey) > 0 {
		i -= len(m.AccessKey)
		copy(dAtA[i:], m.AccessKey)
		i = encodeVarintPb(dAtA, i, uint64(len(m.AccessKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Destination) > 0 {
		i -= len(m.Destination)
		copy(dAtA[i:], m.Destination)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Destination)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.UnixTs) > 0 {
		i -= len(m.UnixTs)
		copy(dAtA[i:], m.UnixTs)
		i = encodeVarintPb(dAtA, i, uint64(len(m.UnixTs)))
		i--
		dAtA[i] = 0x22
	}
	if m.GroupId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x18
	}
	if m.SinceTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.SinceTs))
		i--
		dAtA[i] = 0x10
	}
	if m.ReadTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ReadTs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BackupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackupResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DropOperations) > 0 {
		for iNdEx := len(m.DropOperations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DropOperations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DropOperation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropOperation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropOperation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DropValue) > 0 {
		i -= len(m.DropValue)
		copy(dAtA[i:], m.DropValue)
		i = encodeVarintPb(dAtA, i, uint64(len(m.DropValue)))
		i--
		dAtA[i] = 0x12
	}
	if m.DropOp != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.DropOp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExportRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Anonymous {
		i--
		if m.Anonymous {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.SessionToken) > 0 {
		i -= len(m.SessionToken)
		copy(dAtA[i:], m.SessionToken)
		i = encodeVarintPb(dAtA, i, uint64(len(m.SessionToken)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SecretKey) > 0 {
		i -= len(m.SecretKey)
		copy(dAtA[i:], m.SecretKey)
		i = encodeVarintPb(dAtA, i, uint64(len(m.SecretKey)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AccessKey) > 0 {
		i -= len(m.AccessKey)
		copy(dAtA[i:], m.AccessKey)
		i = encodeVarintPb(dAtA, i, uint64(len(m.AccessKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Destination) > 0 {
		i -= len(m.Destination)
		copy(dAtA[i:], m.Destination)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Destination)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Format) > 0 {
		i -= len(m.Format)
		copy(dAtA[i:], m.Format)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Format)))
		i--
		dAtA[i] = 0x22
	}
	if m.UnixTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.UnixTs))
		i--
		dAtA[i] = 0x18
	}
	if m.ReadTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ReadTs))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExportResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Files) > 0 {
		for iNdEx := len(m.Files) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Files[iNdEx])
			copy(dAtA[i:], m.Files[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Files[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BackupKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackupKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Term) > 0 {
		i -= len(m.Term)
		copy(dAtA[i:], m.Term)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Term)))
		i--
		dAtA[i] = 0x2a
	}
	if m.StartUid != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.StartUid))
		i--
		dAtA[i] = 0x20
	}
	if m.Uid != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Attr) > 0 {
		i -= len(m.Attr)
		copy(dAtA[i:], m.Attr)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Attr)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BackupPostingList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupPostingList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackupPostingList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UidBytes) > 0 {
		i -= len(m.UidBytes)
		copy(dAtA[i:], m.UidBytes)
		i = encodeVarintPb(dAtA, i, uint64(len(m.UidBytes)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Splits) > 0 {
		dAtA37 := make([]byte, len(m.Splits)*10)
		var j36 int
		for _, num := range m.Splits {
			for num >= 1<<7 {
				dAtA37[j36] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j36++
			}
			dAtA37[j36] = uint8(num)
			j36++
		}
		i -= j36
		copy(dAtA[i:], dAtA37[:j36])
		i = encodeVarintPb(dAtA, i, uint64(j36))
		i--
		dAtA[i] = 0x22
	}
	if m.CommitTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.CommitTs))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Postings) > 0 {
		for iNdEx := len(m.Postings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Postings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Uids) > 0 {
		dAtA39 := make([]byte, len(m.Uids)*10)
		var j38 int
		for _, num := range m.Uids {
			for num >= 1<<7 {
				dAtA39[j38] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j38++
			}
			dAtA39[j38] = uint8(num)
			j38++
		}
		i -= j38
		copy(dAtA[i:], dAtA39[:j38])
		i = encodeVarintPb(dAtA, i, uint64(j38))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGraphQLSchemaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGraphQLSchemaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGraphQLSchemaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DgraphTypes) > 0 {
		for iNdEx := len(m.DgraphTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DgraphTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.DgraphPreds) > 0 {
		for iNdEx := len(m.DgraphPreds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DgraphPreds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.GraphqlSchema) > 0 {
		i -= len(m.GraphqlSchema)
		copy(dAtA[i:], m.GraphqlSchema)
		i = encodeVarintPb(dAtA, i, uint64(len(m.GraphqlSchema)))
		i--
		dAtA[i] = 0x12
	}
	if m.StartTs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.StartTs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGraphQLSchemaResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGraphQLSchemaResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGraphQLSchemaResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BulkMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BulkMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BulkMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SchemaMap) > 0 {
		for k := range m.SchemaMap {
			v := m.SchemaMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPb(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPb(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.EdgeCount != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.EdgeCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintPb(dAtA []byte, offset int, v uint64) int {
	offset -= sovPb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Uids) > 0 {
		n += 1 + sovPb(uint64(len(m.Uids)*8)) + len(m.Uids)*8
	}
	return n
}

func (m *TaskValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Val)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.ValType != 0 {
		n += 1 + sovPb(uint64(m.ValType))
	}
	return n
}

func (m *SrcFunction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.IsCount {
		n += 2
	}
	return n
}

func (m *Query) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Attr)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Langs) > 0 {
		for _, s := range m.Langs {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.AfterUid != 0 {
		n += 9
	}
	if m.DoCount {
		n += 2
	}
	if m.UidList != nil {
		l = m.UidList.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.SrcFunc != nil {
		l = m.SrcFunc.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Reverse {
		n += 2
	}
	if m.FacetParam != nil {
		l = m.FacetParam.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.FacetsFilter != nil {
		l = m.FacetsFilter.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.ExpandAll {
		n += 2
	}
	if m.ReadTs != 0 {
		n += 1 + sovPb(uint64(m.ReadTs))
	}
	if m.Cache != 0 {
		n += 1 + sovPb(uint64(m.Cache))
	}
	if m.First != 0 {
		n += 1 + sovPb(uint64(m.First))
	}
	return n
}

func (m *ValueList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *LangList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Lang) > 0 {
		for _, s := range m.Lang {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *Result) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UidMatrix) > 0 {
		for _, e := range m.UidMatrix {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.ValueMatrix) > 0 {
		for _, e := range m.ValueMatrix {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.Counts) > 0 {
		l = 0
		for _, e := range m.Counts {
			l += sovPb(uint64(e))
		}
		n += 1 + sovPb(uint64(l)) + l
	}
	if m.IntersectDest {
		n += 2
	}
	if len(m.FacetMatrix) > 0 {
		for _, e := range m.FacetMatrix {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.LangMatrix) > 0 {
		for _, e := range m.LangMatrix {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.List {
		n += 2
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Attr)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Desc {
		n += 2
	}
	if len(m.Langs) > 0 {
		for _, s := range m.Langs {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *SortMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Order) > 0 {
		for _, e := range m.Order {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.UidMatrix) > 0 {
		for _, e := range m.UidMatrix {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovPb(uint64(m.Count))
	}
	if m.Offset != 0 {
		n += 1 + sovPb(uint64(m.Offset))
	}
	if m.ReadTs != 0 {
		n += 1 + sovPb(uint64(m.ReadTs))
	}
	return n
}

func (m *SortResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UidMatrix) > 0 {
		for _, e := range m.UidMatrix {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *RaftContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 9
	}
	if m.Group != 0 {
		n += 1 + sovPb(uint64(m.Group))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.SnapshotTs != 0 {
		n += 1 + sovPb(uint64(m.SnapshotTs))
	}
	if m.IsLearner {
		n += 2
	}
	return n
}

func (m *Member) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 9
	}
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Leader {
		n += 2
	}
	if m.AmDead {
		n += 2
	}
	if m.LastUpdate != 0 {
		n += 1 + sovPb(uint64(m.LastUpdate))
	}
	if m.Learner {
		n += 2
	}
	if m.ClusterInfoOnly {
		n += 2
	}
	if m.ForceGroupId {
		n += 2
	}
	return n
}

func (m *Group) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Members) > 0 {
		for k, v := range m.Members {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPb(uint64(l))
			}
			mapEntrySize := 1 + sovPb(uint64(k)) + l
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	if len(m.Tablets) > 0 {
		for k, v := range m.Tablets {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPb(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPb(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	if m.SnapshotTs != 0 {
		n += 1 + sovPb(uint64(m.SnapshotTs))
	}
	if m.Checksum != 0 {
		n += 1 + sovPb(uint64(m.Checksum))
	}
	if m.CheckpointTs != 0 {
		n += 1 + sovPb(uint64(m.CheckpointTs))
	}
	return n
}

func (m *License) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.MaxNodes != 0 {
		n += 1 + sovPb(uint64(m.MaxNodes))
	}
	if m.ExpiryTs != 0 {
		n += 1 + sovPb(uint64(m.ExpiryTs))
	}
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *ZeroProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SnapshotTs) > 0 {
		for k, v := range m.SnapshotTs {
			_ = k
			_ = v
			mapEntrySize := 1 + sovPb(uint64(k)) + 1 + sovPb(uint64(v))
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	if m.Member != nil {
		l = m.Member.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Tablet != nil {
		l = m.Tablet.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.MaxUID != 0 {
		n += 1 + sovPb(uint64(m.MaxUID))
	}
	if m.MaxTxnTs != 0 {
		n += 1 + sovPb(uint64(m.MaxTxnTs))
	}
	if m.MaxRaftId != 0 {
		n += 1 + sovPb(uint64(m.MaxRaftId))
	}
	if m.Txn != nil {
		l = m.Txn.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.License != nil {
		l = m.License.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Snapshot != nil {
		l = m.Snapshot.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.MaxNsID != 0 {
		n += 1 + sovPb(uint64(m.MaxNsID))
	}
	return n
}

func (m *MembershipState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Counter != 0 {
		n += 1 + sovPb(uint64(m.Counter))
	}
	if len(m.Groups) > 0 {
		for k, v := range m.Groups {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPb(uint64(l))
			}
			mapEntrySize := 1 + sovPb(uint64(k)) + l
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	if len(m.Zeros) > 0 {
		for k, v := range m.Zeros {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPb(uint64(l))
			}
			mapEntrySize := 1 + sovPb(uint64(k)) + l
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	if m.MaxUID != 0 {
		n += 1 + sovPb(uint64(m.MaxUID))
	}
	if m.MaxTxnTs != 0 {
		n += 1 + sovPb(uint64(m.MaxTxnTs))
	}
	if m.MaxRaftId != 0 {
		n += 1 + sovPb(uint64(m.MaxRaftId))
	}
	if len(m.Removed) > 0 {
		for _, e := range m.Removed {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.License != nil {
		l = m.License.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.MaxNsID != 0 {
		n += 1 + sovPb(uint64(m.MaxNsID))
	}
	return n
}

func (m *ConnectionState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Member != nil {
		l = m.Member.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.MaxPending != 0 {
		n += 1 + sovPb(uint64(m.MaxPending))
	}
	return n
}

func (m *HealthInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Uptime != 0 {
		n += 1 + sovPb(uint64(m.Uptime))
	}
	if m.LastEcho != 0 {
		n += 1 + sovPb(uint64(m.LastEcho))
	}
	if len(m.Ongoing) > 0 {
		for _, s := range m.Ongoing {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.Indexing) > 0 {
		for _, s := range m.Indexing {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.EeFeatures) > 0 {
		for _, s := range m.EeFeatures {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.MaxAssigned != 0 {
		n += 1 + sovPb(uint64(m.MaxAssigned))
	}
	return n
}

func (m *Tablet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	l = len(m.Predicate)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Force {
		n += 2
	}
	if m.OnDiskBytes != 0 {
		n += 1 + sovPb(uint64(m.OnDiskBytes))
	}
	if m.Remove {
		n += 2
	}
	if m.ReadOnly {
		n += 2
	}
	if m.MoveTs != 0 {
		n += 1 + sovPb(uint64(m.MoveTs))
	}
	if m.UncompressedBytes != 0 {
		n += 1 + sovPb(uint64(m.UncompressedBytes))
	}
	return n
}

func (m *DirectedEdge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Entity != 0 {
		n += 9
	}
	l = len(m.Attr)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.ValueType != 0 {
		n += 1 + sovPb(uint64(m.ValueType))
	}
	if m.ValueId != 0 {
		n += 9
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Lang)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovPb(uint64(m.Op))
	}
	if len(m.Facets) > 0 {
		for _, e := range m.Facets {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.AllowedPreds) > 0 {
		for _, s := range m.AllowedPreds {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *Mutations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	if m.StartTs != 0 {
		n += 1 + sovPb(uint64(m.StartTs))
	}
	if len(m.Edges) > 0 {
		for _, e := range m.Edges {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.Schema) > 0 {
		for _, e := range m.Schema {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.DropOp != 0 {
		n += 1 + sovPb(uint64(m.DropOp))
	}
	l = len(m.DropValue)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PredHints) > 0 {
		for k, v := range m.PredHints {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPb(uint64(len(k))) + 1 + sovPb(uint64(v))
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Snapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovPb(uint64(m.Index))
	}
	if m.ReadTs != 0 {
		n += 1 + sovPb(uint64(m.ReadTs))
	}
	if m.Done {
		n += 2
	}
	if m.SinceTs != 0 {
		n += 1 + sovPb(uint64(m.SinceTs))
	}
	return n
}

func (m *ZeroSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovPb(uint64(m.Index))
	}
	if m.CheckpointTs != 0 {
		n += 1 + sovPb(uint64(m.CheckpointTs))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *RestoreRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	if m.RestoreTs != 0 {
		n += 1 + sovPb(uint64(m.RestoreTs))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.BackupId)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.AccessKey)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.SecretKey)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.SessionToken)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Anonymous {
		n += 2
	}
	l = len(m.EncryptionKeyFile)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.VaultAddr)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.VaultRoleidFile)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.VaultSecretidFile)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.VaultPath)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.VaultField)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.VaultFormat)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.BackupNum != 0 {
		n += 2 + sovPb(uint64(m.BackupNum))
	}
	return n
}

func (m *Proposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mutations != nil {
		l = m.Mutations.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Kv) > 0 {
		for _, e := range m.Kv {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.CleanPredicate)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Delta != nil {
		l = m.Delta.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Snapshot != nil {
		l = m.Snapshot.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovPb(uint64(m.Index))
	}
	if m.ExpectedChecksum != 0 {
		n += 1 + sovPb(uint64(m.ExpectedChecksum))
	}
	if m.Restore != nil {
		l = m.Restore.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.CDCIndex != 0 {
		n += 1 + sovPb(uint64(m.CDCIndex))
	}
	return n
}

func (m *KVS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Done {
		n += 2
	}
	if len(m.Predicates) > 0 {
		for _, s := range m.Predicates {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.Types) > 0 {
		for _, s := range m.Types {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *Posting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 9
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.ValType != 0 {
		n += 1 + sovPb(uint64(m.ValType))
	}
	if m.PostingType != 0 {
		n += 1 + sovPb(uint64(m.PostingType))
	}
	l = len(m.LangTag)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Facets) > 0 {
		for _, e := range m.Facets {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.Op != 0 {
		n += 1 + sovPb(uint64(m.Op))
	}
	if m.StartTs != 0 {
		n += 1 + sovPb(uint64(m.StartTs))
	}
	if m.CommitTs != 0 {
		n += 1 + sovPb(uint64(m.CommitTs))
	}
	return n
}

func (m *UidBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != 0 {
		n += 1 + sovPb(uint64(m.Base))
	}
	l = len(m.Deltas)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.NumUids != 0 {
		n += 1 + sovPb(uint64(m.NumUids))
	}
	return n
}

func (m *UidPack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockSize != 0 {
		n += 1 + sovPb(uint64(m.BlockSize))
	}
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.AllocRef != 0 {
		n += 2 + sovPb(uint64(m.AllocRef))
	}
	return n
}

func (m *PostingList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pack != nil {
		l = m.Pack.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Postings) > 0 {
		for _, e := range m.Postings {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.CommitTs != 0 {
		n += 1 + sovPb(uint64(m.CommitTs))
	}
	if len(m.Splits) > 0 {
		l = 0
		for _, e := range m.Splits {
			l += sovPb(uint64(e))
		}
		n += 1 + sovPb(uint64(l)) + l
	}
	return n
}

func (m *FacetParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Alias)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *FacetParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllKeys {
		n += 2
	}
	if len(m.Param) > 0 {
		for _, e := range m.Param {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *Facets) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Facets) > 0 {
		for _, e := range m.Facets {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *FacetsList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FacetsList) > 0 {
		for _, e := range m.FacetsList {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *Function) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *FilterTree) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Op)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.Func != nil {
		l = m.Func.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *SchemaRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	if len(m.Predicates) > 0 {
		for _, s := range m.Predicates {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.Types) > 0 {
		for _, s := range m.Types {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *SchemaNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Predicate)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Index {
		n += 2
	}
	if len(m.Tokenizer) > 0 {
		for _, s := range m.Tokenizer {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.Reverse {
		n += 2
	}
	if m.Count {
		n += 2
	}
	if m.List {
		n += 2
	}
	if m.Upsert {
		n += 2
	}
	if m.Lang {
		n += 2
	}
	if m.NoConflict {
		n += 2
	}
	return n
}

func (m *SchemaResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Schema) > 0 {
		for _, e := range m.Schema {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *SchemaUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Predicate)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.ValueType != 0 {
		n += 1 + sovPb(uint64(m.ValueType))
	}
	if m.Directive != 0 {
		n += 1 + sovPb(uint64(m.Directive))
	}
	if len(m.Tokenizer) > 0 {
		for _, s := range m.Tokenizer {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.Count {
		n += 2
	}
	if m.List {
		n += 2
	}
	if m.Upsert {
		n += 2
	}
	if m.Lang {
		n += 2
	}
	if m.NonNullable {
		n += 2
	}
	if m.NonNullableList {
		n += 2
	}
	l = len(m.ObjectTypeName)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.NoConflict {
		n += 2
	}
	return n
}

func (m *TypeUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TypeName)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *MapHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PartitionKeys) > 0 {
		for _, b := range m.PartitionKeys {
			l = len(b)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *MovePredicatePayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Predicate)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.SourceGid != 0 {
		n += 1 + sovPb(uint64(m.SourceGid))
	}
	if m.DestGid != 0 {
		n += 1 + sovPb(uint64(m.DestGid))
	}
	if m.TxnTs != 0 {
		n += 1 + sovPb(uint64(m.TxnTs))
	}
	if m.ExpectedChecksum != 0 {
		n += 1 + sovPb(uint64(m.ExpectedChecksum))
	}
	return n
}

func (m *TxnStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartTs != 0 {
		n += 1 + sovPb(uint64(m.StartTs))
	}
	if m.CommitTs != 0 {
		n += 1 + sovPb(uint64(m.CommitTs))
	}
	return n
}

func (m *OracleDelta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Txns) > 0 {
		for _, e := range m.Txns {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.MaxAssigned != 0 {
		n += 1 + sovPb(uint64(m.MaxAssigned))
	}
	if len(m.GroupChecksums) > 0 {
		for k, v := range m.GroupChecksums {
			_ = k
			_ = v
			mapEntrySize := 1 + sovPb(uint64(k)) + 1 + sovPb(uint64(v))
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TxnTimestamps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ts) > 0 {
		l = 0
		for _, e := range m.Ts {
			l += sovPb(uint64(e))
		}
		n += 1 + sovPb(uint64(l)) + l
	}
	return n
}

func (m *PeerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *RaftBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *SubscriptionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Prefixes) > 0 {
		for _, b := range m.Prefixes {
			l = len(b)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *SubscriptionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kvs != nil {
		l = m.Kvs.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *Num) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Val != 0 {
		n += 1 + sovPb(uint64(m.Val))
	}
	if m.ReadOnly {
		n += 2
	}
	if m.Forwarded {
		n += 2
	}
	if m.Type != 0 {
		n += 1 + sovPb(uint64(m.Type))
	}
	return n
}

func (m *AssignedIds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartId != 0 {
		n += 1 + sovPb(uint64(m.StartId))
	}
	if m.EndId != 0 {
		n += 1 + sovPb(uint64(m.EndId))
	}
	if m.ReadOnly != 0 {
		n += 1 + sovPb(uint64(m.ReadOnly))
	}
	return n
}

func (m *SnapshotMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientTs != 0 {
		n += 1 + sovPb(uint64(m.ClientTs))
	}
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	return n
}

func (m *Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovPb(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *BackupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReadTs != 0 {
		n += 1 + sovPb(uint64(m.ReadTs))
	}
	if m.SinceTs != 0 {
		n += 1 + sovPb(uint64(m.SinceTs))
	}
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	l = len(m.UnixTs)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.AccessKey)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.SecretKey)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.SessionToken)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Anonymous {
		n += 2
	}
	if len(m.Predicates) > 0 {
		for _, s := range m.Predicates {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *BackupResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DropOperations) > 0 {
		for _, e := range m.DropOperations {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *DropOperation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropOp != 0 {
		n += 1 + sovPb(uint64(m.DropOp))
	}
	l = len(m.DropValue)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *ExportRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovPb(uint64(m.GroupId))
	}
	if m.ReadTs != 0 {
		n += 1 + sovPb(uint64(m.ReadTs))
	}
	if m.UnixTs != 0 {
		n += 1 + sovPb(uint64(m.UnixTs))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.AccessKey)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.SecretKey)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.SessionToken)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Anonymous {
		n += 2
	}
	return n
}

func (m *ExportResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovPb(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Files) > 0 {
		for _, s := range m.Files {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *BackupKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPb(uint64(m.Type))
	}
	l = len(m.Attr)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + sovPb(uint64(m.Uid))
	}
	if m.StartUid != 0 {
		n += 1 + sovPb(uint64(m.StartUid))
	}
	l = len(m.Term)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovPb(uint64(m.Count))
	}
	return n
}

func (m *BackupPostingList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Uids) > 0 {
		l = 0
		for _, e := range m.Uids {
			l += sovPb(uint64(e))
		}
		n += 1 + sovPb(uint64(l)) + l
	}
	if len(m.Postings) > 0 {
		for _, e := range m.Postings {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.CommitTs != 0 {
		n += 1 + sovPb(uint64(m.CommitTs))
	}
	if len(m.Splits) > 0 {
		l = 0
		for _, e := range m.Splits {
			l += sovPb(uint64(e))
		}
		n += 1 + sovPb(uint64(l)) + l
	}
	l = len(m.UidBytes)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *UpdateGraphQLSchemaRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartTs != 0 {
		n += 1 + sovPb(uint64(m.StartTs))
	}
	l = len(m.GraphqlSchema)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.DgraphPreds) > 0 {
		for _, e := range m.DgraphPreds {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.DgraphTypes) > 0 {
		for _, e := range m.DgraphTypes {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *UpdateGraphQLSchemaResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovPb(uint64(m.Uid))
	}
	return n
}

func (m *BulkMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EdgeCount != 0 {
		n += 1 + sovPb(uint64(m.EdgeCount))
	}
	if len(m.SchemaMap) > 0 {
		for k, v := range m.SchemaMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPb(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPb(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	return n
}

func sovPb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPb(x uint64) (n int) {
	return sovPb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.Uids = append(m.Uids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Uids) == 0 {
					m.Uids = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.Uids = append(m.Uids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = append(m.Val[:0], dAtA[iNdEx:postIndex]...)
			if m.Val == nil {
				m.Val = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValType", wireType)
			}
			m.ValType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValType |= Posting_ValType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SrcFunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SrcFunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SrcFunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCount", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCount = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Query) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Query: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Query: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Langs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Langs = append(m.Langs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterUid", wireType)
			}
			m.AfterUid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.AfterUid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoCount", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DoCount = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UidList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UidList == nil {
				m.UidList = &List{}
			}
			if err := m.UidList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcFunc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcFunc == nil {
				m.SrcFunc = &SrcFunction{}
			}
			if err := m.SrcFunc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FacetParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FacetParam == nil {
				m.FacetParam = &FacetParams{}
			}
			if err := m.FacetParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FacetsFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FacetsFilter == nil {
				m.FacetsFilter = &FilterTree{}
			}
			if err := m.FacetsFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpandAll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExpandAll = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTs", wireType)
			}
			m.ReadTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cache", wireType)
			}
			m.Cache = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cache |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field First", wireType)
			}
			m.First = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.First |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValueList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &TaskValue{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LangList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LangList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LangList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lang", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lang = append(m.Lang, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UidMatrix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UidMatrix = append(m.UidMatrix, &List{})
			if err := m.UidMatrix[len(m.UidMatrix)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueMatrix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueMatrix = append(m.ValueMatrix, &ValueList{})
			if err := m.ValueMatrix[len(m.ValueMatrix)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Counts = append(m.Counts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Counts) == 0 {
					m.Counts = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Counts = append(m.Counts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Counts", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntersectDest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IntersectDest = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FacetMatrix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FacetMatrix = append(m.FacetMatrix, &FacetsList{})
			if err := m.FacetMatrix[len(m.FacetMatrix)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangMatrix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangMatrix = append(m.LangMatrix, &LangList{})
			if err := m.LangMatrix[len(m.LangMatrix)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.List = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Desc = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Langs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Langs = append(m.Langs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SortMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SortMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SortMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Order = append(m.Order, &Order{})
			if err := m.Order[len(m.Order)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UidMatrix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UidMatrix = append(m.UidMatrix, &List{})
			if err := m.UidMatrix[len(m.UidMatrix)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTs", wireType)
			}
			m.ReadTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SortResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SortResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SortResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UidMatrix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UidMatrix = append(m.UidMatrix, &List{})
			if err := m.UidMatrix[len(m.UidMatrix)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotTs", wireType)
			}
			m.SnapshotTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapshotTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLearner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLearner = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Leader = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmDead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AmDead = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdate", wireType)
			}
			m.LastUpdate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Learner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Learner = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterInfoOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClusterInfoOnly = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceGroupId", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceGroupId = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Group) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Members == nil {
				m.Members = make(map[uint64]*Member)
			}
			var mapkey uint64
			var mapvalue *Member
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPb
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Member{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Members[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tablets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tablets == nil {
				m.Tablets = make(map[string]*Tablet)
			}
			var mapkey string
			var mapvalue *Tablet
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPb
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPb
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Tablet{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tablets[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotTs", wireType)
			}
			m.SnapshotTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapshotTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckpointTs", wireType)
			}
			m.CheckpointTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheckpointTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *License) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: License: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: License: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNodes", wireType)
			}
			m.MaxNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNodes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryTs", wireType)
			}
			m.ExpiryTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryTs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SnapshotTs == nil {
				m.SnapshotTs = make(map[uint32]uint64)
			}
			var mapkey uint32
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SnapshotTs[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Member == nil {
				m.Member = &Member{}
			}
			if err := m.Member.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tablet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tablet == nil {
				m.Tablet = &Tablet{}
			}
			if err := m.Tablet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUID", wireType)
			}
			m.MaxUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTxnTs", wireType)
			}
			m.MaxTxnTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTxnTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRaftId", wireType)
			}
			m.MaxRaftId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRaftId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Txn == nil {
				m.Txn = &api.TxnContext{}
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field License", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.License == nil {
				m.License = &License{}
			}
			if err := m.License.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Snapshot == nil {
				m.Snapshot = &ZeroSnapshot{}
			}
			if err := m.Snapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNsID", wireType)
			}
			m.MaxNsID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNsID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MembershipState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MembershipState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MembershipState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counter", wireType)
			}
			m.Counter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Counter |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Groups == nil {
				m.Groups = make(map[uint32]*Group)
			}
			var mapkey uint32
			var mapvalue *Group
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPb
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Group{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Groups[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zeros", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Zeros == nil {
				m.Zeros = make(map[uint64]*Member)
			}
			var mapkey uint64
			var mapvalue *Member
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPb
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Member{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Zeros[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUID", wireType)
			}
			m.MaxUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTxnTs", wireType)
			}
			m.MaxTxnTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTxnTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRaftId", wireType)
			}
			m.MaxRaftId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRaftId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Removed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Removed = append(m.Removed, &Member{})
			if err := m.Removed[len(m.Removed)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field License", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.License == nil {
				m.License = &License{}
			}
			if err := m.License.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNsID", wireType)
			}
			m.MaxNsID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNsID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Member == nil {
				m.Member = &Member{}
			}
			if err := m.Member.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &MembershipState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPending", wireType)
			}
			m.MaxPending = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPending |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uptime", wireType)
			}
			m.Uptime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uptime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastEcho", wireType)
			}
			m.LastEcho = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastEcho |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ongoing", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ongoing = append(m.Ongoing, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexing", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Indexing = append(m.Indexing, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EeFeatures", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EeFeatures = append(m.EeFeatures, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAssigned", wireType)
			}
			m.MaxAssigned = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAssigned |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tablet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tablet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tablet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDiskBytes", wireType)
			}
			m.OnDiskBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnDiskBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Remove = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveTs", wireType)
			}
			m.MoveTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncompressedBytes", wireType)
			}
			m.UncompressedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UncompressedBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectedEdge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectedEdge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectedEdge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entity", wireType)
			}
			m.Entity = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Entity = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueType", wireType)
			}
			m.ValueType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValueType |= Posting_ValType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueId", wireType)
			}
			m.ValueId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueId = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lang", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lang = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= DirectedEdge_Op(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Facets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Facets = append(m.Facets, &api.Facet{})
			if err := m.Facets[len(m.Facets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedPreds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedPreds = append(m.AllowedPreds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mutations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mutations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mutations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Edges = append(m.Edges, &DirectedEdge{})
			if err := m.Edges[len(m.Edges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = append(m.Schema, &SchemaUpdate{})
			if err := m.Schema[len(m.Schema)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, &TypeUpdate{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropOp", wireType)
			}
			m.DropOp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropOp |= Mutations_DropOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DropValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredHints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PredHints == nil {
				m.PredHints = make(map[string]Metadata_HintType)
			}
			var mapkey string
			var mapvalue Metadata_HintType
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPb
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= Metadata_HintType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PredHints[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Snapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Snapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &RaftContext{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTs", wireType)
			}
			m.ReadTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Done = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SinceTs", wireType)
			}
			m.SinceTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SinceTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckpointTs", wireType)
			}
			m.CheckpointTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheckpointTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &MembershipState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestoreRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestoreRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestoreTs", wireType)
			}
			m.RestoreTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestoreTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anonymous", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Anonymous = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionKeyFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionKeyFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultRoleidFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultRoleidFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultSecretidFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultSecretidFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultField", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultField = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupNum", wireType)
			}
			m.BackupNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackupNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mutations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mutations == nil {
				m.Mutations = &Mutations{}
			}
			if err := m.Mutations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kv = append(m.Kv, &pb.KV{})
			if err := m.Kv[len(m.Kv)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &MembershipState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CleanPredicate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CleanPredicate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta == nil {
				m.Delta = &OracleDelta{}
			}
			if err := m.Delta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Snapshot == nil {
				m.Snapshot = &Snapshot{}
			}
			if err := m.Snapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedChecksum", wireType)
			}
			m.ExpectedChecksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpectedChecksum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Restore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Restore == nil {
				m.Restore = &RestoreRequest{}
			}
			if err := m.Restore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CDCIndex", wireType)
			}
			m.CDCIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CDCIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Done = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicates", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicates = append(m.Predicates, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Posting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Posting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Posting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValType", wireType)
			}
			m.ValType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValType |= Posting_ValType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostingType", wireType)
			}
			m.PostingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PostingType |= Posting_PostingType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangTag", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangTag = append(m.LangTag[:0], dAtA[iNdEx:postIndex]...)
			if m.LangTag == nil {
				m.LangTag = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Facets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Facets = append(m.Facets, &api.Facet{})
			if err := m.Facets[len(m.Facets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UidBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UidBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UidBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			m.Base = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Base |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deltas", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deltas = append(m.Deltas[:0], dAtA[iNdEx:postIndex]...)
			if m.Deltas == nil {
				m.Deltas = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumUids", wireType)
			}
			m.NumUids = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumUids |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UidPack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UidPack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UidPack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockSize", wireType)
			}
			m.BlockSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &UidBlock{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocRef", wireType)
			}
			m.AllocRef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllocRef |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PostingList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PostingList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PostingList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pack", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pack == nil {
				m.Pack = &UidPack{}
			}
			if err := m.Pack.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Postings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Postings = append(m.Postings, &Posting{})
			if err := m.Postings[len(m.Postings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Splits = append(m.Splits, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Splits) == 0 {
					m.Splits = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Splits = append(m.Splits, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Splits", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FacetParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FacetParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FacetParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alias = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FacetParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FacetParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FacetParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllKeys", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllKeys = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param = append(m.Param, &FacetParam{})
			if err := m.Param[len(m.Param)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Facets) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Facets: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Facets: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Facets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Facets = append(m.Facets, &api.Facet{})
			if err := m.Facets[len(m.Facets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FacetsList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FacetsList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FacetsList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FacetsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FacetsList = append(m.FacetsList, &Facets{})
			if err := m.FacetsList[len(m.FacetsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Function) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Function: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Function: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterTree) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterTree: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterTree: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Op = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &FilterTree{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Func", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Func == nil {
				m.Func = &Function{}
			}
			if err := m.Func.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicates", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicates = append(m.Predicates, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Index = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokenizer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tokenizer = append(m.Tokenizer, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.List = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upsert", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Upsert = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lang", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lang = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoConflict", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoConflict = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = append(m.Schema, &SchemaNode{})
			if err := m.Schema[len(m.Schema)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueType", wireType)
			}
			m.ValueType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValueType |= Posting_ValType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Directive", wireType)
			}
			m.Directive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Directive |= SchemaUpdate_Directive(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokenizer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tokenizer = append(m.Tokenizer, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.List = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upsert", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Upsert = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lang", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lang = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonNullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NonNullable = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonNullableList", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NonNullableList = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectTypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectTypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoConflict", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoConflict = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, &SchemaUpdate{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MapHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionKeys = append(m.PartitionKeys, make([]byte, postIndex-iNdEx))
			copy(m.PartitionKeys[len(m.PartitionKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MovePredicatePayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MovePredicatePayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MovePredicatePayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceGid", wireType)
			}
			m.SourceGid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceGid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestGid", wireType)
			}
			m.DestGid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestGid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnTs", wireType)
			}
			m.TxnTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedChecksum", wireType)
			}
			m.ExpectedChecksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpectedChecksum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleDelta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleDelta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleDelta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txns = append(m.Txns, &TxnStatus{})
			if err := m.Txns[len(m.Txns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAssigned", wireType)
			}
			m.MaxAssigned = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAssigned |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupChecksums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupChecksums == nil {
				m.GroupChecksums = make(map[uint32]uint64)
			}
			var mapkey uint32
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.GroupChecksums[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnTimestamps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnTimestamps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnTimestamps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ts = append(m.Ts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ts) == 0 {
					m.Ts = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ts = append(m.Ts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &RaftContext{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &api.Payload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefixes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefixes = append(m.Prefixes, make([]byte, postIndex-iNdEx))
			copy(m.Prefixes[len(m.Prefixes)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kvs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kvs == nil {
				m.Kvs = &pb.KVList{}
			}
			if err := m.Kvs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Num) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Num: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Num: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			m.Val = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Val |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Forwarded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Forwarded = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NumLeaseType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssignedIds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssignedIds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssignedIds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartId", wireType)
			}
			m.StartId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndId", wireType)
			}
			m.EndId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			m.ReadOnly = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadOnly |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientTs", wireType)
			}
			m.ClientTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTs", wireType)
			}
			m.ReadTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SinceTs", wireType)
			}
			m.SinceTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SinceTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnixTs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnixTs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anonymous", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Anonymous = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicates", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicates = append(m.Predicates, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropOperations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DropOperations = append(m.DropOperations, &DropOperation{})
			if err := m.DropOperations[len(m.DropOperations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropOperation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropOperation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropOperation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropOp", wireType)
			}
			m.DropOp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropOp |= DropOperation_DropOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DropValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTs", wireType)
			}
			m.ReadTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnixTs", wireType)
			}
			m.UnixTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnixTs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anonymous", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Anonymous = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= BackupKey_KeyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartUid", wireType)
			}
			m.StartUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartUid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Term = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupPostingList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupPostingList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupPostingList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uids = append(m.Uids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uids) == 0 {
					m.Uids = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uids = append(m.Uids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uids", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Postings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Postings = append(m.Postings, &Posting{})
			if err := m.Postings[len(m.Postings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Splits = append(m.Splits, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Splits) == 0 {
					m.Splits = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Splits = append(m.Splits, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Splits", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UidBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UidBytes = append(m.UidBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.UidBytes == nil {
				m.UidBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGraphQLSchemaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGraphQLSchemaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGraphQLSchemaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphqlSchema", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GraphqlSchema = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DgraphPreds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DgraphPreds = append(m.DgraphPreds, &SchemaUpdate{})
			if err := m.DgraphPreds[len(m.DgraphPreds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DgraphTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DgraphTypes = append(m.DgraphTypes, &TypeUpdate{})
			if err := m.DgraphTypes[len(m.DgraphTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGraphQLSchemaResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGraphQLSchemaResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGraphQLSchemaResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BulkMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BulkMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BulkMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeCount", wireType)
			}
			m.EdgeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EdgeCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SchemaMap == nil {
				m.SchemaMap = make(map[string]*SchemaUpdate)
			}
			var mapkey string
			var mapvalue *SchemaUpdate
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPb
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPb
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SchemaUpdate{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SchemaMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPb = fmt.Errorf("proto: unexpected end of group")
)
