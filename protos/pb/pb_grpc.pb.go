//
// SPDX-FileCopyrightText: © Hypermode Inc. <hello@hypermode.com>
// SPDX-License-Identifier: Apache-2.0

// Style guide for Protocol Buffer 3.
// Use CamelCase (with an initial capital) for message names – for example,
// SongServerRequest. Use underscore_separated_names for field names – for
// example, song_name.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.12
// source: pb.proto

package pb

import (
	context "context"
	pb "github.com/dgraph-io/badger/v4/pb"
	api "github.com/dgraph-io/dgo/v250/protos/api"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Raft_Heartbeat_FullMethodName   = "/pb.Raft/Heartbeat"
	Raft_RaftMessage_FullMethodName = "/pb.Raft/RaftMessage"
	Raft_JoinCluster_FullMethodName = "/pb.Raft/JoinCluster"
	Raft_IsPeer_FullMethodName      = "/pb.Raft/IsPeer"
)

// RaftClient is the client API for Raft service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RaftClient interface {
	Heartbeat(ctx context.Context, in *api.Payload, opts ...grpc.CallOption) (Raft_HeartbeatClient, error)
	RaftMessage(ctx context.Context, opts ...grpc.CallOption) (Raft_RaftMessageClient, error)
	JoinCluster(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (*api.Payload, error)
	IsPeer(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (*PeerResponse, error)
}

type raftClient struct {
	cc grpc.ClientConnInterface
}

func NewRaftClient(cc grpc.ClientConnInterface) RaftClient {
	return &raftClient{cc}
}

func (c *raftClient) Heartbeat(ctx context.Context, in *api.Payload, opts ...grpc.CallOption) (Raft_HeartbeatClient, error) {
	stream, err := c.cc.NewStream(ctx, &Raft_ServiceDesc.Streams[0], Raft_Heartbeat_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &raftHeartbeatClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Raft_HeartbeatClient interface {
	Recv() (*HealthInfo, error)
	grpc.ClientStream
}

type raftHeartbeatClient struct {
	grpc.ClientStream
}

func (x *raftHeartbeatClient) Recv() (*HealthInfo, error) {
	m := new(HealthInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *raftClient) RaftMessage(ctx context.Context, opts ...grpc.CallOption) (Raft_RaftMessageClient, error) {
	stream, err := c.cc.NewStream(ctx, &Raft_ServiceDesc.Streams[1], Raft_RaftMessage_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &raftRaftMessageClient{stream}
	return x, nil
}

type Raft_RaftMessageClient interface {
	Send(*RaftBatch) error
	CloseAndRecv() (*api.Payload, error)
	grpc.ClientStream
}

type raftRaftMessageClient struct {
	grpc.ClientStream
}

func (x *raftRaftMessageClient) Send(m *RaftBatch) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftRaftMessageClient) CloseAndRecv() (*api.Payload, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(api.Payload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *raftClient) JoinCluster(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (*api.Payload, error) {
	out := new(api.Payload)
	err := c.cc.Invoke(ctx, Raft_JoinCluster_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftClient) IsPeer(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (*PeerResponse, error) {
	out := new(PeerResponse)
	err := c.cc.Invoke(ctx, Raft_IsPeer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RaftServer is the server API for Raft service.
// All implementations must embed UnimplementedRaftServer
// for forward compatibility
type RaftServer interface {
	Heartbeat(*api.Payload, Raft_HeartbeatServer) error
	RaftMessage(Raft_RaftMessageServer) error
	JoinCluster(context.Context, *RaftContext) (*api.Payload, error)
	IsPeer(context.Context, *RaftContext) (*PeerResponse, error)
	mustEmbedUnimplementedRaftServer()
}

// UnimplementedRaftServer must be embedded to have forward compatible implementations.
type UnimplementedRaftServer struct {
}

func (UnimplementedRaftServer) Heartbeat(*api.Payload, Raft_HeartbeatServer) error {
	return status.Errorf(codes.Unimplemented, "method Heartbeat not implemented")
}
func (UnimplementedRaftServer) RaftMessage(Raft_RaftMessageServer) error {
	return status.Errorf(codes.Unimplemented, "method RaftMessage not implemented")
}
func (UnimplementedRaftServer) JoinCluster(context.Context, *RaftContext) (*api.Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinCluster not implemented")
}
func (UnimplementedRaftServer) IsPeer(context.Context, *RaftContext) (*PeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsPeer not implemented")
}
func (UnimplementedRaftServer) mustEmbedUnimplementedRaftServer() {}

// UnsafeRaftServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RaftServer will
// result in compilation errors.
type UnsafeRaftServer interface {
	mustEmbedUnimplementedRaftServer()
}

func RegisterRaftServer(s grpc.ServiceRegistrar, srv RaftServer) {
	s.RegisterService(&Raft_ServiceDesc, srv)
}

func _Raft_Heartbeat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.Payload)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RaftServer).Heartbeat(m, &raftHeartbeatServer{stream})
}

type Raft_HeartbeatServer interface {
	Send(*HealthInfo) error
	grpc.ServerStream
}

type raftHeartbeatServer struct {
	grpc.ServerStream
}

func (x *raftHeartbeatServer) Send(m *HealthInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _Raft_RaftMessage_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftServer).RaftMessage(&raftRaftMessageServer{stream})
}

type Raft_RaftMessageServer interface {
	SendAndClose(*api.Payload) error
	Recv() (*RaftBatch, error)
	grpc.ServerStream
}

type raftRaftMessageServer struct {
	grpc.ServerStream
}

func (x *raftRaftMessageServer) SendAndClose(m *api.Payload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftRaftMessageServer) Recv() (*RaftBatch, error) {
	m := new(RaftBatch)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Raft_JoinCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaftContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServer).JoinCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Raft_JoinCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServer).JoinCluster(ctx, req.(*RaftContext))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raft_IsPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaftContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServer).IsPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Raft_IsPeer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServer).IsPeer(ctx, req.(*RaftContext))
	}
	return interceptor(ctx, in, info, handler)
}

// Raft_ServiceDesc is the grpc.ServiceDesc for Raft service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Raft_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Raft",
	HandlerType: (*RaftServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "JoinCluster",
			Handler:    _Raft_JoinCluster_Handler,
		},
		{
			MethodName: "IsPeer",
			Handler:    _Raft_IsPeer_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Heartbeat",
			Handler:       _Raft_Heartbeat_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RaftMessage",
			Handler:       _Raft_RaftMessage_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "pb.proto",
}

const (
	Zero_Connect_FullMethodName          = "/pb.Zero/Connect"
	Zero_UpdateMembership_FullMethodName = "/pb.Zero/UpdateMembership"
	Zero_StreamMembership_FullMethodName = "/pb.Zero/StreamMembership"
	Zero_Oracle_FullMethodName           = "/pb.Zero/Oracle"
	Zero_ShouldServe_FullMethodName      = "/pb.Zero/ShouldServe"
	Zero_Inform_FullMethodName           = "/pb.Zero/Inform"
	Zero_AssignIds_FullMethodName        = "/pb.Zero/AssignIds"
	Zero_Timestamps_FullMethodName       = "/pb.Zero/Timestamps"
	Zero_CommitOrAbort_FullMethodName    = "/pb.Zero/CommitOrAbort"
	Zero_TryAbort_FullMethodName         = "/pb.Zero/TryAbort"
	Zero_DeleteNamespace_FullMethodName  = "/pb.Zero/DeleteNamespace"
	Zero_RemoveNode_FullMethodName       = "/pb.Zero/RemoveNode"
	Zero_MoveTablet_FullMethodName       = "/pb.Zero/MoveTablet"
)

// ZeroClient is the client API for Zero service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ZeroClient interface {
	// These 3 endpoints are for handling membership.
	Connect(ctx context.Context, in *Member, opts ...grpc.CallOption) (*ConnectionState, error)
	UpdateMembership(ctx context.Context, in *Group, opts ...grpc.CallOption) (*api.Payload, error)
	StreamMembership(ctx context.Context, in *api.Payload, opts ...grpc.CallOption) (Zero_StreamMembershipClient, error)
	Oracle(ctx context.Context, in *api.Payload, opts ...grpc.CallOption) (Zero_OracleClient, error)
	ShouldServe(ctx context.Context, in *Tablet, opts ...grpc.CallOption) (*Tablet, error)
	Inform(ctx context.Context, in *TabletRequest, opts ...grpc.CallOption) (*TabletResponse, error)
	AssignIds(ctx context.Context, in *Num, opts ...grpc.CallOption) (*AssignedIds, error)
	Timestamps(ctx context.Context, in *Num, opts ...grpc.CallOption) (*AssignedIds, error)
	CommitOrAbort(ctx context.Context, in *api.TxnContext, opts ...grpc.CallOption) (*api.TxnContext, error)
	TryAbort(ctx context.Context, in *TxnTimestamps, opts ...grpc.CallOption) (*OracleDelta, error)
	DeleteNamespace(ctx context.Context, in *DeleteNsRequest, opts ...grpc.CallOption) (*Status, error)
	RemoveNode(ctx context.Context, in *RemoveNodeRequest, opts ...grpc.CallOption) (*Status, error)
	MoveTablet(ctx context.Context, in *MoveTabletRequest, opts ...grpc.CallOption) (*Status, error)
}

type zeroClient struct {
	cc grpc.ClientConnInterface
}

func NewZeroClient(cc grpc.ClientConnInterface) ZeroClient {
	return &zeroClient{cc}
}

func (c *zeroClient) Connect(ctx context.Context, in *Member, opts ...grpc.CallOption) (*ConnectionState, error) {
	out := new(ConnectionState)
	err := c.cc.Invoke(ctx, Zero_Connect_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) UpdateMembership(ctx context.Context, in *Group, opts ...grpc.CallOption) (*api.Payload, error) {
	out := new(api.Payload)
	err := c.cc.Invoke(ctx, Zero_UpdateMembership_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) StreamMembership(ctx context.Context, in *api.Payload, opts ...grpc.CallOption) (Zero_StreamMembershipClient, error) {
	stream, err := c.cc.NewStream(ctx, &Zero_ServiceDesc.Streams[0], Zero_StreamMembership_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &zeroStreamMembershipClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Zero_StreamMembershipClient interface {
	Recv() (*MembershipState, error)
	grpc.ClientStream
}

type zeroStreamMembershipClient struct {
	grpc.ClientStream
}

func (x *zeroStreamMembershipClient) Recv() (*MembershipState, error) {
	m := new(MembershipState)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *zeroClient) Oracle(ctx context.Context, in *api.Payload, opts ...grpc.CallOption) (Zero_OracleClient, error) {
	stream, err := c.cc.NewStream(ctx, &Zero_ServiceDesc.Streams[1], Zero_Oracle_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &zeroOracleClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Zero_OracleClient interface {
	Recv() (*OracleDelta, error)
	grpc.ClientStream
}

type zeroOracleClient struct {
	grpc.ClientStream
}

func (x *zeroOracleClient) Recv() (*OracleDelta, error) {
	m := new(OracleDelta)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *zeroClient) ShouldServe(ctx context.Context, in *Tablet, opts ...grpc.CallOption) (*Tablet, error) {
	out := new(Tablet)
	err := c.cc.Invoke(ctx, Zero_ShouldServe_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) Inform(ctx context.Context, in *TabletRequest, opts ...grpc.CallOption) (*TabletResponse, error) {
	out := new(TabletResponse)
	err := c.cc.Invoke(ctx, Zero_Inform_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) AssignIds(ctx context.Context, in *Num, opts ...grpc.CallOption) (*AssignedIds, error) {
	out := new(AssignedIds)
	err := c.cc.Invoke(ctx, Zero_AssignIds_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) Timestamps(ctx context.Context, in *Num, opts ...grpc.CallOption) (*AssignedIds, error) {
	out := new(AssignedIds)
	err := c.cc.Invoke(ctx, Zero_Timestamps_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) CommitOrAbort(ctx context.Context, in *api.TxnContext, opts ...grpc.CallOption) (*api.TxnContext, error) {
	out := new(api.TxnContext)
	err := c.cc.Invoke(ctx, Zero_CommitOrAbort_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) TryAbort(ctx context.Context, in *TxnTimestamps, opts ...grpc.CallOption) (*OracleDelta, error) {
	out := new(OracleDelta)
	err := c.cc.Invoke(ctx, Zero_TryAbort_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) DeleteNamespace(ctx context.Context, in *DeleteNsRequest, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, Zero_DeleteNamespace_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) RemoveNode(ctx context.Context, in *RemoveNodeRequest, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, Zero_RemoveNode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) MoveTablet(ctx context.Context, in *MoveTabletRequest, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, Zero_MoveTablet_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ZeroServer is the server API for Zero service.
// All implementations must embed UnimplementedZeroServer
// for forward compatibility
type ZeroServer interface {
	// These 3 endpoints are for handling membership.
	Connect(context.Context, *Member) (*ConnectionState, error)
	UpdateMembership(context.Context, *Group) (*api.Payload, error)
	StreamMembership(*api.Payload, Zero_StreamMembershipServer) error
	Oracle(*api.Payload, Zero_OracleServer) error
	ShouldServe(context.Context, *Tablet) (*Tablet, error)
	Inform(context.Context, *TabletRequest) (*TabletResponse, error)
	AssignIds(context.Context, *Num) (*AssignedIds, error)
	Timestamps(context.Context, *Num) (*AssignedIds, error)
	CommitOrAbort(context.Context, *api.TxnContext) (*api.TxnContext, error)
	TryAbort(context.Context, *TxnTimestamps) (*OracleDelta, error)
	DeleteNamespace(context.Context, *DeleteNsRequest) (*Status, error)
	RemoveNode(context.Context, *RemoveNodeRequest) (*Status, error)
	MoveTablet(context.Context, *MoveTabletRequest) (*Status, error)
	mustEmbedUnimplementedZeroServer()
}

// UnimplementedZeroServer must be embedded to have forward compatible implementations.
type UnimplementedZeroServer struct {
}

func (UnimplementedZeroServer) Connect(context.Context, *Member) (*ConnectionState, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedZeroServer) UpdateMembership(context.Context, *Group) (*api.Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMembership not implemented")
}
func (UnimplementedZeroServer) StreamMembership(*api.Payload, Zero_StreamMembershipServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamMembership not implemented")
}
func (UnimplementedZeroServer) Oracle(*api.Payload, Zero_OracleServer) error {
	return status.Errorf(codes.Unimplemented, "method Oracle not implemented")
}
func (UnimplementedZeroServer) ShouldServe(context.Context, *Tablet) (*Tablet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShouldServe not implemented")
}
func (UnimplementedZeroServer) Inform(context.Context, *TabletRequest) (*TabletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Inform not implemented")
}
func (UnimplementedZeroServer) AssignIds(context.Context, *Num) (*AssignedIds, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssignIds not implemented")
}
func (UnimplementedZeroServer) Timestamps(context.Context, *Num) (*AssignedIds, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Timestamps not implemented")
}
func (UnimplementedZeroServer) CommitOrAbort(context.Context, *api.TxnContext) (*api.TxnContext, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitOrAbort not implemented")
}
func (UnimplementedZeroServer) TryAbort(context.Context, *TxnTimestamps) (*OracleDelta, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TryAbort not implemented")
}
func (UnimplementedZeroServer) DeleteNamespace(context.Context, *DeleteNsRequest) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNamespace not implemented")
}
func (UnimplementedZeroServer) RemoveNode(context.Context, *RemoveNodeRequest) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveNode not implemented")
}
func (UnimplementedZeroServer) MoveTablet(context.Context, *MoveTabletRequest) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MoveTablet not implemented")
}
func (UnimplementedZeroServer) mustEmbedUnimplementedZeroServer() {}

// UnsafeZeroServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ZeroServer will
// result in compilation errors.
type UnsafeZeroServer interface {
	mustEmbedUnimplementedZeroServer()
}

func RegisterZeroServer(s grpc.ServiceRegistrar, srv ZeroServer) {
	s.RegisterService(&Zero_ServiceDesc, srv)
}

func _Zero_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Member)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Zero_Connect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).Connect(ctx, req.(*Member))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_UpdateMembership_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Group)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).UpdateMembership(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Zero_UpdateMembership_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).UpdateMembership(ctx, req.(*Group))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_StreamMembership_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.Payload)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ZeroServer).StreamMembership(m, &zeroStreamMembershipServer{stream})
}

type Zero_StreamMembershipServer interface {
	Send(*MembershipState) error
	grpc.ServerStream
}

type zeroStreamMembershipServer struct {
	grpc.ServerStream
}

func (x *zeroStreamMembershipServer) Send(m *MembershipState) error {
	return x.ServerStream.SendMsg(m)
}

func _Zero_Oracle_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.Payload)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ZeroServer).Oracle(m, &zeroOracleServer{stream})
}

type Zero_OracleServer interface {
	Send(*OracleDelta) error
	grpc.ServerStream
}

type zeroOracleServer struct {
	grpc.ServerStream
}

func (x *zeroOracleServer) Send(m *OracleDelta) error {
	return x.ServerStream.SendMsg(m)
}

func _Zero_ShouldServe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Tablet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).ShouldServe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Zero_ShouldServe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).ShouldServe(ctx, req.(*Tablet))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_Inform_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TabletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).Inform(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Zero_Inform_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).Inform(ctx, req.(*TabletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_AssignIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Num)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).AssignIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Zero_AssignIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).AssignIds(ctx, req.(*Num))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_Timestamps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Num)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).Timestamps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Zero_Timestamps_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).Timestamps(ctx, req.(*Num))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_CommitOrAbort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.TxnContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).CommitOrAbort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Zero_CommitOrAbort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).CommitOrAbort(ctx, req.(*api.TxnContext))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_TryAbort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxnTimestamps)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).TryAbort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Zero_TryAbort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).TryAbort(ctx, req.(*TxnTimestamps))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_DeleteNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).DeleteNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Zero_DeleteNamespace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).DeleteNamespace(ctx, req.(*DeleteNsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_RemoveNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).RemoveNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Zero_RemoveNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).RemoveNode(ctx, req.(*RemoveNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_MoveTablet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveTabletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).MoveTablet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Zero_MoveTablet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).MoveTablet(ctx, req.(*MoveTabletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Zero_ServiceDesc is the grpc.ServiceDesc for Zero service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Zero_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Zero",
	HandlerType: (*ZeroServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Connect",
			Handler:    _Zero_Connect_Handler,
		},
		{
			MethodName: "UpdateMembership",
			Handler:    _Zero_UpdateMembership_Handler,
		},
		{
			MethodName: "ShouldServe",
			Handler:    _Zero_ShouldServe_Handler,
		},
		{
			MethodName: "Inform",
			Handler:    _Zero_Inform_Handler,
		},
		{
			MethodName: "AssignIds",
			Handler:    _Zero_AssignIds_Handler,
		},
		{
			MethodName: "Timestamps",
			Handler:    _Zero_Timestamps_Handler,
		},
		{
			MethodName: "CommitOrAbort",
			Handler:    _Zero_CommitOrAbort_Handler,
		},
		{
			MethodName: "TryAbort",
			Handler:    _Zero_TryAbort_Handler,
		},
		{
			MethodName: "DeleteNamespace",
			Handler:    _Zero_DeleteNamespace_Handler,
		},
		{
			MethodName: "RemoveNode",
			Handler:    _Zero_RemoveNode_Handler,
		},
		{
			MethodName: "MoveTablet",
			Handler:    _Zero_MoveTablet_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamMembership",
			Handler:       _Zero_StreamMembership_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Oracle",
			Handler:       _Zero_Oracle_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pb.proto",
}

const (
	Worker_Mutate_FullMethodName                          = "/pb.Worker/Mutate"
	Worker_ServeTask_FullMethodName                       = "/pb.Worker/ServeTask"
	Worker_StreamSnapshot_FullMethodName                  = "/pb.Worker/StreamSnapshot"
	Worker_Sort_FullMethodName                            = "/pb.Worker/Sort"
	Worker_Schema_FullMethodName                          = "/pb.Worker/Schema"
	Worker_Backup_FullMethodName                          = "/pb.Worker/Backup"
	Worker_Restore_FullMethodName                         = "/pb.Worker/Restore"
	Worker_Export_FullMethodName                          = "/pb.Worker/Export"
	Worker_ReceivePredicate_FullMethodName                = "/pb.Worker/ReceivePredicate"
	Worker_MovePredicate_FullMethodName                   = "/pb.Worker/MovePredicate"
	Worker_Subscribe_FullMethodName                       = "/pb.Worker/Subscribe"
	Worker_UpdateGraphQLSchema_FullMethodName             = "/pb.Worker/UpdateGraphQLSchema"
	Worker_DeleteNamespace_FullMethodName                 = "/pb.Worker/DeleteNamespace"
	Worker_TaskStatus_FullMethodName                      = "/pb.Worker/TaskStatus"
	Worker_UpdateExtSnapshotStreamingState_FullMethodName = "/pb.Worker/UpdateExtSnapshotStreamingState"
	Worker_StreamExtSnapshot_FullMethodName               = "/pb.Worker/StreamExtSnapshot"
)

// WorkerClient is the client API for Worker service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WorkerClient interface {
	// Data serving RPCs.
	Mutate(ctx context.Context, in *Mutations, opts ...grpc.CallOption) (*api.TxnContext, error)
	ServeTask(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Result, error)
	StreamSnapshot(ctx context.Context, opts ...grpc.CallOption) (Worker_StreamSnapshotClient, error)
	Sort(ctx context.Context, in *SortMessage, opts ...grpc.CallOption) (*SortResult, error)
	Schema(ctx context.Context, in *SchemaRequest, opts ...grpc.CallOption) (*SchemaResult, error)
	Backup(ctx context.Context, in *BackupRequest, opts ...grpc.CallOption) (*BackupResponse, error)
	Restore(ctx context.Context, in *RestoreRequest, opts ...grpc.CallOption) (*Status, error)
	Export(ctx context.Context, in *ExportRequest, opts ...grpc.CallOption) (*ExportResponse, error)
	ReceivePredicate(ctx context.Context, opts ...grpc.CallOption) (Worker_ReceivePredicateClient, error)
	MovePredicate(ctx context.Context, in *MovePredicatePayload, opts ...grpc.CallOption) (*api.Payload, error)
	Subscribe(ctx context.Context, in *SubscriptionRequest, opts ...grpc.CallOption) (Worker_SubscribeClient, error)
	UpdateGraphQLSchema(ctx context.Context, in *UpdateGraphQLSchemaRequest, opts ...grpc.CallOption) (*UpdateGraphQLSchemaResponse, error)
	DeleteNamespace(ctx context.Context, in *DeleteNsRequest, opts ...grpc.CallOption) (*Status, error)
	TaskStatus(ctx context.Context, in *TaskStatusRequest, opts ...grpc.CallOption) (*TaskStatusResponse, error)
	UpdateExtSnapshotStreamingState(ctx context.Context, in *api.UpdateExtSnapshotStreamingStateRequest, opts ...grpc.CallOption) (*Status, error)
	StreamExtSnapshot(ctx context.Context, opts ...grpc.CallOption) (Worker_StreamExtSnapshotClient, error)
}

type workerClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkerClient(cc grpc.ClientConnInterface) WorkerClient {
	return &workerClient{cc}
}

func (c *workerClient) Mutate(ctx context.Context, in *Mutations, opts ...grpc.CallOption) (*api.TxnContext, error) {
	out := new(api.TxnContext)
	err := c.cc.Invoke(ctx, Worker_Mutate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) ServeTask(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, Worker_ServeTask_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) StreamSnapshot(ctx context.Context, opts ...grpc.CallOption) (Worker_StreamSnapshotClient, error) {
	stream, err := c.cc.NewStream(ctx, &Worker_ServiceDesc.Streams[0], Worker_StreamSnapshot_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &workerStreamSnapshotClient{stream}
	return x, nil
}

type Worker_StreamSnapshotClient interface {
	Send(*Snapshot) error
	Recv() (*KVS, error)
	grpc.ClientStream
}

type workerStreamSnapshotClient struct {
	grpc.ClientStream
}

func (x *workerStreamSnapshotClient) Send(m *Snapshot) error {
	return x.ClientStream.SendMsg(m)
}

func (x *workerStreamSnapshotClient) Recv() (*KVS, error) {
	m := new(KVS)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workerClient) Sort(ctx context.Context, in *SortMessage, opts ...grpc.CallOption) (*SortResult, error) {
	out := new(SortResult)
	err := c.cc.Invoke(ctx, Worker_Sort_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) Schema(ctx context.Context, in *SchemaRequest, opts ...grpc.CallOption) (*SchemaResult, error) {
	out := new(SchemaResult)
	err := c.cc.Invoke(ctx, Worker_Schema_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) Backup(ctx context.Context, in *BackupRequest, opts ...grpc.CallOption) (*BackupResponse, error) {
	out := new(BackupResponse)
	err := c.cc.Invoke(ctx, Worker_Backup_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) Restore(ctx context.Context, in *RestoreRequest, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, Worker_Restore_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) Export(ctx context.Context, in *ExportRequest, opts ...grpc.CallOption) (*ExportResponse, error) {
	out := new(ExportResponse)
	err := c.cc.Invoke(ctx, Worker_Export_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) ReceivePredicate(ctx context.Context, opts ...grpc.CallOption) (Worker_ReceivePredicateClient, error) {
	stream, err := c.cc.NewStream(ctx, &Worker_ServiceDesc.Streams[1], Worker_ReceivePredicate_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &workerReceivePredicateClient{stream}
	return x, nil
}

type Worker_ReceivePredicateClient interface {
	Send(*KVS) error
	CloseAndRecv() (*api.Payload, error)
	grpc.ClientStream
}

type workerReceivePredicateClient struct {
	grpc.ClientStream
}

func (x *workerReceivePredicateClient) Send(m *KVS) error {
	return x.ClientStream.SendMsg(m)
}

func (x *workerReceivePredicateClient) CloseAndRecv() (*api.Payload, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(api.Payload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workerClient) MovePredicate(ctx context.Context, in *MovePredicatePayload, opts ...grpc.CallOption) (*api.Payload, error) {
	out := new(api.Payload)
	err := c.cc.Invoke(ctx, Worker_MovePredicate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) Subscribe(ctx context.Context, in *SubscriptionRequest, opts ...grpc.CallOption) (Worker_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &Worker_ServiceDesc.Streams[2], Worker_Subscribe_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &workerSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Worker_SubscribeClient interface {
	Recv() (*pb.KVList, error)
	grpc.ClientStream
}

type workerSubscribeClient struct {
	grpc.ClientStream
}

func (x *workerSubscribeClient) Recv() (*pb.KVList, error) {
	m := new(pb.KVList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workerClient) UpdateGraphQLSchema(ctx context.Context, in *UpdateGraphQLSchemaRequest, opts ...grpc.CallOption) (*UpdateGraphQLSchemaResponse, error) {
	out := new(UpdateGraphQLSchemaResponse)
	err := c.cc.Invoke(ctx, Worker_UpdateGraphQLSchema_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) DeleteNamespace(ctx context.Context, in *DeleteNsRequest, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, Worker_DeleteNamespace_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) TaskStatus(ctx context.Context, in *TaskStatusRequest, opts ...grpc.CallOption) (*TaskStatusResponse, error) {
	out := new(TaskStatusResponse)
	err := c.cc.Invoke(ctx, Worker_TaskStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) UpdateExtSnapshotStreamingState(ctx context.Context, in *api.UpdateExtSnapshotStreamingStateRequest, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, Worker_UpdateExtSnapshotStreamingState_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) StreamExtSnapshot(ctx context.Context, opts ...grpc.CallOption) (Worker_StreamExtSnapshotClient, error) {
	stream, err := c.cc.NewStream(ctx, &Worker_ServiceDesc.Streams[3], Worker_StreamExtSnapshot_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &workerStreamExtSnapshotClient{stream}
	return x, nil
}

type Worker_StreamExtSnapshotClient interface {
	Send(*api.StreamExtSnapshotRequest) error
	Recv() (*api.StreamExtSnapshotResponse, error)
	grpc.ClientStream
}

type workerStreamExtSnapshotClient struct {
	grpc.ClientStream
}

func (x *workerStreamExtSnapshotClient) Send(m *api.StreamExtSnapshotRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *workerStreamExtSnapshotClient) Recv() (*api.StreamExtSnapshotResponse, error) {
	m := new(api.StreamExtSnapshotResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// WorkerServer is the server API for Worker service.
// All implementations must embed UnimplementedWorkerServer
// for forward compatibility
type WorkerServer interface {
	// Data serving RPCs.
	Mutate(context.Context, *Mutations) (*api.TxnContext, error)
	ServeTask(context.Context, *Query) (*Result, error)
	StreamSnapshot(Worker_StreamSnapshotServer) error
	Sort(context.Context, *SortMessage) (*SortResult, error)
	Schema(context.Context, *SchemaRequest) (*SchemaResult, error)
	Backup(context.Context, *BackupRequest) (*BackupResponse, error)
	Restore(context.Context, *RestoreRequest) (*Status, error)
	Export(context.Context, *ExportRequest) (*ExportResponse, error)
	ReceivePredicate(Worker_ReceivePredicateServer) error
	MovePredicate(context.Context, *MovePredicatePayload) (*api.Payload, error)
	Subscribe(*SubscriptionRequest, Worker_SubscribeServer) error
	UpdateGraphQLSchema(context.Context, *UpdateGraphQLSchemaRequest) (*UpdateGraphQLSchemaResponse, error)
	DeleteNamespace(context.Context, *DeleteNsRequest) (*Status, error)
	TaskStatus(context.Context, *TaskStatusRequest) (*TaskStatusResponse, error)
	UpdateExtSnapshotStreamingState(context.Context, *api.UpdateExtSnapshotStreamingStateRequest) (*Status, error)
	StreamExtSnapshot(Worker_StreamExtSnapshotServer) error
	mustEmbedUnimplementedWorkerServer()
}

// UnimplementedWorkerServer must be embedded to have forward compatible implementations.
type UnimplementedWorkerServer struct {
}

func (UnimplementedWorkerServer) Mutate(context.Context, *Mutations) (*api.TxnContext, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Mutate not implemented")
}
func (UnimplementedWorkerServer) ServeTask(context.Context, *Query) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServeTask not implemented")
}
func (UnimplementedWorkerServer) StreamSnapshot(Worker_StreamSnapshotServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamSnapshot not implemented")
}
func (UnimplementedWorkerServer) Sort(context.Context, *SortMessage) (*SortResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sort not implemented")
}
func (UnimplementedWorkerServer) Schema(context.Context, *SchemaRequest) (*SchemaResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Schema not implemented")
}
func (UnimplementedWorkerServer) Backup(context.Context, *BackupRequest) (*BackupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Backup not implemented")
}
func (UnimplementedWorkerServer) Restore(context.Context, *RestoreRequest) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Restore not implemented")
}
func (UnimplementedWorkerServer) Export(context.Context, *ExportRequest) (*ExportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Export not implemented")
}
func (UnimplementedWorkerServer) ReceivePredicate(Worker_ReceivePredicateServer) error {
	return status.Errorf(codes.Unimplemented, "method ReceivePredicate not implemented")
}
func (UnimplementedWorkerServer) MovePredicate(context.Context, *MovePredicatePayload) (*api.Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MovePredicate not implemented")
}
func (UnimplementedWorkerServer) Subscribe(*SubscriptionRequest, Worker_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedWorkerServer) UpdateGraphQLSchema(context.Context, *UpdateGraphQLSchemaRequest) (*UpdateGraphQLSchemaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGraphQLSchema not implemented")
}
func (UnimplementedWorkerServer) DeleteNamespace(context.Context, *DeleteNsRequest) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNamespace not implemented")
}
func (UnimplementedWorkerServer) TaskStatus(context.Context, *TaskStatusRequest) (*TaskStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaskStatus not implemented")
}
func (UnimplementedWorkerServer) UpdateExtSnapshotStreamingState(context.Context, *api.UpdateExtSnapshotStreamingStateRequest) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateExtSnapshotStreamingState not implemented")
}
func (UnimplementedWorkerServer) StreamExtSnapshot(Worker_StreamExtSnapshotServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamExtSnapshot not implemented")
}
func (UnimplementedWorkerServer) mustEmbedUnimplementedWorkerServer() {}

// UnsafeWorkerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkerServer will
// result in compilation errors.
type UnsafeWorkerServer interface {
	mustEmbedUnimplementedWorkerServer()
}

func RegisterWorkerServer(s grpc.ServiceRegistrar, srv WorkerServer) {
	s.RegisterService(&Worker_ServiceDesc, srv)
}

func _Worker_Mutate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Mutations)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Mutate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Worker_Mutate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Mutate(ctx, req.(*Mutations))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_ServeTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).ServeTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Worker_ServeTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).ServeTask(ctx, req.(*Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_StreamSnapshot_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WorkerServer).StreamSnapshot(&workerStreamSnapshotServer{stream})
}

type Worker_StreamSnapshotServer interface {
	Send(*KVS) error
	Recv() (*Snapshot, error)
	grpc.ServerStream
}

type workerStreamSnapshotServer struct {
	grpc.ServerStream
}

func (x *workerStreamSnapshotServer) Send(m *KVS) error {
	return x.ServerStream.SendMsg(m)
}

func (x *workerStreamSnapshotServer) Recv() (*Snapshot, error) {
	m := new(Snapshot)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Worker_Sort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SortMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Sort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Worker_Sort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Sort(ctx, req.(*SortMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_Schema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Schema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Worker_Schema_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Schema(ctx, req.(*SchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_Backup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BackupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Backup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Worker_Backup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Backup(ctx, req.(*BackupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_Restore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Restore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Worker_Restore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Restore(ctx, req.(*RestoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_Export_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Export(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Worker_Export_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Export(ctx, req.(*ExportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_ReceivePredicate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WorkerServer).ReceivePredicate(&workerReceivePredicateServer{stream})
}

type Worker_ReceivePredicateServer interface {
	SendAndClose(*api.Payload) error
	Recv() (*KVS, error)
	grpc.ServerStream
}

type workerReceivePredicateServer struct {
	grpc.ServerStream
}

func (x *workerReceivePredicateServer) SendAndClose(m *api.Payload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *workerReceivePredicateServer) Recv() (*KVS, error) {
	m := new(KVS)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Worker_MovePredicate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MovePredicatePayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).MovePredicate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Worker_MovePredicate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).MovePredicate(ctx, req.(*MovePredicatePayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscriptionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WorkerServer).Subscribe(m, &workerSubscribeServer{stream})
}

type Worker_SubscribeServer interface {
	Send(*pb.KVList) error
	grpc.ServerStream
}

type workerSubscribeServer struct {
	grpc.ServerStream
}

func (x *workerSubscribeServer) Send(m *pb.KVList) error {
	return x.ServerStream.SendMsg(m)
}

func _Worker_UpdateGraphQLSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGraphQLSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).UpdateGraphQLSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Worker_UpdateGraphQLSchema_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).UpdateGraphQLSchema(ctx, req.(*UpdateGraphQLSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_DeleteNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).DeleteNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Worker_DeleteNamespace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).DeleteNamespace(ctx, req.(*DeleteNsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_TaskStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).TaskStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Worker_TaskStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).TaskStatus(ctx, req.(*TaskStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_UpdateExtSnapshotStreamingState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.UpdateExtSnapshotStreamingStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).UpdateExtSnapshotStreamingState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Worker_UpdateExtSnapshotStreamingState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).UpdateExtSnapshotStreamingState(ctx, req.(*api.UpdateExtSnapshotStreamingStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_StreamExtSnapshot_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WorkerServer).StreamExtSnapshot(&workerStreamExtSnapshotServer{stream})
}

type Worker_StreamExtSnapshotServer interface {
	Send(*api.StreamExtSnapshotResponse) error
	Recv() (*api.StreamExtSnapshotRequest, error)
	grpc.ServerStream
}

type workerStreamExtSnapshotServer struct {
	grpc.ServerStream
}

func (x *workerStreamExtSnapshotServer) Send(m *api.StreamExtSnapshotResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *workerStreamExtSnapshotServer) Recv() (*api.StreamExtSnapshotRequest, error) {
	m := new(api.StreamExtSnapshotRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Worker_ServiceDesc is the grpc.ServiceDesc for Worker service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Worker_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Worker",
	HandlerType: (*WorkerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Mutate",
			Handler:    _Worker_Mutate_Handler,
		},
		{
			MethodName: "ServeTask",
			Handler:    _Worker_ServeTask_Handler,
		},
		{
			MethodName: "Sort",
			Handler:    _Worker_Sort_Handler,
		},
		{
			MethodName: "Schema",
			Handler:    _Worker_Schema_Handler,
		},
		{
			MethodName: "Backup",
			Handler:    _Worker_Backup_Handler,
		},
		{
			MethodName: "Restore",
			Handler:    _Worker_Restore_Handler,
		},
		{
			MethodName: "Export",
			Handler:    _Worker_Export_Handler,
		},
		{
			MethodName: "MovePredicate",
			Handler:    _Worker_MovePredicate_Handler,
		},
		{
			MethodName: "UpdateGraphQLSchema",
			Handler:    _Worker_UpdateGraphQLSchema_Handler,
		},
		{
			MethodName: "DeleteNamespace",
			Handler:    _Worker_DeleteNamespace_Handler,
		},
		{
			MethodName: "TaskStatus",
			Handler:    _Worker_TaskStatus_Handler,
		},
		{
			MethodName: "UpdateExtSnapshotStreamingState",
			Handler:    _Worker_UpdateExtSnapshotStreamingState_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamSnapshot",
			Handler:       _Worker_StreamSnapshot_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "ReceivePredicate",
			Handler:       _Worker_ReceivePredicate_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _Worker_Subscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamExtSnapshot",
			Handler:       _Worker_StreamExtSnapshot_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "pb.proto",
}
