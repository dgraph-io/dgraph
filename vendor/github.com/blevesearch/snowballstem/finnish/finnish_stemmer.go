//! This file was generated automatically by the Snowball to Go compiler
//! http://snowballstem.org/

package finnish

import (
	snowballRuntime "github.com/blevesearch/snowballstem"
)

var A_0 = []*snowballRuntime.Among{
	{Str: "pa", A: -1, B: 1, F: nil},
	{Str: "sti", A: -1, B: 2, F: nil},
	{Str: "kaan", A: -1, B: 1, F: nil},
	{Str: "han", A: -1, B: 1, F: nil},
	{Str: "kin", A: -1, B: 1, F: nil},
	{Str: "h\u00E4n", A: -1, B: 1, F: nil},
	{Str: "k\u00E4\u00E4n", A: -1, B: 1, F: nil},
	{Str: "ko", A: -1, B: 1, F: nil},
	{Str: "p\u00E4", A: -1, B: 1, F: nil},
	{Str: "k\u00F6", A: -1, B: 1, F: nil},
}

var A_1 = []*snowballRuntime.Among{
	{Str: "lla", A: -1, B: -1, F: nil},
	{Str: "na", A: -1, B: -1, F: nil},
	{Str: "ssa", A: -1, B: -1, F: nil},
	{Str: "ta", A: -1, B: -1, F: nil},
	{Str: "lta", A: 3, B: -1, F: nil},
	{Str: "sta", A: 3, B: -1, F: nil},
}

var A_2 = []*snowballRuntime.Among{
	{Str: "ll\u00E4", A: -1, B: -1, F: nil},
	{Str: "n\u00E4", A: -1, B: -1, F: nil},
	{Str: "ss\u00E4", A: -1, B: -1, F: nil},
	{Str: "t\u00E4", A: -1, B: -1, F: nil},
	{Str: "lt\u00E4", A: 3, B: -1, F: nil},
	{Str: "st\u00E4", A: 3, B: -1, F: nil},
}

var A_3 = []*snowballRuntime.Among{
	{Str: "lle", A: -1, B: -1, F: nil},
	{Str: "ine", A: -1, B: -1, F: nil},
}

var A_4 = []*snowballRuntime.Among{
	{Str: "nsa", A: -1, B: 3, F: nil},
	{Str: "mme", A: -1, B: 3, F: nil},
	{Str: "nne", A: -1, B: 3, F: nil},
	{Str: "ni", A: -1, B: 2, F: nil},
	{Str: "si", A: -1, B: 1, F: nil},
	{Str: "an", A: -1, B: 4, F: nil},
	{Str: "en", A: -1, B: 6, F: nil},
	{Str: "\u00E4n", A: -1, B: 5, F: nil},
	{Str: "ns\u00E4", A: -1, B: 3, F: nil},
}

var A_5 = []*snowballRuntime.Among{
	{Str: "aa", A: -1, B: -1, F: nil},
	{Str: "ee", A: -1, B: -1, F: nil},
	{Str: "ii", A: -1, B: -1, F: nil},
	{Str: "oo", A: -1, B: -1, F: nil},
	{Str: "uu", A: -1, B: -1, F: nil},
	{Str: "\u00E4\u00E4", A: -1, B: -1, F: nil},
	{Str: "\u00F6\u00F6", A: -1, B: -1, F: nil},
}

var A_6 = []*snowballRuntime.Among{
	{Str: "a", A: -1, B: 8, F: nil},
	{Str: "lla", A: 0, B: -1, F: nil},
	{Str: "na", A: 0, B: -1, F: nil},
	{Str: "ssa", A: 0, B: -1, F: nil},
	{Str: "ta", A: 0, B: -1, F: nil},
	{Str: "lta", A: 4, B: -1, F: nil},
	{Str: "sta", A: 4, B: -1, F: nil},
	{Str: "tta", A: 4, B: 9, F: nil},
	{Str: "lle", A: -1, B: -1, F: nil},
	{Str: "ine", A: -1, B: -1, F: nil},
	{Str: "ksi", A: -1, B: -1, F: nil},
	{Str: "n", A: -1, B: 7, F: nil},
	{Str: "han", A: 11, B: 1, F: nil},
	{Str: "den", A: 11, B: -1, F: r_VI},
	{Str: "seen", A: 11, B: -1, F: r_LONG},
	{Str: "hen", A: 11, B: 2, F: nil},
	{Str: "tten", A: 11, B: -1, F: r_VI},
	{Str: "hin", A: 11, B: 3, F: nil},
	{Str: "siin", A: 11, B: -1, F: r_VI},
	{Str: "hon", A: 11, B: 4, F: nil},
	{Str: "h\u00E4n", A: 11, B: 5, F: nil},
	{Str: "h\u00F6n", A: 11, B: 6, F: nil},
	{Str: "\u00E4", A: -1, B: 8, F: nil},
	{Str: "ll\u00E4", A: 22, B: -1, F: nil},
	{Str: "n\u00E4", A: 22, B: -1, F: nil},
	{Str: "ss\u00E4", A: 22, B: -1, F: nil},
	{Str: "t\u00E4", A: 22, B: -1, F: nil},
	{Str: "lt\u00E4", A: 26, B: -1, F: nil},
	{Str: "st\u00E4", A: 26, B: -1, F: nil},
	{Str: "tt\u00E4", A: 26, B: 9, F: nil},
}

var A_7 = []*snowballRuntime.Among{
	{Str: "eja", A: -1, B: -1, F: nil},
	{Str: "mma", A: -1, B: 1, F: nil},
	{Str: "imma", A: 1, B: -1, F: nil},
	{Str: "mpa", A: -1, B: 1, F: nil},
	{Str: "impa", A: 3, B: -1, F: nil},
	{Str: "mmi", A: -1, B: 1, F: nil},
	{Str: "immi", A: 5, B: -1, F: nil},
	{Str: "mpi", A: -1, B: 1, F: nil},
	{Str: "impi", A: 7, B: -1, F: nil},
	{Str: "ej\u00E4", A: -1, B: -1, F: nil},
	{Str: "mm\u00E4", A: -1, B: 1, F: nil},
	{Str: "imm\u00E4", A: 10, B: -1, F: nil},
	{Str: "mp\u00E4", A: -1, B: 1, F: nil},
	{Str: "imp\u00E4", A: 12, B: -1, F: nil},
}

var A_8 = []*snowballRuntime.Among{
	{Str: "i", A: -1, B: -1, F: nil},
	{Str: "j", A: -1, B: -1, F: nil},
}

var A_9 = []*snowballRuntime.Among{
	{Str: "mma", A: -1, B: 1, F: nil},
	{Str: "imma", A: 0, B: -1, F: nil},
}

var G_AEI = []byte{17, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8}

var G_V1 = []byte{17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 32}

var G_V2 = []byte{17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 32}

var G_particle_end = []byte{17, 97, 24, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 32}

type Context struct {
	b_ending_removed bool
	S_x              string
	i_p2             int
	i_p1             int
}

func r_mark_regions(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 41
	context.i_p1 = env.Limit
	context.i_p2 = env.Limit
	// goto, line 46
golab0:
	for {
		var v_1 = env.Cursor
	lab1:
		for {
			if !env.InGrouping(G_V1, 97, 246) {
				break lab1
			}
			env.Cursor = v_1
			break golab0
		}
		env.Cursor = v_1
		if env.Cursor >= env.Limit {
			return false
		}
		env.NextChar()
	}
	// gopast, line 46
golab2:
	for {
	lab3:
		for {
			if !env.OutGrouping(G_V1, 97, 246) {
				break lab3
			}
			break golab2
		}
		if env.Cursor >= env.Limit {
			return false
		}
		env.NextChar()
	}
	// setmark p1, line 46
	context.i_p1 = env.Cursor
	// goto, line 47
golab4:
	for {
		var v_3 = env.Cursor
	lab5:
		for {
			if !env.InGrouping(G_V1, 97, 246) {
				break lab5
			}
			env.Cursor = v_3
			break golab4
		}
		env.Cursor = v_3
		if env.Cursor >= env.Limit {
			return false
		}
		env.NextChar()
	}
	// gopast, line 47
golab6:
	for {
	lab7:
		for {
			if !env.OutGrouping(G_V1, 97, 246) {
				break lab7
			}
			break golab6
		}
		if env.Cursor >= env.Limit {
			return false
		}
		env.NextChar()
	}
	// setmark p2, line 47
	context.i_p2 = env.Cursor
	return true
}

func r_R2(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_p2 <= env.Cursor) {
		return false
	}
	return true
}

func r_particle_etc(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 54
	// setlimit, line 55
	var v_1 = env.Limit - env.Cursor
	// tomark, line 55
	if env.Cursor < context.i_p1 {
		return false
	}
	env.Cursor = context.i_p1
	var v_2 = env.LimitBackward
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit - v_1
	// (, line 55
	// [, line 55
	env.Ket = env.Cursor
	// substring, line 55
	among_var = env.FindAmongB(A_0, context)
	if among_var == 0 {
		env.LimitBackward = v_2
		return false
	}
	// ], line 55
	env.Bra = env.Cursor
	env.LimitBackward = v_2
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 62
		if !env.InGroupingB(G_particle_end, 97, 246) {
			return false
		}
	} else if among_var == 2 {
		// (, line 64
		// call R2, line 64
		if !r_R2(env, context) {
			return false
		}
	}
	// delete, line 66
	if !env.SliceDel() {
		return false
	}
	return true
}

func r_possessive(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 68
	// setlimit, line 69
	var v_1 = env.Limit - env.Cursor
	// tomark, line 69
	if env.Cursor < context.i_p1 {
		return false
	}
	env.Cursor = context.i_p1
	var v_2 = env.LimitBackward
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit - v_1
	// (, line 69
	// [, line 69
	env.Ket = env.Cursor
	// substring, line 69
	among_var = env.FindAmongB(A_4, context)
	if among_var == 0 {
		env.LimitBackward = v_2
		return false
	}
	// ], line 69
	env.Bra = env.Cursor
	env.LimitBackward = v_2
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 72
		// not, line 72
		var v_3 = env.Limit - env.Cursor
	lab0:
		for {
			// literal, line 72
			if !env.EqSB("k") {
				break lab0
			}
			return false
		}
		env.Cursor = env.Limit - v_3
		// delete, line 72
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		// (, line 74
		// delete, line 74
		if !env.SliceDel() {
			return false
		}
		// [, line 74
		env.Ket = env.Cursor
		// literal, line 74
		if !env.EqSB("kse") {
			return false
		}
		// ], line 74
		env.Bra = env.Cursor
		// <-, line 74
		if !env.SliceFrom("ksi") {
			return false
		}
	} else if among_var == 3 {
		// (, line 78
		// delete, line 78
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 4 {
		// (, line 81
		// among, line 81
		if env.FindAmongB(A_1, context) == 0 {
			return false
		}
		// delete, line 81
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 5 {
		// (, line 83
		// among, line 83
		if env.FindAmongB(A_2, context) == 0 {
			return false
		}
		// delete, line 84
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 6 {
		// (, line 86
		// among, line 86
		if env.FindAmongB(A_3, context) == 0 {
			return false
		}
		// delete, line 86
		if !env.SliceDel() {
			return false
		}
	}
	return true
}

func r_LONG(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// among, line 91
	if env.FindAmongB(A_5, context) == 0 {
		return false
	}
	return true
}

func r_VI(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 93
	// literal, line 93
	if !env.EqSB("i") {
		return false
	}
	if !env.InGroupingB(G_V2, 97, 246) {
		return false
	}
	return true
}

func r_case_ending(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 95
	// setlimit, line 96
	var v_1 = env.Limit - env.Cursor
	// tomark, line 96
	if env.Cursor < context.i_p1 {
		return false
	}
	env.Cursor = context.i_p1
	var v_2 = env.LimitBackward
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit - v_1
	// (, line 96
	// [, line 96
	env.Ket = env.Cursor
	// substring, line 96
	among_var = env.FindAmongB(A_6, context)
	if among_var == 0 {
		env.LimitBackward = v_2
		return false
	}
	// ], line 96
	env.Bra = env.Cursor
	env.LimitBackward = v_2
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 98
		// literal, line 98
		if !env.EqSB("a") {
			return false
		}
	} else if among_var == 2 {
		// (, line 99
		// literal, line 99
		if !env.EqSB("e") {
			return false
		}
	} else if among_var == 3 {
		// (, line 100
		// literal, line 100
		if !env.EqSB("i") {
			return false
		}
	} else if among_var == 4 {
		// (, line 101
		// literal, line 101
		if !env.EqSB("o") {
			return false
		}
	} else if among_var == 5 {
		// (, line 102
		// literal, line 102
		if !env.EqSB("\u00E4") {
			return false
		}
	} else if among_var == 6 {
		// (, line 103
		// literal, line 103
		if !env.EqSB("\u00F6") {
			return false
		}
	} else if among_var == 7 {
		// (, line 111
		// try, line 111
		var v_3 = env.Limit - env.Cursor
	lab0:
		for {
			// (, line 111
			// and, line 113
			var v_4 = env.Limit - env.Cursor
			// or, line 112
		lab1:
			for {
				var v_5 = env.Limit - env.Cursor
			lab2:
				for {
					// call LONG, line 111
					if !r_LONG(env, context) {
						break lab2
					}
					break lab1
				}
				env.Cursor = env.Limit - v_5
				// literal, line 112
				if !env.EqSB("ie") {
					env.Cursor = env.Limit - v_3
					break lab0
				}
				break lab1
			}
			env.Cursor = env.Limit - v_4
			// next, line 113
			if env.Cursor <= env.LimitBackward {
				env.Cursor = env.Limit - v_3
				break lab0
			}
			env.PrevChar()
			// ], line 113
			env.Bra = env.Cursor
			break lab0
		}
	} else if among_var == 8 {
		// (, line 119
		if !env.InGroupingB(G_V1, 97, 246) {
			return false
		}
		if !env.OutGroupingB(G_V1, 97, 246) {
			return false
		}
	} else if among_var == 9 {
		// (, line 121
		// literal, line 121
		if !env.EqSB("e") {
			return false
		}
	}
	// delete, line 138
	if !env.SliceDel() {
		return false
	}
	// set ending_removed, line 139
	context.b_ending_removed = true
	return true
}

func r_other_endings(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 141
	// setlimit, line 142
	var v_1 = env.Limit - env.Cursor
	// tomark, line 142
	if env.Cursor < context.i_p2 {
		return false
	}
	env.Cursor = context.i_p2
	var v_2 = env.LimitBackward
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit - v_1
	// (, line 142
	// [, line 142
	env.Ket = env.Cursor
	// substring, line 142
	among_var = env.FindAmongB(A_7, context)
	if among_var == 0 {
		env.LimitBackward = v_2
		return false
	}
	// ], line 142
	env.Bra = env.Cursor
	env.LimitBackward = v_2
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 146
		// not, line 146
		var v_3 = env.Limit - env.Cursor
	lab0:
		for {
			// literal, line 146
			if !env.EqSB("po") {
				break lab0
			}
			return false
		}
		env.Cursor = env.Limit - v_3
	}
	// delete, line 151
	if !env.SliceDel() {
		return false
	}
	return true
}

func r_i_plural(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 153
	// setlimit, line 154
	var v_1 = env.Limit - env.Cursor
	// tomark, line 154
	if env.Cursor < context.i_p1 {
		return false
	}
	env.Cursor = context.i_p1
	var v_2 = env.LimitBackward
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit - v_1
	// (, line 154
	// [, line 154
	env.Ket = env.Cursor
	// substring, line 154
	if env.FindAmongB(A_8, context) == 0 {
		env.LimitBackward = v_2
		return false
	}
	// ], line 154
	env.Bra = env.Cursor
	env.LimitBackward = v_2
	// delete, line 158
	if !env.SliceDel() {
		return false
	}
	return true
}

func r_t_plural(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 160
	// setlimit, line 161
	var v_1 = env.Limit - env.Cursor
	// tomark, line 161
	if env.Cursor < context.i_p1 {
		return false
	}
	env.Cursor = context.i_p1
	var v_2 = env.LimitBackward
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit - v_1
	// (, line 161
	// [, line 162
	env.Ket = env.Cursor
	// literal, line 162
	if !env.EqSB("t") {
		env.LimitBackward = v_2
		return false
	}
	// ], line 162
	env.Bra = env.Cursor
	// test, line 162
	var v_3 = env.Limit - env.Cursor
	if !env.InGroupingB(G_V1, 97, 246) {
		env.LimitBackward = v_2
		return false
	}
	env.Cursor = env.Limit - v_3
	// delete, line 163
	if !env.SliceDel() {
		return false
	}
	env.LimitBackward = v_2
	// setlimit, line 165
	var v_4 = env.Limit - env.Cursor
	// tomark, line 165
	if env.Cursor < context.i_p2 {
		return false
	}
	env.Cursor = context.i_p2
	var v_5 = env.LimitBackward
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit - v_4
	// (, line 165
	// [, line 165
	env.Ket = env.Cursor
	// substring, line 165
	among_var = env.FindAmongB(A_9, context)
	if among_var == 0 {
		env.LimitBackward = v_5
		return false
	}
	// ], line 165
	env.Bra = env.Cursor
	env.LimitBackward = v_5
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 167
		// not, line 167
		var v_6 = env.Limit - env.Cursor
	lab0:
		for {
			// literal, line 167
			if !env.EqSB("po") {
				break lab0
			}
			return false
		}
		env.Cursor = env.Limit - v_6
	}
	// delete, line 170
	if !env.SliceDel() {
		return false
	}
	return true
}

func r_tidy(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 172
	// setlimit, line 173
	var v_1 = env.Limit - env.Cursor
	// tomark, line 173
	if env.Cursor < context.i_p1 {
		return false
	}
	env.Cursor = context.i_p1
	var v_2 = env.LimitBackward
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit - v_1
	// (, line 173
	// do, line 174
	var v_3 = env.Limit - env.Cursor
lab0:
	for {
		// (, line 174
		// and, line 174
		var v_4 = env.Limit - env.Cursor
		// call LONG, line 174
		if !r_LONG(env, context) {
			break lab0
		}
		env.Cursor = env.Limit - v_4
		// (, line 174
		// [, line 174
		env.Ket = env.Cursor
		// next, line 174
		if env.Cursor <= env.LimitBackward {
			break lab0
		}
		env.PrevChar()
		// ], line 174
		env.Bra = env.Cursor
		// delete, line 174
		if !env.SliceDel() {
			return false
		}
		break lab0
	}
	env.Cursor = env.Limit - v_3
	// do, line 175
	var v_5 = env.Limit - env.Cursor
lab1:
	for {
		// (, line 175
		// [, line 175
		env.Ket = env.Cursor
		if !env.InGroupingB(G_AEI, 97, 228) {
			break lab1
		}
		// ], line 175
		env.Bra = env.Cursor
		if !env.OutGroupingB(G_V1, 97, 246) {
			break lab1
		}
		// delete, line 175
		if !env.SliceDel() {
			return false
		}
		break lab1
	}
	env.Cursor = env.Limit - v_5
	// do, line 176
	var v_6 = env.Limit - env.Cursor
lab2:
	for {
		// (, line 176
		// [, line 176
		env.Ket = env.Cursor
		// literal, line 176
		if !env.EqSB("j") {
			break lab2
		}
		// ], line 176
		env.Bra = env.Cursor
		// or, line 176
	lab3:
		for {
			var v_7 = env.Limit - env.Cursor
		lab4:
			for {
				// literal, line 176
				if !env.EqSB("o") {
					break lab4
				}
				break lab3
			}
			env.Cursor = env.Limit - v_7
			// literal, line 176
			if !env.EqSB("u") {
				break lab2
			}
			break lab3
		}
		// delete, line 176
		if !env.SliceDel() {
			return false
		}
		break lab2
	}
	env.Cursor = env.Limit - v_6
	// do, line 177
	var v_8 = env.Limit - env.Cursor
lab5:
	for {
		// (, line 177
		// [, line 177
		env.Ket = env.Cursor
		// literal, line 177
		if !env.EqSB("o") {
			break lab5
		}
		// ], line 177
		env.Bra = env.Cursor
		// literal, line 177
		if !env.EqSB("j") {
			break lab5
		}
		// delete, line 177
		if !env.SliceDel() {
			return false
		}
		break lab5
	}
	env.Cursor = env.Limit - v_8
	env.LimitBackward = v_2
	// goto, line 179
golab6:
	for {
		var v_9 = env.Limit - env.Cursor
	lab7:
		for {
			if !env.OutGroupingB(G_V1, 97, 246) {
				break lab7
			}
			env.Cursor = env.Limit - v_9
			break golab6
		}
		env.Cursor = env.Limit - v_9
		if env.Cursor <= env.LimitBackward {
			return false
		}
		env.PrevChar()
	}
	// [, line 179
	env.Ket = env.Cursor
	// next, line 179
	if env.Cursor <= env.LimitBackward {
		return false
	}
	env.PrevChar()
	// ], line 179
	env.Bra = env.Cursor
	// -> x, line 179
	context.S_x = env.SliceTo()
	if context.S_x == "" {
		return false
	}
	// name x, line 179
	if !env.EqSB(context.S_x) {
		return false
	}
	// delete, line 179
	if !env.SliceDel() {
		return false
	}
	return true
}

func Stem(env *snowballRuntime.Env) bool {
	var context = &Context{
		b_ending_removed: false,
		S_x:              "",
		i_p2:             0,
		i_p1:             0,
	}
	_ = context
	// (, line 183
	// do, line 185
	var v_1 = env.Cursor
lab0:
	for {
		// call mark_regions, line 185
		if !r_mark_regions(env, context) {
			break lab0
		}
		break lab0
	}
	env.Cursor = v_1
	// unset ending_removed, line 186
	context.b_ending_removed = false
	// backwards, line 187
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit
	// (, line 187
	// do, line 188
	var v_2 = env.Limit - env.Cursor
lab1:
	for {
		// call particle_etc, line 188
		if !r_particle_etc(env, context) {
			break lab1
		}
		break lab1
	}
	env.Cursor = env.Limit - v_2
	// do, line 189
	var v_3 = env.Limit - env.Cursor
lab2:
	for {
		// call possessive, line 189
		if !r_possessive(env, context) {
			break lab2
		}
		break lab2
	}
	env.Cursor = env.Limit - v_3
	// do, line 190
	var v_4 = env.Limit - env.Cursor
lab3:
	for {
		// call case_ending, line 190
		if !r_case_ending(env, context) {
			break lab3
		}
		break lab3
	}
	env.Cursor = env.Limit - v_4
	// do, line 191
	var v_5 = env.Limit - env.Cursor
lab4:
	for {
		// call other_endings, line 191
		if !r_other_endings(env, context) {
			break lab4
		}
		break lab4
	}
	env.Cursor = env.Limit - v_5
	// or, line 192
lab5:
	for {
		var v_6 = env.Limit - env.Cursor
	lab6:
		for {
			// (, line 192
			// Boolean test ending_removed, line 192
			if !context.b_ending_removed {
				break lab6
			}
			// do, line 192
			var v_7 = env.Limit - env.Cursor
		lab7:
			for {
				// call i_plural, line 192
				if !r_i_plural(env, context) {
					break lab7
				}
				break lab7
			}
			env.Cursor = env.Limit - v_7
			break lab5
		}
		env.Cursor = env.Limit - v_6
		// do, line 192
		var v_8 = env.Limit - env.Cursor
	lab8:
		for {
			// call t_plural, line 192
			if !r_t_plural(env, context) {
				break lab8
			}
			break lab8
		}
		env.Cursor = env.Limit - v_8
		break lab5
	}
	// do, line 193
	var v_9 = env.Limit - env.Cursor
lab9:
	for {
		// call tidy, line 193
		if !r_tidy(env, context) {
			break lab9
		}
		break lab9
	}
	env.Cursor = env.Limit - v_9
	env.Cursor = env.LimitBackward
	return true
}
