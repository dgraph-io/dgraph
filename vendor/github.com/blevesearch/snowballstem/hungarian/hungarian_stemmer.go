//! This file was generated automatically by the Snowball to Go compiler
//! http://snowballstem.org/

package hungarian

import (
	snowballRuntime "github.com/blevesearch/snowballstem"
)

var A_0 = []*snowballRuntime.Among{
	{Str: "cs", A: -1, B: -1, F: nil},
	{Str: "dzs", A: -1, B: -1, F: nil},
	{Str: "gy", A: -1, B: -1, F: nil},
	{Str: "ly", A: -1, B: -1, F: nil},
	{Str: "ny", A: -1, B: -1, F: nil},
	{Str: "sz", A: -1, B: -1, F: nil},
	{Str: "ty", A: -1, B: -1, F: nil},
	{Str: "zs", A: -1, B: -1, F: nil},
}

var A_1 = []*snowballRuntime.Among{
	{Str: "\u00E1", A: -1, B: 1, F: nil},
	{Str: "\u00E9", A: -1, B: 2, F: nil},
}

var A_2 = []*snowballRuntime.Among{
	{Str: "bb", A: -1, B: -1, F: nil},
	{Str: "cc", A: -1, B: -1, F: nil},
	{Str: "dd", A: -1, B: -1, F: nil},
	{Str: "ff", A: -1, B: -1, F: nil},
	{Str: "gg", A: -1, B: -1, F: nil},
	{Str: "jj", A: -1, B: -1, F: nil},
	{Str: "kk", A: -1, B: -1, F: nil},
	{Str: "ll", A: -1, B: -1, F: nil},
	{Str: "mm", A: -1, B: -1, F: nil},
	{Str: "nn", A: -1, B: -1, F: nil},
	{Str: "pp", A: -1, B: -1, F: nil},
	{Str: "rr", A: -1, B: -1, F: nil},
	{Str: "ccs", A: -1, B: -1, F: nil},
	{Str: "ss", A: -1, B: -1, F: nil},
	{Str: "zzs", A: -1, B: -1, F: nil},
	{Str: "tt", A: -1, B: -1, F: nil},
	{Str: "vv", A: -1, B: -1, F: nil},
	{Str: "ggy", A: -1, B: -1, F: nil},
	{Str: "lly", A: -1, B: -1, F: nil},
	{Str: "nny", A: -1, B: -1, F: nil},
	{Str: "tty", A: -1, B: -1, F: nil},
	{Str: "ssz", A: -1, B: -1, F: nil},
	{Str: "zz", A: -1, B: -1, F: nil},
}

var A_3 = []*snowballRuntime.Among{
	{Str: "al", A: -1, B: 1, F: nil},
	{Str: "el", A: -1, B: 2, F: nil},
}

var A_4 = []*snowballRuntime.Among{
	{Str: "ba", A: -1, B: -1, F: nil},
	{Str: "ra", A: -1, B: -1, F: nil},
	{Str: "be", A: -1, B: -1, F: nil},
	{Str: "re", A: -1, B: -1, F: nil},
	{Str: "ig", A: -1, B: -1, F: nil},
	{Str: "nak", A: -1, B: -1, F: nil},
	{Str: "nek", A: -1, B: -1, F: nil},
	{Str: "val", A: -1, B: -1, F: nil},
	{Str: "vel", A: -1, B: -1, F: nil},
	{Str: "ul", A: -1, B: -1, F: nil},
	{Str: "b\u0151l", A: -1, B: -1, F: nil},
	{Str: "r\u0151l", A: -1, B: -1, F: nil},
	{Str: "t\u0151l", A: -1, B: -1, F: nil},
	{Str: "n\u00E1l", A: -1, B: -1, F: nil},
	{Str: "n\u00E9l", A: -1, B: -1, F: nil},
	{Str: "b\u00F3l", A: -1, B: -1, F: nil},
	{Str: "r\u00F3l", A: -1, B: -1, F: nil},
	{Str: "t\u00F3l", A: -1, B: -1, F: nil},
	{Str: "\u00FCl", A: -1, B: -1, F: nil},
	{Str: "n", A: -1, B: -1, F: nil},
	{Str: "an", A: 19, B: -1, F: nil},
	{Str: "ban", A: 20, B: -1, F: nil},
	{Str: "en", A: 19, B: -1, F: nil},
	{Str: "ben", A: 22, B: -1, F: nil},
	{Str: "k\u00E9ppen", A: 22, B: -1, F: nil},
	{Str: "on", A: 19, B: -1, F: nil},
	{Str: "\u00F6n", A: 19, B: -1, F: nil},
	{Str: "k\u00E9pp", A: -1, B: -1, F: nil},
	{Str: "kor", A: -1, B: -1, F: nil},
	{Str: "t", A: -1, B: -1, F: nil},
	{Str: "at", A: 29, B: -1, F: nil},
	{Str: "et", A: 29, B: -1, F: nil},
	{Str: "k\u00E9nt", A: 29, B: -1, F: nil},
	{Str: "ank\u00E9nt", A: 32, B: -1, F: nil},
	{Str: "enk\u00E9nt", A: 32, B: -1, F: nil},
	{Str: "onk\u00E9nt", A: 32, B: -1, F: nil},
	{Str: "ot", A: 29, B: -1, F: nil},
	{Str: "\u00E9rt", A: 29, B: -1, F: nil},
	{Str: "\u00F6t", A: 29, B: -1, F: nil},
	{Str: "hez", A: -1, B: -1, F: nil},
	{Str: "hoz", A: -1, B: -1, F: nil},
	{Str: "h\u00F6z", A: -1, B: -1, F: nil},
	{Str: "v\u00E1", A: -1, B: -1, F: nil},
	{Str: "v\u00E9", A: -1, B: -1, F: nil},
}

var A_5 = []*snowballRuntime.Among{
	{Str: "\u00E1n", A: -1, B: 2, F: nil},
	{Str: "\u00E9n", A: -1, B: 1, F: nil},
	{Str: "\u00E1nk\u00E9nt", A: -1, B: 3, F: nil},
}

var A_6 = []*snowballRuntime.Among{
	{Str: "stul", A: -1, B: 2, F: nil},
	{Str: "astul", A: 0, B: 1, F: nil},
	{Str: "\u00E1stul", A: 0, B: 3, F: nil},
	{Str: "st\u00FCl", A: -1, B: 2, F: nil},
	{Str: "est\u00FCl", A: 3, B: 1, F: nil},
	{Str: "\u00E9st\u00FCl", A: 3, B: 4, F: nil},
}

var A_7 = []*snowballRuntime.Among{
	{Str: "\u00E1", A: -1, B: 1, F: nil},
	{Str: "\u00E9", A: -1, B: 2, F: nil},
}

var A_8 = []*snowballRuntime.Among{
	{Str: "k", A: -1, B: 7, F: nil},
	{Str: "ak", A: 0, B: 4, F: nil},
	{Str: "ek", A: 0, B: 6, F: nil},
	{Str: "ok", A: 0, B: 5, F: nil},
	{Str: "\u00E1k", A: 0, B: 1, F: nil},
	{Str: "\u00E9k", A: 0, B: 2, F: nil},
	{Str: "\u00F6k", A: 0, B: 3, F: nil},
}

var A_9 = []*snowballRuntime.Among{
	{Str: "\u00E9i", A: -1, B: 7, F: nil},
	{Str: "\u00E1\u00E9i", A: 0, B: 6, F: nil},
	{Str: "\u00E9\u00E9i", A: 0, B: 5, F: nil},
	{Str: "\u00E9", A: -1, B: 9, F: nil},
	{Str: "k\u00E9", A: 3, B: 4, F: nil},
	{Str: "ak\u00E9", A: 4, B: 1, F: nil},
	{Str: "ek\u00E9", A: 4, B: 1, F: nil},
	{Str: "ok\u00E9", A: 4, B: 1, F: nil},
	{Str: "\u00E1k\u00E9", A: 4, B: 3, F: nil},
	{Str: "\u00E9k\u00E9", A: 4, B: 2, F: nil},
	{Str: "\u00F6k\u00E9", A: 4, B: 1, F: nil},
	{Str: "\u00E9\u00E9", A: 3, B: 8, F: nil},
}

var A_10 = []*snowballRuntime.Among{
	{Str: "a", A: -1, B: 18, F: nil},
	{Str: "ja", A: 0, B: 17, F: nil},
	{Str: "d", A: -1, B: 16, F: nil},
	{Str: "ad", A: 2, B: 13, F: nil},
	{Str: "ed", A: 2, B: 13, F: nil},
	{Str: "od", A: 2, B: 13, F: nil},
	{Str: "\u00E1d", A: 2, B: 14, F: nil},
	{Str: "\u00E9d", A: 2, B: 15, F: nil},
	{Str: "\u00F6d", A: 2, B: 13, F: nil},
	{Str: "e", A: -1, B: 18, F: nil},
	{Str: "je", A: 9, B: 17, F: nil},
	{Str: "nk", A: -1, B: 4, F: nil},
	{Str: "unk", A: 11, B: 1, F: nil},
	{Str: "\u00E1nk", A: 11, B: 2, F: nil},
	{Str: "\u00E9nk", A: 11, B: 3, F: nil},
	{Str: "\u00FCnk", A: 11, B: 1, F: nil},
	{Str: "uk", A: -1, B: 8, F: nil},
	{Str: "juk", A: 16, B: 7, F: nil},
	{Str: "\u00E1juk", A: 17, B: 5, F: nil},
	{Str: "\u00FCk", A: -1, B: 8, F: nil},
	{Str: "j\u00FCk", A: 19, B: 7, F: nil},
	{Str: "\u00E9j\u00FCk", A: 20, B: 6, F: nil},
	{Str: "m", A: -1, B: 12, F: nil},
	{Str: "am", A: 22, B: 9, F: nil},
	{Str: "em", A: 22, B: 9, F: nil},
	{Str: "om", A: 22, B: 9, F: nil},
	{Str: "\u00E1m", A: 22, B: 10, F: nil},
	{Str: "\u00E9m", A: 22, B: 11, F: nil},
	{Str: "o", A: -1, B: 18, F: nil},
	{Str: "\u00E1", A: -1, B: 19, F: nil},
	{Str: "\u00E9", A: -1, B: 20, F: nil},
}

var A_11 = []*snowballRuntime.Among{
	{Str: "id", A: -1, B: 10, F: nil},
	{Str: "aid", A: 0, B: 9, F: nil},
	{Str: "jaid", A: 1, B: 6, F: nil},
	{Str: "eid", A: 0, B: 9, F: nil},
	{Str: "jeid", A: 3, B: 6, F: nil},
	{Str: "\u00E1id", A: 0, B: 7, F: nil},
	{Str: "\u00E9id", A: 0, B: 8, F: nil},
	{Str: "i", A: -1, B: 15, F: nil},
	{Str: "ai", A: 7, B: 14, F: nil},
	{Str: "jai", A: 8, B: 11, F: nil},
	{Str: "ei", A: 7, B: 14, F: nil},
	{Str: "jei", A: 10, B: 11, F: nil},
	{Str: "\u00E1i", A: 7, B: 12, F: nil},
	{Str: "\u00E9i", A: 7, B: 13, F: nil},
	{Str: "itek", A: -1, B: 24, F: nil},
	{Str: "eitek", A: 14, B: 21, F: nil},
	{Str: "jeitek", A: 15, B: 20, F: nil},
	{Str: "\u00E9itek", A: 14, B: 23, F: nil},
	{Str: "ik", A: -1, B: 29, F: nil},
	{Str: "aik", A: 18, B: 26, F: nil},
	{Str: "jaik", A: 19, B: 25, F: nil},
	{Str: "eik", A: 18, B: 26, F: nil},
	{Str: "jeik", A: 21, B: 25, F: nil},
	{Str: "\u00E1ik", A: 18, B: 27, F: nil},
	{Str: "\u00E9ik", A: 18, B: 28, F: nil},
	{Str: "ink", A: -1, B: 20, F: nil},
	{Str: "aink", A: 25, B: 17, F: nil},
	{Str: "jaink", A: 26, B: 16, F: nil},
	{Str: "eink", A: 25, B: 17, F: nil},
	{Str: "jeink", A: 28, B: 16, F: nil},
	{Str: "\u00E1ink", A: 25, B: 18, F: nil},
	{Str: "\u00E9ink", A: 25, B: 19, F: nil},
	{Str: "aitok", A: -1, B: 21, F: nil},
	{Str: "jaitok", A: 32, B: 20, F: nil},
	{Str: "\u00E1itok", A: -1, B: 22, F: nil},
	{Str: "im", A: -1, B: 5, F: nil},
	{Str: "aim", A: 35, B: 4, F: nil},
	{Str: "jaim", A: 36, B: 1, F: nil},
	{Str: "eim", A: 35, B: 4, F: nil},
	{Str: "jeim", A: 38, B: 1, F: nil},
	{Str: "\u00E1im", A: 35, B: 2, F: nil},
	{Str: "\u00E9im", A: 35, B: 3, F: nil},
}

var G_v = []byte{17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 17, 36, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1}

type Context struct {
	i_p1 int
}

func r_mark_regions(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 44
	context.i_p1 = env.Limit
	// or, line 51
lab0:
	for {
		var v_1 = env.Cursor
	lab1:
		for {
			// (, line 48
			if !env.InGrouping(G_v, 97, 369) {
				break lab1
			}
			// goto, line 48
		golab2:
			for {
				var v_2 = env.Cursor
			lab3:
				for {
					if !env.OutGrouping(G_v, 97, 369) {
						break lab3
					}
					env.Cursor = v_2
					break golab2
				}
				env.Cursor = v_2
				if env.Cursor >= env.Limit {
					break lab1
				}
				env.NextChar()
			}
			// or, line 49
		lab4:
			for {
				var v_3 = env.Cursor
			lab5:
				for {
					// among, line 49
					if env.FindAmong(A_0, context) == 0 {
						break lab5
					}
					break lab4
				}
				env.Cursor = v_3
				// next, line 49
				if env.Cursor >= env.Limit {
					break lab1
				}
				env.NextChar()
				break lab4
			}
			// setmark p1, line 50
			context.i_p1 = env.Cursor
			break lab0
		}
		env.Cursor = v_1
		// (, line 53
		if !env.OutGrouping(G_v, 97, 369) {
			return false
		}
		// gopast, line 53
	golab6:
		for {
		lab7:
			for {
				if !env.InGrouping(G_v, 97, 369) {
					break lab7
				}
				break golab6
			}
			if env.Cursor >= env.Limit {
				return false
			}
			env.NextChar()
		}
		// setmark p1, line 53
		context.i_p1 = env.Cursor
		break lab0
	}
	return true
}

func r_R1(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_p1 <= env.Cursor) {
		return false
	}
	return true
}

func r_v_ending(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 60
	// [, line 61
	env.Ket = env.Cursor
	// substring, line 61
	among_var = env.FindAmongB(A_1, context)
	if among_var == 0 {
		return false
	}
	// ], line 61
	env.Bra = env.Cursor
	// call R1, line 61
	if !r_R1(env, context) {
		return false
	}
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 62
		// <-, line 62
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 2 {
		// (, line 63
		// <-, line 63
		if !env.SliceFrom("e") {
			return false
		}
	}
	return true
}

func r_double(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 67
	// test, line 68
	var v_1 = env.Limit - env.Cursor
	// among, line 68
	if env.FindAmongB(A_2, context) == 0 {
		return false
	}
	env.Cursor = env.Limit - v_1
	return true
}

func r_undouble(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 72
	// next, line 73
	if env.Cursor <= env.LimitBackward {
		return false
	}
	env.PrevChar()
	// [, line 73
	env.Ket = env.Cursor
	{
		// hop, line 73
		var c = env.ByteIndexForHop(-(1))
		if int32(env.LimitBackward) > c || c > int32(env.Limit) {
			return false
		}
		env.Cursor = int(c)
	}
	// ], line 73
	env.Bra = env.Cursor
	// delete, line 73
	if !env.SliceDel() {
		return false
	}
	return true
}

func r_instrum(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 76
	// [, line 77
	env.Ket = env.Cursor
	// substring, line 77
	among_var = env.FindAmongB(A_3, context)
	if among_var == 0 {
		return false
	}
	// ], line 77
	env.Bra = env.Cursor
	// call R1, line 77
	if !r_R1(env, context) {
		return false
	}
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 78
		// call double, line 78
		if !r_double(env, context) {
			return false
		}
	} else if among_var == 2 {
		// (, line 79
		// call double, line 79
		if !r_double(env, context) {
			return false
		}
	}
	// delete, line 81
	if !env.SliceDel() {
		return false
	}
	// call undouble, line 82
	if !r_undouble(env, context) {
		return false
	}
	return true
}

func r_case(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 86
	// [, line 87
	env.Ket = env.Cursor
	// substring, line 87
	if env.FindAmongB(A_4, context) == 0 {
		return false
	}
	// ], line 87
	env.Bra = env.Cursor
	// call R1, line 87
	if !r_R1(env, context) {
		return false
	}
	// delete, line 111
	if !env.SliceDel() {
		return false
	}
	// call v_ending, line 112
	if !r_v_ending(env, context) {
		return false
	}
	return true
}

func r_case_special(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 115
	// [, line 116
	env.Ket = env.Cursor
	// substring, line 116
	among_var = env.FindAmongB(A_5, context)
	if among_var == 0 {
		return false
	}
	// ], line 116
	env.Bra = env.Cursor
	// call R1, line 116
	if !r_R1(env, context) {
		return false
	}
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 117
		// <-, line 117
		if !env.SliceFrom("e") {
			return false
		}
	} else if among_var == 2 {
		// (, line 118
		// <-, line 118
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 3 {
		// (, line 119
		// <-, line 119
		if !env.SliceFrom("a") {
			return false
		}
	}
	return true
}

func r_case_other(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 123
	// [, line 124
	env.Ket = env.Cursor
	// substring, line 124
	among_var = env.FindAmongB(A_6, context)
	if among_var == 0 {
		return false
	}
	// ], line 124
	env.Bra = env.Cursor
	// call R1, line 124
	if !r_R1(env, context) {
		return false
	}
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 125
		// delete, line 125
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		// (, line 126
		// delete, line 126
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 3 {
		// (, line 127
		// <-, line 127
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 4 {
		// (, line 128
		// <-, line 128
		if !env.SliceFrom("e") {
			return false
		}
	}
	return true
}

func r_factive(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 132
	// [, line 133
	env.Ket = env.Cursor
	// substring, line 133
	among_var = env.FindAmongB(A_7, context)
	if among_var == 0 {
		return false
	}
	// ], line 133
	env.Bra = env.Cursor
	// call R1, line 133
	if !r_R1(env, context) {
		return false
	}
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 134
		// call double, line 134
		if !r_double(env, context) {
			return false
		}
	} else if among_var == 2 {
		// (, line 135
		// call double, line 135
		if !r_double(env, context) {
			return false
		}
	}
	// delete, line 137
	if !env.SliceDel() {
		return false
	}
	// call undouble, line 138
	if !r_undouble(env, context) {
		return false
	}
	return true
}

func r_plural(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 141
	// [, line 142
	env.Ket = env.Cursor
	// substring, line 142
	among_var = env.FindAmongB(A_8, context)
	if among_var == 0 {
		return false
	}
	// ], line 142
	env.Bra = env.Cursor
	// call R1, line 142
	if !r_R1(env, context) {
		return false
	}
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 143
		// <-, line 143
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 2 {
		// (, line 144
		// <-, line 144
		if !env.SliceFrom("e") {
			return false
		}
	} else if among_var == 3 {
		// (, line 145
		// delete, line 145
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 4 {
		// (, line 146
		// delete, line 146
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 5 {
		// (, line 147
		// delete, line 147
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 6 {
		// (, line 148
		// delete, line 148
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 7 {
		// (, line 149
		// delete, line 149
		if !env.SliceDel() {
			return false
		}
	}
	return true
}

func r_owned(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 153
	// [, line 154
	env.Ket = env.Cursor
	// substring, line 154
	among_var = env.FindAmongB(A_9, context)
	if among_var == 0 {
		return false
	}
	// ], line 154
	env.Bra = env.Cursor
	// call R1, line 154
	if !r_R1(env, context) {
		return false
	}
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 155
		// delete, line 155
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		// (, line 156
		// <-, line 156
		if !env.SliceFrom("e") {
			return false
		}
	} else if among_var == 3 {
		// (, line 157
		// <-, line 157
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 4 {
		// (, line 158
		// delete, line 158
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 5 {
		// (, line 159
		// <-, line 159
		if !env.SliceFrom("e") {
			return false
		}
	} else if among_var == 6 {
		// (, line 160
		// <-, line 160
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 7 {
		// (, line 161
		// delete, line 161
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 8 {
		// (, line 162
		// <-, line 162
		if !env.SliceFrom("e") {
			return false
		}
	} else if among_var == 9 {
		// (, line 163
		// delete, line 163
		if !env.SliceDel() {
			return false
		}
	}
	return true
}

func r_sing_owner(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 167
	// [, line 168
	env.Ket = env.Cursor
	// substring, line 168
	among_var = env.FindAmongB(A_10, context)
	if among_var == 0 {
		return false
	}
	// ], line 168
	env.Bra = env.Cursor
	// call R1, line 168
	if !r_R1(env, context) {
		return false
	}
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 169
		// delete, line 169
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		// (, line 170
		// <-, line 170
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 3 {
		// (, line 171
		// <-, line 171
		if !env.SliceFrom("e") {
			return false
		}
	} else if among_var == 4 {
		// (, line 172
		// delete, line 172
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 5 {
		// (, line 173
		// <-, line 173
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 6 {
		// (, line 174
		// <-, line 174
		if !env.SliceFrom("e") {
			return false
		}
	} else if among_var == 7 {
		// (, line 175
		// delete, line 175
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 8 {
		// (, line 176
		// delete, line 176
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 9 {
		// (, line 177
		// delete, line 177
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 10 {
		// (, line 178
		// <-, line 178
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 11 {
		// (, line 179
		// <-, line 179
		if !env.SliceFrom("e") {
			return false
		}
	} else if among_var == 12 {
		// (, line 180
		// delete, line 180
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 13 {
		// (, line 181
		// delete, line 181
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 14 {
		// (, line 182
		// <-, line 182
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 15 {
		// (, line 183
		// <-, line 183
		if !env.SliceFrom("e") {
			return false
		}
	} else if among_var == 16 {
		// (, line 184
		// delete, line 184
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 17 {
		// (, line 185
		// delete, line 185
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 18 {
		// (, line 186
		// delete, line 186
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 19 {
		// (, line 187
		// <-, line 187
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 20 {
		// (, line 188
		// <-, line 188
		if !env.SliceFrom("e") {
			return false
		}
	}
	return true
}

func r_plur_owner(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 192
	// [, line 193
	env.Ket = env.Cursor
	// substring, line 193
	among_var = env.FindAmongB(A_11, context)
	if among_var == 0 {
		return false
	}
	// ], line 193
	env.Bra = env.Cursor
	// call R1, line 193
	if !r_R1(env, context) {
		return false
	}
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 194
		// delete, line 194
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		// (, line 195
		// <-, line 195
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 3 {
		// (, line 196
		// <-, line 196
		if !env.SliceFrom("e") {
			return false
		}
	} else if among_var == 4 {
		// (, line 197
		// delete, line 197
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 5 {
		// (, line 198
		// delete, line 198
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 6 {
		// (, line 199
		// delete, line 199
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 7 {
		// (, line 200
		// <-, line 200
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 8 {
		// (, line 201
		// <-, line 201
		if !env.SliceFrom("e") {
			return false
		}
	} else if among_var == 9 {
		// (, line 202
		// delete, line 202
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 10 {
		// (, line 203
		// delete, line 203
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 11 {
		// (, line 204
		// delete, line 204
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 12 {
		// (, line 205
		// <-, line 205
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 13 {
		// (, line 206
		// <-, line 206
		if !env.SliceFrom("e") {
			return false
		}
	} else if among_var == 14 {
		// (, line 207
		// delete, line 207
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 15 {
		// (, line 208
		// delete, line 208
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 16 {
		// (, line 209
		// delete, line 209
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 17 {
		// (, line 210
		// delete, line 210
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 18 {
		// (, line 211
		// <-, line 211
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 19 {
		// (, line 212
		// <-, line 212
		if !env.SliceFrom("e") {
			return false
		}
	} else if among_var == 20 {
		// (, line 214
		// delete, line 214
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 21 {
		// (, line 215
		// delete, line 215
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 22 {
		// (, line 216
		// <-, line 216
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 23 {
		// (, line 217
		// <-, line 217
		if !env.SliceFrom("e") {
			return false
		}
	} else if among_var == 24 {
		// (, line 218
		// delete, line 218
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 25 {
		// (, line 219
		// delete, line 219
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 26 {
		// (, line 220
		// delete, line 220
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 27 {
		// (, line 221
		// <-, line 221
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 28 {
		// (, line 222
		// <-, line 222
		if !env.SliceFrom("e") {
			return false
		}
	} else if among_var == 29 {
		// (, line 223
		// delete, line 223
		if !env.SliceDel() {
			return false
		}
	}
	return true
}

func Stem(env *snowballRuntime.Env) bool {
	var context = &Context{
		i_p1: 0,
	}
	_ = context
	// (, line 228
	// do, line 229
	var v_1 = env.Cursor
lab0:
	for {
		// call mark_regions, line 229
		if !r_mark_regions(env, context) {
			break lab0
		}
		break lab0
	}
	env.Cursor = v_1
	// backwards, line 230
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit
	// (, line 230
	// do, line 231
	var v_2 = env.Limit - env.Cursor
lab1:
	for {
		// call instrum, line 231
		if !r_instrum(env, context) {
			break lab1
		}
		break lab1
	}
	env.Cursor = env.Limit - v_2
	// do, line 232
	var v_3 = env.Limit - env.Cursor
lab2:
	for {
		// call case, line 232
		if !r_case(env, context) {
			break lab2
		}
		break lab2
	}
	env.Cursor = env.Limit - v_3
	// do, line 233
	var v_4 = env.Limit - env.Cursor
lab3:
	for {
		// call case_special, line 233
		if !r_case_special(env, context) {
			break lab3
		}
		break lab3
	}
	env.Cursor = env.Limit - v_4
	// do, line 234
	var v_5 = env.Limit - env.Cursor
lab4:
	for {
		// call case_other, line 234
		if !r_case_other(env, context) {
			break lab4
		}
		break lab4
	}
	env.Cursor = env.Limit - v_5
	// do, line 235
	var v_6 = env.Limit - env.Cursor
lab5:
	for {
		// call factive, line 235
		if !r_factive(env, context) {
			break lab5
		}
		break lab5
	}
	env.Cursor = env.Limit - v_6
	// do, line 236
	var v_7 = env.Limit - env.Cursor
lab6:
	for {
		// call owned, line 236
		if !r_owned(env, context) {
			break lab6
		}
		break lab6
	}
	env.Cursor = env.Limit - v_7
	// do, line 237
	var v_8 = env.Limit - env.Cursor
lab7:
	for {
		// call sing_owner, line 237
		if !r_sing_owner(env, context) {
			break lab7
		}
		break lab7
	}
	env.Cursor = env.Limit - v_8
	// do, line 238
	var v_9 = env.Limit - env.Cursor
lab8:
	for {
		// call plur_owner, line 238
		if !r_plur_owner(env, context) {
			break lab8
		}
		break lab8
	}
	env.Cursor = env.Limit - v_9
	// do, line 239
	var v_10 = env.Limit - env.Cursor
lab9:
	for {
		// call plural, line 239
		if !r_plural(env, context) {
			break lab9
		}
		break lab9
	}
	env.Cursor = env.Limit - v_10
	env.Cursor = env.LimitBackward
	return true
}
