//! This file was generated automatically by the Snowball to Go compiler
//! http://snowballstem.org/

package romanian

import (
	snowballRuntime "github.com/blevesearch/snowballstem"
)

var A_0 = []*snowballRuntime.Among{
	{Str: "", A: -1, B: 3, F: nil},
	{Str: "I", A: 0, B: 1, F: nil},
	{Str: "U", A: 0, B: 2, F: nil},
}

var A_1 = []*snowballRuntime.Among{
	{Str: "ea", A: -1, B: 3, F: nil},
	{Str: "a\u0163ia", A: -1, B: 7, F: nil},
	{Str: "aua", A: -1, B: 2, F: nil},
	{Str: "iua", A: -1, B: 4, F: nil},
	{Str: "a\u0163ie", A: -1, B: 7, F: nil},
	{Str: "ele", A: -1, B: 3, F: nil},
	{Str: "ile", A: -1, B: 5, F: nil},
	{Str: "iile", A: 6, B: 4, F: nil},
	{Str: "iei", A: -1, B: 4, F: nil},
	{Str: "atei", A: -1, B: 6, F: nil},
	{Str: "ii", A: -1, B: 4, F: nil},
	{Str: "ului", A: -1, B: 1, F: nil},
	{Str: "ul", A: -1, B: 1, F: nil},
	{Str: "elor", A: -1, B: 3, F: nil},
	{Str: "ilor", A: -1, B: 4, F: nil},
	{Str: "iilor", A: 14, B: 4, F: nil},
}

var A_2 = []*snowballRuntime.Among{
	{Str: "icala", A: -1, B: 4, F: nil},
	{Str: "iciva", A: -1, B: 4, F: nil},
	{Str: "ativa", A: -1, B: 5, F: nil},
	{Str: "itiva", A: -1, B: 6, F: nil},
	{Str: "icale", A: -1, B: 4, F: nil},
	{Str: "a\u0163iune", A: -1, B: 5, F: nil},
	{Str: "i\u0163iune", A: -1, B: 6, F: nil},
	{Str: "atoare", A: -1, B: 5, F: nil},
	{Str: "itoare", A: -1, B: 6, F: nil},
	{Str: "\u0103toare", A: -1, B: 5, F: nil},
	{Str: "icitate", A: -1, B: 4, F: nil},
	{Str: "abilitate", A: -1, B: 1, F: nil},
	{Str: "ibilitate", A: -1, B: 2, F: nil},
	{Str: "ivitate", A: -1, B: 3, F: nil},
	{Str: "icive", A: -1, B: 4, F: nil},
	{Str: "ative", A: -1, B: 5, F: nil},
	{Str: "itive", A: -1, B: 6, F: nil},
	{Str: "icali", A: -1, B: 4, F: nil},
	{Str: "atori", A: -1, B: 5, F: nil},
	{Str: "icatori", A: 18, B: 4, F: nil},
	{Str: "itori", A: -1, B: 6, F: nil},
	{Str: "\u0103tori", A: -1, B: 5, F: nil},
	{Str: "icitati", A: -1, B: 4, F: nil},
	{Str: "abilitati", A: -1, B: 1, F: nil},
	{Str: "ivitati", A: -1, B: 3, F: nil},
	{Str: "icivi", A: -1, B: 4, F: nil},
	{Str: "ativi", A: -1, B: 5, F: nil},
	{Str: "itivi", A: -1, B: 6, F: nil},
	{Str: "icit\u0103i", A: -1, B: 4, F: nil},
	{Str: "abilit\u0103i", A: -1, B: 1, F: nil},
	{Str: "ivit\u0103i", A: -1, B: 3, F: nil},
	{Str: "icit\u0103\u0163i", A: -1, B: 4, F: nil},
	{Str: "abilit\u0103\u0163i", A: -1, B: 1, F: nil},
	{Str: "ivit\u0103\u0163i", A: -1, B: 3, F: nil},
	{Str: "ical", A: -1, B: 4, F: nil},
	{Str: "ator", A: -1, B: 5, F: nil},
	{Str: "icator", A: 35, B: 4, F: nil},
	{Str: "itor", A: -1, B: 6, F: nil},
	{Str: "\u0103tor", A: -1, B: 5, F: nil},
	{Str: "iciv", A: -1, B: 4, F: nil},
	{Str: "ativ", A: -1, B: 5, F: nil},
	{Str: "itiv", A: -1, B: 6, F: nil},
	{Str: "ical\u0103", A: -1, B: 4, F: nil},
	{Str: "iciv\u0103", A: -1, B: 4, F: nil},
	{Str: "ativ\u0103", A: -1, B: 5, F: nil},
	{Str: "itiv\u0103", A: -1, B: 6, F: nil},
}

var A_3 = []*snowballRuntime.Among{
	{Str: "ica", A: -1, B: 1, F: nil},
	{Str: "abila", A: -1, B: 1, F: nil},
	{Str: "ibila", A: -1, B: 1, F: nil},
	{Str: "oasa", A: -1, B: 1, F: nil},
	{Str: "ata", A: -1, B: 1, F: nil},
	{Str: "ita", A: -1, B: 1, F: nil},
	{Str: "anta", A: -1, B: 1, F: nil},
	{Str: "ista", A: -1, B: 3, F: nil},
	{Str: "uta", A: -1, B: 1, F: nil},
	{Str: "iva", A: -1, B: 1, F: nil},
	{Str: "ic", A: -1, B: 1, F: nil},
	{Str: "ice", A: -1, B: 1, F: nil},
	{Str: "abile", A: -1, B: 1, F: nil},
	{Str: "ibile", A: -1, B: 1, F: nil},
	{Str: "isme", A: -1, B: 3, F: nil},
	{Str: "iune", A: -1, B: 2, F: nil},
	{Str: "oase", A: -1, B: 1, F: nil},
	{Str: "ate", A: -1, B: 1, F: nil},
	{Str: "itate", A: 17, B: 1, F: nil},
	{Str: "ite", A: -1, B: 1, F: nil},
	{Str: "ante", A: -1, B: 1, F: nil},
	{Str: "iste", A: -1, B: 3, F: nil},
	{Str: "ute", A: -1, B: 1, F: nil},
	{Str: "ive", A: -1, B: 1, F: nil},
	{Str: "ici", A: -1, B: 1, F: nil},
	{Str: "abili", A: -1, B: 1, F: nil},
	{Str: "ibili", A: -1, B: 1, F: nil},
	{Str: "iuni", A: -1, B: 2, F: nil},
	{Str: "atori", A: -1, B: 1, F: nil},
	{Str: "osi", A: -1, B: 1, F: nil},
	{Str: "ati", A: -1, B: 1, F: nil},
	{Str: "itati", A: 30, B: 1, F: nil},
	{Str: "iti", A: -1, B: 1, F: nil},
	{Str: "anti", A: -1, B: 1, F: nil},
	{Str: "isti", A: -1, B: 3, F: nil},
	{Str: "uti", A: -1, B: 1, F: nil},
	{Str: "i\u015Fti", A: -1, B: 3, F: nil},
	{Str: "ivi", A: -1, B: 1, F: nil},
	{Str: "it\u0103i", A: -1, B: 1, F: nil},
	{Str: "o\u015Fi", A: -1, B: 1, F: nil},
	{Str: "it\u0103\u0163i", A: -1, B: 1, F: nil},
	{Str: "abil", A: -1, B: 1, F: nil},
	{Str: "ibil", A: -1, B: 1, F: nil},
	{Str: "ism", A: -1, B: 3, F: nil},
	{Str: "ator", A: -1, B: 1, F: nil},
	{Str: "os", A: -1, B: 1, F: nil},
	{Str: "at", A: -1, B: 1, F: nil},
	{Str: "it", A: -1, B: 1, F: nil},
	{Str: "ant", A: -1, B: 1, F: nil},
	{Str: "ist", A: -1, B: 3, F: nil},
	{Str: "ut", A: -1, B: 1, F: nil},
	{Str: "iv", A: -1, B: 1, F: nil},
	{Str: "ic\u0103", A: -1, B: 1, F: nil},
	{Str: "abil\u0103", A: -1, B: 1, F: nil},
	{Str: "ibil\u0103", A: -1, B: 1, F: nil},
	{Str: "oas\u0103", A: -1, B: 1, F: nil},
	{Str: "at\u0103", A: -1, B: 1, F: nil},
	{Str: "it\u0103", A: -1, B: 1, F: nil},
	{Str: "ant\u0103", A: -1, B: 1, F: nil},
	{Str: "ist\u0103", A: -1, B: 3, F: nil},
	{Str: "ut\u0103", A: -1, B: 1, F: nil},
	{Str: "iv\u0103", A: -1, B: 1, F: nil},
}

var A_4 = []*snowballRuntime.Among{
	{Str: "ea", A: -1, B: 1, F: nil},
	{Str: "ia", A: -1, B: 1, F: nil},
	{Str: "esc", A: -1, B: 1, F: nil},
	{Str: "\u0103sc", A: -1, B: 1, F: nil},
	{Str: "ind", A: -1, B: 1, F: nil},
	{Str: "\u00E2nd", A: -1, B: 1, F: nil},
	{Str: "are", A: -1, B: 1, F: nil},
	{Str: "ere", A: -1, B: 1, F: nil},
	{Str: "ire", A: -1, B: 1, F: nil},
	{Str: "\u00E2re", A: -1, B: 1, F: nil},
	{Str: "se", A: -1, B: 2, F: nil},
	{Str: "ase", A: 10, B: 1, F: nil},
	{Str: "sese", A: 10, B: 2, F: nil},
	{Str: "ise", A: 10, B: 1, F: nil},
	{Str: "use", A: 10, B: 1, F: nil},
	{Str: "\u00E2se", A: 10, B: 1, F: nil},
	{Str: "e\u015Fte", A: -1, B: 1, F: nil},
	{Str: "\u0103\u015Fte", A: -1, B: 1, F: nil},
	{Str: "eze", A: -1, B: 1, F: nil},
	{Str: "ai", A: -1, B: 1, F: nil},
	{Str: "eai", A: 19, B: 1, F: nil},
	{Str: "iai", A: 19, B: 1, F: nil},
	{Str: "sei", A: -1, B: 2, F: nil},
	{Str: "e\u015Fti", A: -1, B: 1, F: nil},
	{Str: "\u0103\u015Fti", A: -1, B: 1, F: nil},
	{Str: "ui", A: -1, B: 1, F: nil},
	{Str: "ezi", A: -1, B: 1, F: nil},
	{Str: "a\u015Fi", A: -1, B: 1, F: nil},
	{Str: "se\u015Fi", A: -1, B: 2, F: nil},
	{Str: "ase\u015Fi", A: 28, B: 1, F: nil},
	{Str: "sese\u015Fi", A: 28, B: 2, F: nil},
	{Str: "ise\u015Fi", A: 28, B: 1, F: nil},
	{Str: "use\u015Fi", A: 28, B: 1, F: nil},
	{Str: "\u00E2se\u015Fi", A: 28, B: 1, F: nil},
	{Str: "i\u015Fi", A: -1, B: 1, F: nil},
	{Str: "u\u015Fi", A: -1, B: 1, F: nil},
	{Str: "\u00E2\u015Fi", A: -1, B: 1, F: nil},
	{Str: "\u00E2i", A: -1, B: 1, F: nil},
	{Str: "a\u0163i", A: -1, B: 2, F: nil},
	{Str: "ea\u0163i", A: 38, B: 1, F: nil},
	{Str: "ia\u0163i", A: 38, B: 1, F: nil},
	{Str: "e\u0163i", A: -1, B: 2, F: nil},
	{Str: "i\u0163i", A: -1, B: 2, F: nil},
	{Str: "ar\u0103\u0163i", A: -1, B: 1, F: nil},
	{Str: "ser\u0103\u0163i", A: -1, B: 2, F: nil},
	{Str: "aser\u0103\u0163i", A: 44, B: 1, F: nil},
	{Str: "seser\u0103\u0163i", A: 44, B: 2, F: nil},
	{Str: "iser\u0103\u0163i", A: 44, B: 1, F: nil},
	{Str: "user\u0103\u0163i", A: 44, B: 1, F: nil},
	{Str: "\u00E2ser\u0103\u0163i", A: 44, B: 1, F: nil},
	{Str: "ir\u0103\u0163i", A: -1, B: 1, F: nil},
	{Str: "ur\u0103\u0163i", A: -1, B: 1, F: nil},
	{Str: "\u00E2r\u0103\u0163i", A: -1, B: 1, F: nil},
	{Str: "\u00E2\u0163i", A: -1, B: 2, F: nil},
	{Str: "am", A: -1, B: 1, F: nil},
	{Str: "eam", A: 54, B: 1, F: nil},
	{Str: "iam", A: 54, B: 1, F: nil},
	{Str: "em", A: -1, B: 2, F: nil},
	{Str: "asem", A: 57, B: 1, F: nil},
	{Str: "sesem", A: 57, B: 2, F: nil},
	{Str: "isem", A: 57, B: 1, F: nil},
	{Str: "usem", A: 57, B: 1, F: nil},
	{Str: "\u00E2sem", A: 57, B: 1, F: nil},
	{Str: "im", A: -1, B: 2, F: nil},
	{Str: "\u0103m", A: -1, B: 2, F: nil},
	{Str: "ar\u0103m", A: 64, B: 1, F: nil},
	{Str: "ser\u0103m", A: 64, B: 2, F: nil},
	{Str: "aser\u0103m", A: 66, B: 1, F: nil},
	{Str: "seser\u0103m", A: 66, B: 2, F: nil},
	{Str: "iser\u0103m", A: 66, B: 1, F: nil},
	{Str: "user\u0103m", A: 66, B: 1, F: nil},
	{Str: "\u00E2ser\u0103m", A: 66, B: 1, F: nil},
	{Str: "ir\u0103m", A: 64, B: 1, F: nil},
	{Str: "ur\u0103m", A: 64, B: 1, F: nil},
	{Str: "\u00E2r\u0103m", A: 64, B: 1, F: nil},
	{Str: "\u00E2m", A: -1, B: 2, F: nil},
	{Str: "au", A: -1, B: 1, F: nil},
	{Str: "eau", A: 76, B: 1, F: nil},
	{Str: "iau", A: 76, B: 1, F: nil},
	{Str: "indu", A: -1, B: 1, F: nil},
	{Str: "\u00E2ndu", A: -1, B: 1, F: nil},
	{Str: "ez", A: -1, B: 1, F: nil},
	{Str: "easc\u0103", A: -1, B: 1, F: nil},
	{Str: "ar\u0103", A: -1, B: 1, F: nil},
	{Str: "ser\u0103", A: -1, B: 2, F: nil},
	{Str: "aser\u0103", A: 84, B: 1, F: nil},
	{Str: "seser\u0103", A: 84, B: 2, F: nil},
	{Str: "iser\u0103", A: 84, B: 1, F: nil},
	{Str: "user\u0103", A: 84, B: 1, F: nil},
	{Str: "\u00E2ser\u0103", A: 84, B: 1, F: nil},
	{Str: "ir\u0103", A: -1, B: 1, F: nil},
	{Str: "ur\u0103", A: -1, B: 1, F: nil},
	{Str: "\u00E2r\u0103", A: -1, B: 1, F: nil},
	{Str: "eaz\u0103", A: -1, B: 1, F: nil},
}

var A_5 = []*snowballRuntime.Among{
	{Str: "a", A: -1, B: 1, F: nil},
	{Str: "e", A: -1, B: 1, F: nil},
	{Str: "ie", A: 1, B: 1, F: nil},
	{Str: "i", A: -1, B: 1, F: nil},
	{Str: "\u0103", A: -1, B: 1, F: nil},
}

var G_v = []byte{17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 32, 0, 0, 4}

type Context struct {
	b_standard_suffix_removed bool
	i_p2                      int
	i_p1                      int
	i_pV                      int
}

func r_prelude(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 31
	// repeat, line 32
replab0:
	for {
		var v_1 = env.Cursor
	lab1:
		for range [2]struct{}{} {
			// goto, line 32
		golab2:
			for {
				var v_2 = env.Cursor
			lab3:
				for {
					// (, line 32
					if !env.InGrouping(G_v, 97, 259) {
						break lab3
					}
					// [, line 33
					env.Bra = env.Cursor
					// or, line 33
				lab4:
					for {
						var v_3 = env.Cursor
					lab5:
						for {
							// (, line 33
							// literal, line 33
							if !env.EqS("u") {
								break lab5
							}
							// ], line 33
							env.Ket = env.Cursor
							if !env.InGrouping(G_v, 97, 259) {
								break lab5
							}
							// <-, line 33
							if !env.SliceFrom("U") {
								return false
							}
							break lab4
						}
						env.Cursor = v_3
						// (, line 34
						// literal, line 34
						if !env.EqS("i") {
							break lab3
						}
						// ], line 34
						env.Ket = env.Cursor
						if !env.InGrouping(G_v, 97, 259) {
							break lab3
						}
						// <-, line 34
						if !env.SliceFrom("I") {
							return false
						}
						break lab4
					}
					env.Cursor = v_2
					break golab2
				}
				env.Cursor = v_2
				if env.Cursor >= env.Limit {
					break lab1
				}
				env.NextChar()
			}
			continue replab0
		}
		env.Cursor = v_1
		break replab0
	}
	return true
}

func r_mark_regions(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 38
	context.i_pV = env.Limit
	context.i_p1 = env.Limit
	context.i_p2 = env.Limit
	// do, line 44
	var v_1 = env.Cursor
lab0:
	for {
		// (, line 44
		// or, line 46
	lab1:
		for {
			var v_2 = env.Cursor
		lab2:
			for {
				// (, line 45
				if !env.InGrouping(G_v, 97, 259) {
					break lab2
				}
				// or, line 45
			lab3:
				for {
					var v_3 = env.Cursor
				lab4:
					for {
						// (, line 45
						if !env.OutGrouping(G_v, 97, 259) {
							break lab4
						}
						// gopast, line 45
					golab5:
						for {
						lab6:
							for {
								if !env.InGrouping(G_v, 97, 259) {
									break lab6
								}
								break golab5
							}
							if env.Cursor >= env.Limit {
								break lab4
							}
							env.NextChar()
						}
						break lab3
					}
					env.Cursor = v_3
					// (, line 45
					if !env.InGrouping(G_v, 97, 259) {
						break lab2
					}
					// gopast, line 45
				golab7:
					for {
					lab8:
						for {
							if !env.OutGrouping(G_v, 97, 259) {
								break lab8
							}
							break golab7
						}
						if env.Cursor >= env.Limit {
							break lab2
						}
						env.NextChar()
					}
					break lab3
				}
				break lab1
			}
			env.Cursor = v_2
			// (, line 47
			if !env.OutGrouping(G_v, 97, 259) {
				break lab0
			}
			// or, line 47
		lab9:
			for {
				var v_6 = env.Cursor
			lab10:
				for {
					// (, line 47
					if !env.OutGrouping(G_v, 97, 259) {
						break lab10
					}
					// gopast, line 47
				golab11:
					for {
					lab12:
						for {
							if !env.InGrouping(G_v, 97, 259) {
								break lab12
							}
							break golab11
						}
						if env.Cursor >= env.Limit {
							break lab10
						}
						env.NextChar()
					}
					break lab9
				}
				env.Cursor = v_6
				// (, line 47
				if !env.InGrouping(G_v, 97, 259) {
					break lab0
				}
				// next, line 47
				if env.Cursor >= env.Limit {
					break lab0
				}
				env.NextChar()
				break lab9
			}
			break lab1
		}
		// setmark pV, line 48
		context.i_pV = env.Cursor
		break lab0
	}
	env.Cursor = v_1
	// do, line 50
	var v_8 = env.Cursor
lab13:
	for {
		// (, line 50
		// gopast, line 51
	golab14:
		for {
		lab15:
			for {
				if !env.InGrouping(G_v, 97, 259) {
					break lab15
				}
				break golab14
			}
			if env.Cursor >= env.Limit {
				break lab13
			}
			env.NextChar()
		}
		// gopast, line 51
	golab16:
		for {
		lab17:
			for {
				if !env.OutGrouping(G_v, 97, 259) {
					break lab17
				}
				break golab16
			}
			if env.Cursor >= env.Limit {
				break lab13
			}
			env.NextChar()
		}
		// setmark p1, line 51
		context.i_p1 = env.Cursor
		// gopast, line 52
	golab18:
		for {
		lab19:
			for {
				if !env.InGrouping(G_v, 97, 259) {
					break lab19
				}
				break golab18
			}
			if env.Cursor >= env.Limit {
				break lab13
			}
			env.NextChar()
		}
		// gopast, line 52
	golab20:
		for {
		lab21:
			for {
				if !env.OutGrouping(G_v, 97, 259) {
					break lab21
				}
				break golab20
			}
			if env.Cursor >= env.Limit {
				break lab13
			}
			env.NextChar()
		}
		// setmark p2, line 52
		context.i_p2 = env.Cursor
		break lab13
	}
	env.Cursor = v_8
	return true
}

func r_postlude(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// repeat, line 56
replab0:
	for {
		var v_1 = env.Cursor
	lab1:
		for range [2]struct{}{} {
			// (, line 56
			// [, line 58
			env.Bra = env.Cursor
			// substring, line 58
			among_var = env.FindAmong(A_0, context)
			if among_var == 0 {
				break lab1
			}
			// ], line 58
			env.Ket = env.Cursor
			if among_var == 0 {
				break lab1
			} else if among_var == 1 {
				// (, line 59
				// <-, line 59
				if !env.SliceFrom("i") {
					return false
				}
			} else if among_var == 2 {
				// (, line 60
				// <-, line 60
				if !env.SliceFrom("u") {
					return false
				}
			} else if among_var == 3 {
				// (, line 61
				// next, line 61
				if env.Cursor >= env.Limit {
					break lab1
				}
				env.NextChar()
			}
			continue replab0
		}
		env.Cursor = v_1
		break replab0
	}
	return true
}

func r_RV(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_pV <= env.Cursor) {
		return false
	}
	return true
}

func r_R1(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_p1 <= env.Cursor) {
		return false
	}
	return true
}

func r_R2(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_p2 <= env.Cursor) {
		return false
	}
	return true
}

func r_step_0(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 72
	// [, line 73
	env.Ket = env.Cursor
	// substring, line 73
	among_var = env.FindAmongB(A_1, context)
	if among_var == 0 {
		return false
	}
	// ], line 73
	env.Bra = env.Cursor
	// call R1, line 73
	if !r_R1(env, context) {
		return false
	}
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 75
		// delete, line 75
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		// (, line 77
		// <-, line 77
		if !env.SliceFrom("a") {
			return false
		}
	} else if among_var == 3 {
		// (, line 79
		// <-, line 79
		if !env.SliceFrom("e") {
			return false
		}
	} else if among_var == 4 {
		// (, line 81
		// <-, line 81
		if !env.SliceFrom("i") {
			return false
		}
	} else if among_var == 5 {
		// (, line 83
		// not, line 83
		var v_1 = env.Limit - env.Cursor
	lab0:
		for {
			// literal, line 83
			if !env.EqSB("ab") {
				break lab0
			}
			return false
		}
		env.Cursor = env.Limit - v_1
		// <-, line 83
		if !env.SliceFrom("i") {
			return false
		}
	} else if among_var == 6 {
		// (, line 85
		// <-, line 85
		if !env.SliceFrom("at") {
			return false
		}
	} else if among_var == 7 {
		// (, line 87
		// <-, line 87
		if !env.SliceFrom("a\u0163i") {
			return false
		}
	}
	return true
}

func r_combo_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// test, line 91
	var v_1 = env.Limit - env.Cursor
	// (, line 91
	// [, line 92
	env.Ket = env.Cursor
	// substring, line 92
	among_var = env.FindAmongB(A_2, context)
	if among_var == 0 {
		return false
	}
	// ], line 92
	env.Bra = env.Cursor
	// call R1, line 92
	if !r_R1(env, context) {
		return false
	}
	// (, line 92
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 100
		// <-, line 101
		if !env.SliceFrom("abil") {
			return false
		}
	} else if among_var == 2 {
		// (, line 103
		// <-, line 104
		if !env.SliceFrom("ibil") {
			return false
		}
	} else if among_var == 3 {
		// (, line 106
		// <-, line 107
		if !env.SliceFrom("iv") {
			return false
		}
	} else if among_var == 4 {
		// (, line 112
		// <-, line 113
		if !env.SliceFrom("ic") {
			return false
		}
	} else if among_var == 5 {
		// (, line 117
		// <-, line 118
		if !env.SliceFrom("at") {
			return false
		}
	} else if among_var == 6 {
		// (, line 121
		// <-, line 122
		if !env.SliceFrom("it") {
			return false
		}
	}
	// set standard_suffix_removed, line 125
	context.b_standard_suffix_removed = true
	env.Cursor = env.Limit - v_1
	return true
}

func r_standard_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 129
	// unset standard_suffix_removed, line 130
	context.b_standard_suffix_removed = false
	// repeat, line 131
replab0:
	for {
		var v_1 = env.Limit - env.Cursor
	lab1:
		for range [2]struct{}{} {
			// call combo_suffix, line 131
			if !r_combo_suffix(env, context) {
				break lab1
			}
			continue replab0
		}
		env.Cursor = env.Limit - v_1
		break replab0
	}
	// [, line 132
	env.Ket = env.Cursor
	// substring, line 132
	among_var = env.FindAmongB(A_3, context)
	if among_var == 0 {
		return false
	}
	// ], line 132
	env.Bra = env.Cursor
	// call R2, line 132
	if !r_R2(env, context) {
		return false
	}
	// (, line 132
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 148
		// delete, line 149
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		// (, line 151
		// literal, line 152
		if !env.EqSB("\u0163") {
			return false
		}
		// ], line 152
		env.Bra = env.Cursor
		// <-, line 152
		if !env.SliceFrom("t") {
			return false
		}
	} else if among_var == 3 {
		// (, line 155
		// <-, line 156
		if !env.SliceFrom("ist") {
			return false
		}
	}
	// set standard_suffix_removed, line 160
	context.b_standard_suffix_removed = true
	return true
}

func r_verb_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// setlimit, line 164
	var v_1 = env.Limit - env.Cursor
	// tomark, line 164
	if env.Cursor < context.i_pV {
		return false
	}
	env.Cursor = context.i_pV
	var v_2 = env.LimitBackward
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit - v_1
	// (, line 164
	// [, line 165
	env.Ket = env.Cursor
	// substring, line 165
	among_var = env.FindAmongB(A_4, context)
	if among_var == 0 {
		env.LimitBackward = v_2
		return false
	}
	// ], line 165
	env.Bra = env.Cursor
	if among_var == 0 {
		env.LimitBackward = v_2
		return false
	} else if among_var == 1 {
		// (, line 200
		// or, line 200
	lab0:
		for {
			var v_3 = env.Limit - env.Cursor
		lab1:
			for {
				if !env.OutGroupingB(G_v, 97, 259) {
					break lab1
				}
				break lab0
			}
			env.Cursor = env.Limit - v_3
			// literal, line 200
			if !env.EqSB("u") {
				env.LimitBackward = v_2
				return false
			}
			break lab0
		}
		// delete, line 200
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		// (, line 214
		// delete, line 214
		if !env.SliceDel() {
			return false
		}
	}
	env.LimitBackward = v_2
	return true
}

func r_vowel_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 218
	// [, line 219
	env.Ket = env.Cursor
	// substring, line 219
	among_var = env.FindAmongB(A_5, context)
	if among_var == 0 {
		return false
	}
	// ], line 219
	env.Bra = env.Cursor
	// call RV, line 219
	if !r_RV(env, context) {
		return false
	}
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 220
		// delete, line 220
		if !env.SliceDel() {
			return false
		}
	}
	return true
}

func Stem(env *snowballRuntime.Env) bool {
	var context = &Context{
		b_standard_suffix_removed: false,
		i_p2: 0,
		i_p1: 0,
		i_pV: 0,
	}
	_ = context
	// (, line 225
	// do, line 226
	var v_1 = env.Cursor
lab0:
	for {
		// call prelude, line 226
		if !r_prelude(env, context) {
			break lab0
		}
		break lab0
	}
	env.Cursor = v_1
	// do, line 227
	var v_2 = env.Cursor
lab1:
	for {
		// call mark_regions, line 227
		if !r_mark_regions(env, context) {
			break lab1
		}
		break lab1
	}
	env.Cursor = v_2
	// backwards, line 228
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit
	// (, line 228
	// do, line 229
	var v_3 = env.Limit - env.Cursor
lab2:
	for {
		// call step_0, line 229
		if !r_step_0(env, context) {
			break lab2
		}
		break lab2
	}
	env.Cursor = env.Limit - v_3
	// do, line 230
	var v_4 = env.Limit - env.Cursor
lab3:
	for {
		// call standard_suffix, line 230
		if !r_standard_suffix(env, context) {
			break lab3
		}
		break lab3
	}
	env.Cursor = env.Limit - v_4
	// do, line 231
	var v_5 = env.Limit - env.Cursor
lab4:
	for {
		// (, line 231
		// or, line 231
	lab5:
		for {
			var v_6 = env.Limit - env.Cursor
		lab6:
			for {
				// Boolean test standard_suffix_removed, line 231
				if !context.b_standard_suffix_removed {
					break lab6
				}
				break lab5
			}
			env.Cursor = env.Limit - v_6
			// call verb_suffix, line 231
			if !r_verb_suffix(env, context) {
				break lab4
			}
			break lab5
		}
		break lab4
	}
	env.Cursor = env.Limit - v_5
	// do, line 232
	var v_7 = env.Limit - env.Cursor
lab7:
	for {
		// call vowel_suffix, line 232
		if !r_vowel_suffix(env, context) {
			break lab7
		}
		break lab7
	}
	env.Cursor = env.Limit - v_7
	env.Cursor = env.LimitBackward
	// do, line 234
	var v_8 = env.Cursor
lab8:
	for {
		// call postlude, line 234
		if !r_postlude(env, context) {
			break lab8
		}
		break lab8
	}
	env.Cursor = v_8
	return true
}
